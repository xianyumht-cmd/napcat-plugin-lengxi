import fs, { promises, existsSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'node:url';
import require$$0 from 'util';
import require$$1 from 'stream';
import require$$1$1 from 'zlib';
import require$$0$1 from 'assert';
import require$$3 from 'buffer';

const DEFAULT_MSG_FILTER = {
  blockVideo: false,
  blockImage: false,
  blockRecord: false,
  blockForward: false,
  blockLightApp: false,
  blockContact: false,
  blockUrl: false,
  blockQr: false
};
const DEFAULT_GROUP_SETTINGS = {
  useGlobal: true,
  autoApprove: true,
  enableVerify: true,
  verifyTimeout: 300,
  maxAttempts: 5,
  mathMin: 1,
  mathMax: 100,
  targetUsers: [],
  groupBlacklist: [],
  leaveBlacklist: false,
  warningLimit: 3,
  warningAction: "ban",
  enableCurfew: false,
  curfewStart: "00:00",
  curfewEnd: "06:00",
  messageReward: 0,
  signinMin: 10,
  signinMax: 50,
  invitePoints: 20,
  lotteryCost: 50,
  lotteryReward: 200,
  autoRecallSelf: false,
  autoRecallSelfDelay: 60,
  randomSuffix: true,
  randomDelayMin: 500,
  randomDelayMax: 1500,
  disableQA: false,
  disableSignin: false,
  disableLottery: false,
  disableInvite: false,
  disableActivity: false
};
const DEFAULT_PLUGIN_CONFIG = {
  licenseKey: "",
  debug: false,
  ownerQQs: "",
  licenses: {},
  global: { ...DEFAULT_GROUP_SETTINGS, useGlobal: false },
  groups: {},
  antiRecallGroups: [],
  globalAntiRecall: false,
  globalEmojiReact: false,
  emojiReactGroups: {},
  cardLocks: {},
  blacklist: [],
  whitelist: [],
  filterKeywords: [],
  filterPunishLevel: 1,
  filterBanMinutes: 10,
  welcomeMessage: "æ¬¢è¿ {user} åŠ å…¥æœ¬ç¾¤ï¼",
  spamWindow: 10,
  spamThreshold: 10,
  spamDetect: false,
  spamBanMinutes: 5,
  leaveBlacklist: false,
  lolToken: "",
  lolQueryUrl: "",
  lolAuthKey: "",
  msgFilter: { ...DEFAULT_MSG_FILTER },
  qaList: [],
  rejectKeywords: [],
  presets: []
};
const RISK_CONTROL_MENU = `ğŸ›¡ï¸ é£æ§ä¸å®‰å…¨è®¾ç½®
----------------
â€¢ å¼€å¯/å…³é—­åˆ·å±æ£€æµ‹
â€¢ è®¾ç½®åˆ·å±é˜ˆå€¼ <æ¬¡æ•°> (é»˜è®¤10)
â€¢ è®¾ç½®åˆ·å±æ—¶é—´ <ç§’> (é»˜è®¤10)
â€¢ è®¾ç½®å¤è¯»é˜ˆå€¼ <æ¬¡æ•°> (é»˜è®¤0å…³é—­)
â€¢ å¼€å¯/å…³é—­è‡ªèº«æ’¤å›
â€¢ è®¾ç½®è‡ªèº«æ’¤å›æ—¶é—´ <ç§’>
â€¢ å¼€å¯/å…³é—­å…¥ç¾¤éªŒè¯
â€¢ è®¾ç½®æƒé™ç¼“å­˜ <ç§’> (é»˜è®¤60)
â€¢ å¼€å¯/å…³é—­å®µç¦
â€¢ è®¾ç½®å®µç¦æ—¶é—´ <å¼€å§‹> <ç»“æŸ>`;

function getPluginVersion() {
  try {
    const __dirname = path.dirname(fileURLToPath(import.meta.url));
    const pkgPath = path.join(__dirname, "package.json");
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
      return pkg.version || "1.0.0";
    }
  } catch {
  }
  return "1.0.0";
}
class PluginState {
  /** æ’ä»¶ç‰ˆæœ¬ï¼ˆè¿è¡Œæ—¶ä» package.json è¯»å–ï¼‰ */
  version = getPluginVersion();
  logger = null;
  actions;
  adapterName = "";
  networkConfig = null;
  config = JSON.parse(JSON.stringify(DEFAULT_PLUGIN_CONFIG));
  sessions = /* @__PURE__ */ new Map();
  pendingComments = /* @__PURE__ */ new Map();
  botId = "";
  // æœºå™¨äººè‡ªèº«QQå·
  /** é˜²æ’¤å›æ¶ˆæ¯ç¼“å­˜ key: messageId */
  msgCache = /* @__PURE__ */ new Map();
  /** åˆ·å±æ£€æµ‹ç¼“å­˜ key: `${groupId}:${userId}`, value: æ—¶é—´æˆ³æ•°ç»„ */
  spamCache = /* @__PURE__ */ new Map();
  /** å¤è¯»æ£€æµ‹ç¼“å­˜ key: `${groupId}:${userId}`, value: { content: string, count: number } */
  repeatCache = /* @__PURE__ */ new Map();
  /** è°ƒè¯•æ—¥å¿—ç¼“å†²åŒº */
  logBuffer = [];
  maxLogEntries = 500;
  /** ç®¡ç†å‘˜æƒé™ç¼“å­˜ key: `${groupId}:${userId}`, value: { role: string, expire: number } */
  adminCache = /* @__PURE__ */ new Map();
  /** å¯åŠ¨æ—¶é—´ */
  startTime = Date.now();
  /** å¤„ç†æ¶ˆæ¯æ•° */
  msgCount = 0;
  // ===== å†…å­˜ä¼˜åŒ– =====
  /** æ¸…ç†å†…å­˜ç¼“å­˜ */
  cleanCache() {
    const now = Date.now();
    for (const [key, val] of this.msgCache.entries()) {
      if (now - val.time > 3e5) this.msgCache.delete(key);
    }
    for (const [key, val] of this.adminCache.entries()) {
      if (now > val.expire + 6e5) this.adminCache.delete(key);
    }
    for (const [key, val] of this.sessions.entries()) {
      if (now - val.startTime > 6e5) this.sessions.delete(key);
    }
    if (this.logBuffer.length > 200) {
      this.logBuffer = this.logBuffer.slice(-200);
    }
  }
  pushLog(level, msg) {
    this.logBuffer.push({ time: Date.now(), level, msg });
    if (this.logBuffer.length > this.maxLogEntries) this.logBuffer.splice(0, this.logBuffer.length - this.maxLogEntries);
  }
  log(level, msg) {
    this.logger?.[level](`[GroupGuard] ${msg}`);
    this.pushLog(level, msg);
  }
  clearLogs() {
    this.logBuffer = [];
  }
  debug(msg) {
    if (this.config.debug) {
      this.logger?.info(`[GroupGuard][Debug] ${msg}`);
      this.pushLog("info", `[Debug] ${msg}`);
    }
  }
  getGroupSettings(groupId) {
    if (this.config.groups[groupId]) {
      if (this.config.groups[groupId].useGlobal) return this.config.global;
      return { ...this.config.global, ...this.config.groups[groupId] };
    }
    return this.config.global;
  }
  isWhitelisted(userId) {
    return this.config.whitelist.includes(userId);
  }
  isBlacklisted(userId) {
    return this.config.blacklist.includes(userId);
  }
  isOwner(userId) {
    const ownersStr = String(this.config.ownerQQs || "");
    const configOwners = ownersStr.split(/[,ï¼Œ]/).map((s) => s.trim()).filter((s) => s);
    const target = String(userId);
    const isMatch = configOwners.includes(target);
    if (this.config.debug) {
      this.log("info", `[AuthCheck] User: "${target}", Config: "${ownersStr}", Parsed: ${JSON.stringify(configOwners)}, Result: ${isMatch}`);
    }
    return isMatch;
  }
  // ===== è¾…åŠ©æ–¹æ³• =====
  /** ç”Ÿæˆéšæœºåç¼€ */
  getRandomSuffix(groupId) {
    const settings = this.config.global;
    if (!settings.randomSuffix) return "";
    const chars = ["â€‹", "â€Œ", "â€", "â ", " ", ".", "..", "~"];
    const len = Math.floor(Math.random() * 3) + 1;
    let suffix = "";
    for (let i = 0; i < len; i++) {
      suffix += chars[Math.floor(Math.random() * chars.length)];
    }
    return suffix;
  }
  /** éšæœºå»¶è¿Ÿ */
  async randomSleep(groupId) {
    const settings = this.config.global;
    const min = settings.randomDelayMin || 0;
    const max = settings.randomDelayMax || 0;
    if (max > min && max > 0) {
      const delay = Math.floor(Math.random() * (max - min + 1)) + min;
      if (delay > 0) {
        if (this.config.debug) this.log("info", `[AntiRisk] éšæœºå»¶è¿Ÿ: ${delay}ms`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }
  /** å‘é€ç¾¤æ¶ˆæ¯ (Text) */
  async sendGroupText(groupId, content) {
    if (!this.actions || !this.networkConfig) return;
    await this.randomSleep(groupId);
    const suffix = this.getRandomSuffix(groupId);
    const finalContent = content + suffix;
    try {
      const res = await this.actions.call("send_group_msg", {
        group_id: groupId,
        message: [{ type: "text", data: { text: finalContent } }]
      }, this.adapterName, this.networkConfig);
      if (res && res.message_id) {
        const settings = this.getGroupSettings(groupId);
        if (settings.autoRecallSelf) {
          const delay = (settings.autoRecallSelfDelay || 60) * 1e3;
          setTimeout(() => {
            this.callApi("delete_msg", { message_id: res.message_id }).catch(() => {
            });
          }, delay);
        }
      }
    } catch (e) {
      this.log("error", `å‘é€ç¾¤æ¶ˆæ¯å¤±è´¥: ${e}`);
    }
  }
  /** å‘é€ç¾¤æ¶ˆæ¯ (Array) */
  async sendGroupMsg(groupId, message) {
    if (!this.actions || !this.networkConfig) return;
    await this.randomSleep(groupId);
    const suffix = this.getRandomSuffix(groupId);
    if (suffix && Array.isArray(message)) {
      const lastNode = message[message.length - 1];
      if (lastNode && lastNode.type === "text" && lastNode.data) {
        lastNode.data.text += suffix;
      } else {
        message.push({ type: "text", data: { text: suffix } });
      }
    }
    try {
      const res = await this.actions.call("send_group_msg", {
        group_id: groupId,
        message
      }, this.adapterName, this.networkConfig);
      if (res && res.message_id) {
        const settings = this.getGroupSettings(groupId);
        if (settings.autoRecallSelf) {
          const delay = (settings.autoRecallSelfDelay || 60) * 1e3;
          setTimeout(() => {
            this.callApi("delete_msg", { message_id: res.message_id }).catch(() => {
            });
          }, delay);
        }
      }
    } catch (e) {
      this.log("error", `å‘é€ç¾¤æ¶ˆæ¯å¤±è´¥: ${e}`);
    }
  }
  /** å‘é€ç§èŠæ¶ˆæ¯ (Text) */
  async sendPrivateMsg(userId, content) {
    if (!this.actions || !this.networkConfig) return;
    await this.randomSleep();
    const suffix = this.getRandomSuffix();
    const finalContent = content + suffix;
    try {
      await this.actions.call("send_private_msg", {
        user_id: userId,
        message: [{ type: "text", data: { text: finalContent } }]
      }, this.adapterName, this.networkConfig);
    } catch (e) {
      this.log("error", `å‘é€ç§èŠæ¶ˆæ¯å¤±è´¥: ${e}`);
    }
  }
  /** è°ƒç”¨ API */
  async callApi(action, params) {
    if (!this.actions || !this.networkConfig) return;
    if (action === "delete_msg" && params && params.message_id) {
      params.message_id = String(params.message_id);
    }
    try {
      return await this.actions.call(action, params, this.adapterName, this.networkConfig);
    } catch (e) {
      const errMsg = String(e);
      if (action === "delete_msg") {
        if (errMsg.includes("Timeout") || errMsg.includes("No data returned") || errMsg.includes("decode failed")) {
          if (this.config.debug) this.log("warn", `æ’¤å›æ¶ˆæ¯è¯·æ±‚è¶…æ—¶ï¼Œå°è¯•é‡è¯•ä¸€æ¬¡...`);
          await new Promise((resolve) => setTimeout(resolve, 300));
          try {
            return await this.actions.call(action, params, this.adapterName, this.networkConfig);
          } catch (retryErr) {
            if (this.config.debug) this.log("info", `æ’¤å›æ¶ˆæ¯æœ€ç»ˆç¡®è®¤: å·²å¤„ç†æˆ–å¤±æ•ˆ`);
            return null;
          }
        }
        if (this.config.debug) this.log("warn", `æ’¤å›æ¶ˆæ¯ API è°ƒç”¨å¼‚å¸¸: ${errMsg}`);
        return null;
      }
      this.log("error", `APIè°ƒç”¨å¤±è´¥ [${action}]: ${e}`);
      return null;
    }
  }
  /** æ£€æŸ¥æœºå™¨äººæ˜¯å¦ä¸ºç®¡ç†å‘˜ */
  async isBotAdmin(groupId) {
    if (!this.botId) return false;
    try {
      const info = await this.callApi("get_group_member_info", { group_id: groupId, user_id: this.botId });
      return info?.role === "admin" || info?.role === "owner";
    } catch {
      return false;
    }
  }
}
const pluginState = new PluginState();

class AuthManager {
  static instance;
  checkInterval = null;
  constructor() {
  }
  static getInstance() {
    if (!AuthManager.instance) {
      AuthManager.instance = new AuthManager();
    }
    return AuthManager.instance;
  }
  /**
   * åˆå§‹åŒ–æˆæƒæ£€æŸ¥
   */
  init() {
    if (this.checkInterval) clearInterval(this.checkInterval);
    this.checkInterval = setInterval(() => {
      this.checkLicenses();
    }, 36e5);
  }
  async checkLicenses() {
    const now = Date.now();
    if (!pluginState.config.licenses) pluginState.config.licenses = {};
    for (const [groupId, license] of Object.entries(pluginState.config.licenses)) {
      if (license.expireTime > 0 && now > license.expireTime) {
        pluginState.log("info", `ç¾¤ ${groupId} æˆæƒå·²è¿‡æœŸï¼Œè‡ªåŠ¨é™çº§ä¸ºå…è´¹ç‰ˆ`);
        delete pluginState.config.licenses[groupId];
        await pluginState.sendGroupText(groupId, "âš ï¸ æœ¬ç¾¤æˆæƒå·²è¿‡æœŸï¼Œæ‰€æœ‰é«˜çº§åŠŸèƒ½å·²å¤±æ•ˆã€‚è¯·è”ç³»ç®¡ç†å‘˜ç»­è´¹ã€‚");
        continue;
      }
      if (license.expireTime > 0 && license.expireTime - now < 24 * 3600 * 1e3) {
        const remainingHours = (license.expireTime - now) / 36e5;
        if (remainingHours > 23 && remainingHours < 24 || remainingHours > 1 && remainingHours < 2) {
          await pluginState.sendGroupText(groupId, `ğŸ”” ã€ç³»ç»Ÿé¢„è­¦ã€‘æœ¬ç¾¤æˆæƒå³å°†äº ${Math.ceil(remainingHours)} å°æ—¶ååˆ°æœŸï¼Œè¯·åŠæ—¶ç»­è´¹ä»¥å…å½±å“ä½¿ç”¨ã€‚`);
        }
      }
    }
  }
  /**
   * è·å–ç¾¤æˆæƒä¿¡æ¯
   */
  getGroupLicense(groupId) {
    if (!pluginState.config.licenses) return null;
    const license = pluginState.config.licenses[groupId];
    if (!license) return null;
    if (license.expireTime > 0 && Date.now() > license.expireTime) {
      delete pluginState.config.licenses[groupId];
      return null;
    }
    return license;
  }
  /**
   * æ£€æŸ¥åŠŸèƒ½æƒé™
   * @param groupId ç¾¤å·
   * @param feature åŠŸèƒ½æ ‡è¯†
   */
  checkFeature(groupId, feature) {
    const license = this.getGroupLicense(groupId);
    if (!license) return false;
    if (license.level === "enterprise") return true;
    if (license.level === "pro") {
      const PRO_FEATURES = ["anti_recall", "regex_qa", "analytics_detail", "warning_system", "curfew", "group_settings"];
      return PRO_FEATURES.includes(feature);
    }
    return false;
  }
  /**
   * æˆäºˆæƒé™
   */
  grantLicense(groupId, days, level = "pro") {
    if (!pluginState.config.licenses) pluginState.config.licenses = {};
    const expireTime = days === -1 ? 0 : Date.now() + days * 24 * 60 * 60 * 1e3;
    pluginState.config.licenses[groupId] = {
      level,
      expireTime
    };
    pluginState.log("info", `ç¾¤ ${groupId} å·²æˆæƒ ${level} ç‰ˆï¼Œæœ‰æ•ˆæœŸ ${days === -1 ? "æ°¸ä¹…" : days + "å¤©"}`);
  }
  /**
   * å›æ”¶æƒé™
   */
  revokeLicense(groupId) {
    if (pluginState.config.licenses && pluginState.config.licenses[groupId]) {
      delete pluginState.config.licenses[groupId];
      pluginState.log("info", `ç¾¤ ${groupId} æˆæƒå·²å›æ”¶`);
    }
  }
}
const authManager = AuthManager.getInstance();

const cache = {
  activity: /* @__PURE__ */ new Map(),
  signin: /* @__PURE__ */ new Map(),
  invites: /* @__PURE__ */ new Map(),
  warnings: /* @__PURE__ */ new Map()
};
const writeQueue = /* @__PURE__ */ new Set();
let writeTimer = null;
const WRITE_DELAY = 5e3;
let dataDir = "";
async function initDB() {
  dataDir = path.join(pluginState.configDir, "data");
  if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
  const groupsDir = path.join(dataDir, "groups");
  if (!fs.existsSync(groupsDir)) fs.mkdirSync(groupsDir, { recursive: true });
  console.log("JSON DB v3.0 (Per-Group Folder) initialized at", dataDir);
}
function loadData(type, groupId) {
  if (cache[type].has(groupId)) {
    return cache[type].get(groupId);
  }
  const groupDir = path.join(dataDir, "groups", groupId);
  const filePath = path.join(groupDir, `${type}.json`);
  try {
    if (fs.existsSync(filePath)) {
      const data = JSON.parse(fs.readFileSync(filePath, "utf-8"));
      cache[type].set(groupId, data);
      return data;
    }
  } catch (e) {
    console.error(`Failed to load ${type} data for group ${groupId}:`, e);
  }
  const empty = {};
  cache[type].set(groupId, empty);
  return empty;
}
function scheduleWrite(type, groupId) {
  const key = `${type}|${groupId}`;
  writeQueue.add(key);
  if (!writeTimer) {
    writeTimer = setTimeout(flushWrites, WRITE_DELAY);
  }
}
function flushWrites() {
  if (writeTimer) {
    clearTimeout(writeTimer);
    writeTimer = null;
  }
  const queue = Array.from(writeQueue);
  writeQueue.clear();
  for (const item of queue) {
    const [type, groupId] = item.split("|");
    const data = cache[type].get(groupId);
    if (!data) continue;
    const groupDir = path.join(dataDir, "groups", groupId);
    if (!fs.existsSync(groupDir)) fs.mkdirSync(groupDir, { recursive: true });
    const filePath = path.join(groupDir, `${type}.json`);
    const tempPath = `${filePath}.tmp`;
    try {
      fs.writeFileSync(tempPath, JSON.stringify(data, null, 2), "utf-8");
      fs.renameSync(tempPath, filePath);
    } catch (e) {
      console.error(`Failed to write ${type} data for group ${groupId}:`, e);
    }
  }
}
setInterval(flushWrites, 6e4);
const dbQuery = {
  // Activity
  getActivity: (groupId, userId) => {
    return void 0;
  },
  getActivityAsync: async (groupId, userId) => {
    const data = loadData("activity", groupId);
    return data[userId] ? { ...data[userId] } : void 0;
  },
  updateActivity: async (groupId, userId, data) => {
    const allData = loadData("activity", groupId);
    allData[userId] = data;
    scheduleWrite("activity", groupId);
  },
  getAllActivity: async (groupId) => {
    return { ...loadData("activity", groupId) };
  },
  // Signin
  getSignin: async (groupId, userId) => {
    const data = loadData("signin", groupId);
    return data[userId] ? { ...data[userId] } : void 0;
  },
  updateSignin: async (groupId, userId, data) => {
    const allData = loadData("signin", groupId);
    allData[userId] = data;
    scheduleWrite("signin", groupId);
  },
  getAllSignin: async (groupId) => {
    return { ...loadData("signin", groupId) };
  },
  // Invites
  getInvite: async (groupId, userId) => {
    const data = loadData("invites", groupId);
    return data[userId] ? { ...data[userId] } : void 0;
  },
  updateInvite: async (groupId, userId, data) => {
    const allData = loadData("invites", groupId);
    allData[userId] = data;
    scheduleWrite("invites", groupId);
  },
  getAllInvites: async (groupId) => {
    return { ...loadData("invites", groupId) };
  },
  // Warnings
  getWarning: async (groupId, userId) => {
    const data = loadData("warnings", groupId);
    return data[userId] || 0;
  },
  setWarning: async (groupId, userId, count) => {
    const allData = loadData("warnings", groupId);
    allData[userId] = count;
    scheduleWrite("warnings", groupId);
  }
};

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function generateMathQuestion(min, max) {
  const a = randInt(min, max);
  const b = randInt(min, max);
  const ops = ["+", "-", "*"];
  const op = ops[randInt(0, 2)];
  let expression, answer;
  switch (op) {
    case "+":
      expression = `${a} + ${b}`;
      answer = a + b;
      break;
    case "-": {
      const big = Math.max(a, b), small = Math.min(a, b);
      expression = `${big} - ${small}`;
      answer = big - small;
      break;
    }
    case "*": {
      const x = randInt(1, 20), y = randInt(1, 20);
      expression = `${x} Ã— ${y}`;
      answer = x * y;
      break;
    }
  }
  return { expression, answer };
}
function sessionKey(groupId, userId) {
  return `${groupId}:${userId}`;
}
function createVerifySession(groupId, userId, comment, welcomeText) {
  const key = sessionKey(groupId, userId);
  const existing = pluginState.sessions.get(key);
  if (existing) clearTimeout(existing.timer);
  const settings = pluginState.getGroupSettings(groupId);
  const { expression, answer } = generateMathQuestion(settings.mathMin, settings.mathMax);
  const timeout = settings.verifyTimeout;
  const maxAttempts = settings.maxAttempts;
  const timer = setTimeout(async () => {
    const session = pluginState.sessions.get(key);
    if (!session) return;
    pluginState.sessions.delete(key);
    pluginState.log("info", `ç”¨æˆ· ${userId} åœ¨ç¾¤ ${groupId} éªŒè¯è¶…æ—¶ï¼Œè¸¢å‡º`);
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` éªŒè¯è¶…æ—¶ï¼Œä½ å·²è¢«ç§»å‡ºç¾¤èŠã€‚` } }
    ]);
    setTimeout(() => pluginState.callApi("set_group_kick", { group_id: groupId, user_id: userId, reject_add_request: false }), 1500);
  }, timeout * 1e3);
  pluginState.sessions.set(key, { userId, groupId, answer, expression, attempts: 0, maxAttempts, timer, createdAt: Date.now() });
  pluginState.debug(`åˆ›å»ºéªŒè¯ä¼šè¯: ${key}, é¢˜ç›®: ${expression} = ${answer}`);
  const cleanComment = comment ? comment.replace(/^é—®é¢˜ï¼š/, "").replace(/\s*ç­”æ¡ˆï¼š/, " ç­”æ¡ˆ:") : "";
  const commentLine = cleanComment ? ` å…¥ç¾¤ä¿¡æ¯:${cleanComment}` : "";
  const welcomeLine = welcomeText ? `${welcomeText}` : "";
  pluginState.sendGroupMsg(groupId, [
    { type: "at", data: { qq: userId } },
    { type: "text", data: { text: ` ${welcomeLine}è¯·åœ¨ã€Œ${timeout}ã€ç§’å†…å‘é€ã€Œ${expression}ã€ç­”æ¡ˆ,å¦åˆ™ç§»å‡ºç¾¤èŠã€‚${commentLine}` } }
  ]);
}
async function handleVerifyAnswer(groupId, userId, rawMessage, messageId) {
  const key = sessionKey(groupId, userId);
  const session = pluginState.sessions.get(key);
  if (!session) return false;
  const trimmed = rawMessage.trim();
  if (!/^-?\d+$/.test(trimmed)) {
    await pluginState.callApi("delete_msg", { message_id: messageId });
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` è¯·å‘é€æ•°å­—ç­”æ¡ˆï¼Œè®¡ç®—ã€Œ${session.expression}ã€çš„ç»“æœã€‚` } }
    ]);
    return true;
  }
  const userAnswer = parseInt(trimmed, 10);
  if (userAnswer === session.answer) {
    clearTimeout(session.timer);
    pluginState.sessions.delete(key);
    pluginState.log("info", `ç”¨æˆ· ${userId} åœ¨ç¾¤ ${groupId} éªŒè¯é€šè¿‡`);
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: " éªŒè¯é€šè¿‡ï¼Œæ¬¢è¿åŠ å…¥ï¼" } }
    ]);
    return true;
  }
  session.attempts++;
  await pluginState.callApi("delete_msg", { message_id: messageId });
  if (session.attempts >= session.maxAttempts) {
    clearTimeout(session.timer);
    pluginState.sessions.delete(key);
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` éªŒè¯å¤±è´¥ï¼Œä½ å·²ç”¨å®Œ ${session.maxAttempts} æ¬¡æœºä¼šï¼Œå·²è¢«ç§»å‡ºç¾¤èŠã€‚` } }
    ]);
    setTimeout(() => pluginState.callApi("set_group_kick", { group_id: groupId, user_id: userId, reject_add_request: false }), 1500);
  } else {
    const remaining = session.maxAttempts - session.attempts;
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` å›ç­”é”™è¯¯ï¼Œè¿˜å‰© ${remaining} æ¬¡æœºä¼šã€‚è¯·é‡æ–°è®¡ç®—ã€Œ${session.expression}ã€çš„ç»“æœã€‚` } }
    ]);
  }
  return true;
}
function clearAllSessions() {
  for (const session of pluginState.sessions.values()) clearTimeout(session.timer);
  pluginState.sessions.clear();
}

var HeaderTypes;
(function (HeaderTypes) {
    HeaderTypes[HeaderTypes["BITMAP_INFO_HEADER"] = 40] = "BITMAP_INFO_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V2_INFO_HEADER"] = 52] = "BITMAP_V2_INFO_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V3_INFO_HEADER"] = 56] = "BITMAP_V3_INFO_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V4_HEADER"] = 108] = "BITMAP_V4_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V5_HEADER"] = 124] = "BITMAP_V5_HEADER";
})(HeaderTypes || (HeaderTypes = {}));

// We have these:
//
// const sample = 0101 0101 0101 0101
// const mask   = 0111 1100 0000 0000
// 256        === 0000 0001 0000 0000
//
// We want to take the sample and turn it into an 8-bit value.
//
// 1. We extract the last bit of the mask:
//
// 0000 0100 0000 0000
//       ^
//
// Like so:
//
// const a = ~mask =    1000 0011 1111 1111
// const b = a + 1 =    1000 0100 0000 0000
// const c = b & mask = 0000 0100 0000 0000
//
// 2. We shift it to the right and extract the bit before the first:
//
// 0000 0000 0010 0000
//             ^
//
// Like so:
//
// const d = mask / c = 0000 0000 0001 1111
// const e = mask + 1 = 0000 0000 0010 0000
//
// 3. We apply the mask and the two values above to a sample:
//
// const f = sample & mask = 0101 0100 0000 0000
// const g = f / c =         0000 0000 0001 0101
// const h = 256 / e =       0000 0000 0000 0100
// const i = g * h =         0000 0000 1010 1000
//                                     ^^^^ ^
//
// Voila, we have extracted a sample and "stretched" it to 8 bits. For samples
// which are already 8-bit, h === 1 and g === i.
function maskColor(maskRed, maskGreen, maskBlue, maskAlpha) {
    const maskRedR = (~maskRed + 1) & maskRed;
    const maskGreenR = (~maskGreen + 1) & maskGreen;
    const maskBlueR = (~maskBlue + 1) & maskBlue;
    const maskAlphaR = (~maskAlpha + 1) & maskAlpha;
    const shiftedMaskRedL = maskRed / maskRedR + 1;
    const shiftedMaskGreenL = maskGreen / maskGreenR + 1;
    const shiftedMaskBlueL = maskBlue / maskBlueR + 1;
    const shiftedMaskAlphaL = maskAlpha / maskAlphaR + 1;
    return {
        shiftRed: (x) => (((x & maskRed) / maskRedR) * 0x100) / shiftedMaskRedL,
        shiftGreen: (x) => (((x & maskGreen) / maskGreenR) * 0x100) / shiftedMaskGreenL,
        shiftBlue: (x) => (((x & maskBlue) / maskBlueR) * 0x100) / shiftedMaskBlueL,
        shiftAlpha: maskAlpha !== 0
            ? (x) => (((x & maskAlpha) / maskAlphaR) * 0x100) / shiftedMaskAlphaL
            : () => 255,
    };
}

var BmpCompression;
(function (BmpCompression) {
    BmpCompression[BmpCompression["NONE"] = 0] = "NONE";
    BmpCompression[BmpCompression["BI_RLE8"] = 1] = "BI_RLE8";
    BmpCompression[BmpCompression["BI_RLE4"] = 2] = "BI_RLE4";
    BmpCompression[BmpCompression["BI_BIT_FIELDS"] = 3] = "BI_BIT_FIELDS";
    BmpCompression[BmpCompression["BI_ALPHA_BIT_FIELDS"] = 6] = "BI_ALPHA_BIT_FIELDS";
})(BmpCompression || (BmpCompression = {}));

class BmpDecoder {
    // Header
    flag;
    fileSize;
    reserved1;
    reserved2;
    offset;
    headerSize;
    width;
    height;
    planes;
    bitPP;
    compression;
    rawSize;
    hr;
    vr;
    colors;
    importantColors;
    palette;
    data;
    maskRed;
    maskGreen;
    maskBlue;
    maskAlpha;
    toRGBA;
    pos;
    bottomUp;
    buffer;
    locRed;
    locGreen;
    locBlue;
    locAlpha;
    shiftRed;
    shiftGreen;
    shiftBlue;
    shiftAlpha;
    constructor(buffer, { toRGBA } = { toRGBA: false }) {
        this.buffer = buffer;
        this.toRGBA = !!toRGBA;
        this.pos = 0;
        this.bottomUp = true;
        this.flag = this.buffer.toString('utf-8', 0, (this.pos += 2));
        if (this.flag !== 'BM') {
            throw new Error('Invalid BMP File');
        }
        this.locRed = this.toRGBA ? 0 : 3;
        this.locGreen = this.toRGBA ? 1 : 2;
        this.locBlue = this.toRGBA ? 2 : 1;
        this.locAlpha = this.toRGBA ? 3 : 0;
        this.parseHeader();
        this.parseRGBA();
    }
    parseHeader() {
        this.fileSize = this.readUInt32LE();
        this.reserved1 = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.reserved2 = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.offset = this.readUInt32LE();
        // End of BITMAP_FILE_HEADER
        this.headerSize = this.readUInt32LE();
        if (!(this.headerSize in HeaderTypes)) {
            throw new Error(`Unsupported BMP header size ${this.headerSize}`);
        }
        this.width = this.readUInt32LE();
        this.height = this.readUInt32LE();
        // negative value are possible here => implies bottom down
        this.height =
            this.height > 0x7fffffff ? this.height - 0x100000000 : this.height;
        this.planes = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.bitPP = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.compression = this.readUInt32LE();
        this.rawSize = this.readUInt32LE();
        this.hr = this.readUInt32LE();
        this.vr = this.readUInt32LE();
        this.colors = this.readUInt32LE();
        this.importantColors = this.readUInt32LE();
        // De facto defaults
        if (this.bitPP === 32) {
            this.maskAlpha = 0;
            this.maskRed = 0x00ff0000;
            this.maskGreen = 0x0000ff00;
            this.maskBlue = 0x000000ff;
        }
        else if (this.bitPP === 16) {
            this.maskAlpha = 0;
            this.maskRed = 0x7c00;
            this.maskGreen = 0x03e0;
            this.maskBlue = 0x001f;
        }
        // End of BITMAP_INFO_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_INFO_HEADER ||
            this.compression === BmpCompression.BI_BIT_FIELDS ||
            this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
            this.maskRed = this.readUInt32LE();
            this.maskGreen = this.readUInt32LE();
            this.maskBlue = this.readUInt32LE();
        }
        // End of BITMAP_V2_INFO_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_V2_INFO_HEADER ||
            this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
            this.maskAlpha = this.readUInt32LE();
        }
        // End of BITMAP_V3_INFO_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_V3_INFO_HEADER) {
            this.pos +=
                HeaderTypes.BITMAP_V4_HEADER - HeaderTypes.BITMAP_V3_INFO_HEADER;
        }
        // End of BITMAP_V4_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_V4_HEADER) {
            this.pos += HeaderTypes.BITMAP_V5_HEADER - HeaderTypes.BITMAP_V4_HEADER;
        }
        // End of BITMAP_V5_HEADER
        if (this.bitPP <= 8 || this.colors > 0) {
            const len = this.colors === 0 ? 1 << this.bitPP : this.colors;
            this.palette = new Array(len);
            for (let i = 0; i < len; i++) {
                const blue = this.buffer.readUInt8(this.pos++);
                const green = this.buffer.readUInt8(this.pos++);
                const red = this.buffer.readUInt8(this.pos++);
                const quad = this.buffer.readUInt8(this.pos++);
                this.palette[i] = {
                    red,
                    green,
                    blue,
                    quad,
                };
            }
        }
        // End of color table
        // Can the height ever be negative?
        if (this.height < 0) {
            this.height *= -1;
            this.bottomUp = false;
        }
        const coloShift = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
        this.shiftRed = coloShift.shiftRed;
        this.shiftGreen = coloShift.shiftGreen;
        this.shiftBlue = coloShift.shiftBlue;
        this.shiftAlpha = coloShift.shiftAlpha;
    }
    parseRGBA() {
        this.data = Buffer.alloc(this.width * this.height * 4);
        switch (this.bitPP) {
            case 1:
                this.bit1();
                break;
            case 4:
                this.bit4();
                break;
            case 8:
                this.bit8();
                break;
            case 16:
                this.bit16();
                break;
            case 24:
                this.bit24();
                break;
            default:
                this.bit32();
        }
    }
    bit1() {
        const xLen = Math.ceil(this.width / 8);
        const mode = xLen % 4;
        const padding = mode !== 0 ? 4 - mode : 0;
        this.scanImage(padding, xLen, (x, line) => {
            const b = this.buffer.readUInt8(this.pos++);
            const location = line * this.width * 4 + x * 8 * 4;
            for (let i = 0; i < 8; i++) {
                if (x * 8 + i < this.width) {
                    const rgb = this.palette[(b >> (7 - i)) & 0x1];
                    this.data[location + i * this.locAlpha] = 0;
                    this.data[location + i * 4 + this.locBlue] = rgb.blue;
                    this.data[location + i * 4 + this.locGreen] = rgb.green;
                    this.data[location + i * 4 + this.locRed] = rgb.red;
                }
                else {
                    break;
                }
            }
        });
    }
    bit4() {
        if (this.compression === BmpCompression.BI_RLE4) {
            this.data.fill(0);
            let lowNibble = false; //for all count of pixel
            let lines = this.bottomUp ? this.height - 1 : 0;
            let location = 0;
            while (location < this.data.length) {
                const a = this.buffer.readUInt8(this.pos++);
                const b = this.buffer.readUInt8(this.pos++);
                //absolute mode
                if (a === 0) {
                    if (b === 0) {
                        //line end
                        lines += this.bottomUp ? -1 : 1;
                        location = lines * this.width * 4;
                        lowNibble = false;
                        continue;
                    }
                    if (b === 1) {
                        // image end
                        break;
                    }
                    if (b === 2) {
                        // offset x, y
                        const x = this.buffer.readUInt8(this.pos++);
                        const y = this.buffer.readUInt8(this.pos++);
                        lines += this.bottomUp ? -y : y;
                        location += y * this.width * 4 + x * 4;
                    }
                    else {
                        let c = this.buffer.readUInt8(this.pos++);
                        for (let i = 0; i < b; i++) {
                            location = this.setPixelData(location, lowNibble ? c & 0x0f : (c & 0xf0) >> 4);
                            if (i & 1 && i + 1 < b) {
                                c = this.buffer.readUInt8(this.pos++);
                            }
                            lowNibble = !lowNibble;
                        }
                        if ((((b + 1) >> 1) & 1) === 1) {
                            this.pos++;
                        }
                    }
                }
                else {
                    //encoded mode
                    for (let i = 0; i < a; i++) {
                        location = this.setPixelData(location, lowNibble ? b & 0x0f : (b & 0xf0) >> 4);
                        lowNibble = !lowNibble;
                    }
                }
            }
        }
        else {
            const xLen = Math.ceil(this.width / 2);
            const mode = xLen % 4;
            const padding = mode !== 0 ? 4 - mode : 0;
            this.scanImage(padding, xLen, (x, line) => {
                const b = this.buffer.readUInt8(this.pos++);
                const location = line * this.width * 4 + x * 2 * 4;
                const first4 = b >> 4;
                let rgb = this.palette[first4];
                this.data[location] = 0;
                this.data[location + 1] = rgb.blue;
                this.data[location + 2] = rgb.green;
                this.data[location + 3] = rgb.red;
                if (x * 2 + 1 >= this.width) {
                    // throw new Error('Something');
                    return false;
                }
                const last4 = b & 0x0f;
                rgb = this.palette[last4];
                this.data[location + 4] = 0;
                this.data[location + 4 + 1] = rgb.blue;
                this.data[location + 4 + 2] = rgb.green;
                this.data[location + 4 + 3] = rgb.red;
            });
        }
    }
    bit8() {
        if (this.compression === BmpCompression.BI_RLE8) {
            this.data.fill(0);
            let lines = this.bottomUp ? this.height - 1 : 0;
            let location = 0;
            while (location < this.data.length) {
                const a = this.buffer.readUInt8(this.pos++);
                const b = this.buffer.readUInt8(this.pos++);
                //absolute mode
                if (a === 0) {
                    if (b === 0) {
                        //line end
                        lines += this.bottomUp ? -1 : 1;
                        location = lines * this.width * 4;
                        continue;
                    }
                    if (b === 1) {
                        //image end
                        break;
                    }
                    if (b === 2) {
                        //offset x,y
                        const x = this.buffer.readUInt8(this.pos++);
                        const y = this.buffer.readUInt8(this.pos++);
                        lines += this.bottomUp ? -y : y;
                        location += y * this.width * 4 + x * 4;
                    }
                    else {
                        for (let i = 0; i < b; i++) {
                            const c = this.buffer.readUInt8(this.pos++);
                            location = this.setPixelData(location, c);
                        }
                        // @ts-ignore
                        const shouldIncrement = b & (1 === 1);
                        if (shouldIncrement) {
                            this.pos++;
                        }
                    }
                }
                else {
                    //encoded mode
                    for (let i = 0; i < a; i++) {
                        location = this.setPixelData(location, b);
                    }
                }
            }
        }
        else {
            const mode = this.width % 4;
            const padding = mode !== 0 ? 4 - mode : 0;
            this.scanImage(padding, this.width, (x, line) => {
                const b = this.buffer.readUInt8(this.pos++);
                const location = line * this.width * 4 + x * 4;
                if (b < this.palette.length) {
                    const rgb = this.palette[b];
                    this.data[location] = 0;
                    this.data[location + 1] = rgb.blue;
                    this.data[location + 2] = rgb.green;
                    this.data[location + 3] = rgb.red;
                }
                else {
                    this.data[location] = 0;
                    this.data[location + 1] = 0xff;
                    this.data[location + 2] = 0xff;
                    this.data[location + 3] = 0xff;
                }
            });
        }
    }
    bit16() {
        const padding = (this.width % 2) * 2;
        this.scanImage(padding, this.width, (x, line) => {
            const loc = line * this.width * 4 + x * 4;
            const px = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            this.data[loc + this.locRed] = this.shiftRed(px);
            this.data[loc + this.locGreen] = this.shiftGreen(px);
            this.data[loc + this.locBlue] = this.shiftBlue(px);
            this.data[loc + this.locAlpha] = this.shiftAlpha(px);
        });
    }
    bit24() {
        const padding = this.width % 4;
        this.scanImage(padding, this.width, (x, line) => {
            const loc = line * this.width * 4 + x * 4;
            const blue = this.buffer.readUInt8(this.pos++);
            const green = this.buffer.readUInt8(this.pos++);
            const red = this.buffer.readUInt8(this.pos++);
            this.data[loc + this.locRed] = red;
            this.data[loc + this.locGreen] = green;
            this.data[loc + this.locBlue] = blue;
            this.data[loc + this.locAlpha] = 0;
        });
    }
    bit32() {
        this.scanImage(0, this.width, (x, line) => {
            const loc = line * this.width * 4 + x * 4;
            const px = this.readUInt32LE();
            this.data[loc + this.locRed] = this.shiftRed(px);
            this.data[loc + this.locGreen] = this.shiftGreen(px);
            this.data[loc + this.locBlue] = this.shiftBlue(px);
            this.data[loc + this.locAlpha] = this.shiftAlpha(px);
        });
    }
    scanImage(padding = 0, width = this.width, processPixel) {
        for (let y = this.height - 1; y >= 0; y--) {
            const line = this.bottomUp ? y : this.height - 1 - y;
            for (let x = 0; x < width; x++) {
                const result = processPixel.call(this, x, line);
                if (result === false) {
                    return;
                }
            }
            this.pos += padding;
        }
    }
    readUInt32LE() {
        const value = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        return value;
    }
    setPixelData(location, rgbIndex) {
        const { blue, green, red } = this.palette[rgbIndex];
        this.data[location + this.locAlpha] = 0;
        this.data[location + 1 + this.locBlue] = blue;
        this.data[location + 2 + this.locGreen] = green;
        this.data[location + 3 + this.locRed] = red;
        return location + 4;
    }
}

function createInteger(numbers) {
    return numbers.reduce((final, n) => (final << 1) | n, 0);
}
function createColor(color) {
    return ((color.quad << 24) | (color.red << 16) | (color.green << 8) | color.blue);
}
class BmpEncoder {
    fileSize;
    reserved1;
    reserved2;
    offset;
    width;
    flag;
    height;
    planes;
    bitPP;
    compress;
    hr;
    vr;
    colors;
    importantColors;
    rawSize;
    headerSize;
    data;
    palette;
    extraBytes;
    buffer;
    bytesInColor;
    pos;
    constructor(imgData) {
        this.buffer = imgData.data;
        this.width = imgData.width;
        this.height = imgData.height;
        this.headerSize = HeaderTypes.BITMAP_INFO_HEADER;
        // Header
        this.flag = 'BM';
        this.bitPP = imgData.bitPP || 24;
        this.offset = 54;
        this.reserved1 = imgData.reserved1 || 0;
        this.reserved2 = imgData.reserved2 || 0;
        this.planes = 1;
        this.compress = 0;
        this.hr = imgData.hr || 0;
        this.vr = imgData.vr || 0;
        this.importantColors = imgData.importantColors || 0;
        this.colors = Math.min(2 ** (this.bitPP - 1 || 1), imgData.colors || Infinity);
        this.palette = imgData.palette || [];
        if (this.colors && this.bitPP < 16) {
            this.offset += this.colors * 4;
        }
        else {
            this.colors = 0;
        }
        switch (this.bitPP) {
            case 32:
                this.bytesInColor = 4;
                break;
            case 16:
                this.bytesInColor = 2;
                break;
            case 8:
                this.bytesInColor = 1;
                break;
            case 4:
                this.bytesInColor = 1 / 2;
                break;
            case 1:
                this.bytesInColor = 1 / 8;
                break;
            default:
                this.bytesInColor = 3;
                this.bitPP = 24;
        }
        const rowWidth = (this.width * this.bitPP) / 32;
        const rowBytes = Math.ceil(rowWidth);
        this.extraBytes = (rowBytes - rowWidth) * 4;
        // Why 2?
        this.rawSize = this.height * rowBytes * 4 + 2;
        this.fileSize = this.rawSize + this.offset;
        this.data = Buffer.alloc(this.fileSize, 0x1);
        this.pos = 0;
        this.encode();
    }
    encode() {
        this.pos = 0;
        this.writeHeader();
        switch (this.bitPP) {
            case 32:
                this.bit32();
                break;
            case 16:
                this.bit16();
                break;
            case 8:
                this.bit8();
                break;
            case 4:
                this.bit4();
                break;
            case 1:
                this.bit1();
                break;
            default:
                this.bit24();
        }
    }
    writeHeader() {
        this.data.write(this.flag, this.pos, 2);
        this.pos += 2;
        this.writeUInt32LE(this.fileSize);
        // Writing 2 UInt16LE resulted in a weird bug
        this.writeUInt32LE((this.reserved1 << 16) | this.reserved2);
        this.writeUInt32LE(this.offset);
        this.writeUInt32LE(this.headerSize);
        this.writeUInt32LE(this.width);
        this.writeUInt32LE(this.height);
        this.data.writeUInt16LE(this.planes, this.pos);
        this.pos += 2;
        this.data.writeUInt16LE(this.bitPP, this.pos);
        this.pos += 2;
        this.writeUInt32LE(this.compress);
        this.writeUInt32LE(this.rawSize);
        this.writeUInt32LE(this.hr);
        this.writeUInt32LE(this.vr);
        this.writeUInt32LE(this.colors);
        this.writeUInt32LE(this.importantColors);
    }
    bit1() {
        if (this.palette.length && this.colors === 2) {
            this.initColors(1);
        }
        else {
            this.writeUInt32LE(0x00ffffff); // Black
            this.writeUInt32LE(0x00000000); // White
        }
        this.pos += 1; // ?
        let lineArr = [];
        this.writeImage((p, index, x) => {
            let i = index;
            i++;
            const b = this.buffer[i++];
            const g = this.buffer[i++];
            const r = this.buffer[i++];
            const brightness = r * 0.2126 + g * 0.7152 + b * 0.0722;
            lineArr.push(brightness > 127 ? 0 : 1);
            if ((x + 1) % 8 === 0) {
                this.data[p - 1] = createInteger(lineArr);
                lineArr = [];
            }
            else if (x === this.width - 1 && lineArr.length > 0) {
                this.data[p - 1] = createInteger(lineArr) << 4;
                lineArr = [];
            }
            return i;
        });
    }
    bit4() {
        const colors = this.initColors(4);
        let integerPair = [];
        this.writeImage((p, index, x) => {
            let i = index;
            const colorInt = createColor({
                quad: this.buffer[i++],
                blue: this.buffer[i++],
                green: this.buffer[i++],
                red: this.buffer[i++],
            });
            const colorExists = colors.findIndex((c) => c === colorInt);
            if (colorExists !== -1) {
                integerPair.push(colorExists);
            }
            else {
                integerPair.push(0);
            }
            if ((x + 1) % 2 === 0) {
                this.data[p] = (integerPair[0] << 4) | integerPair[1];
                integerPair = [];
            }
            return i;
        });
    }
    bit8() {
        const colors = this.initColors(8);
        this.writeImage((p, index) => {
            let i = index;
            const colorInt = createColor({
                quad: this.buffer[i++],
                blue: this.buffer[i++],
                green: this.buffer[i++],
                red: this.buffer[i++],
            });
            const colorExists = colors.findIndex((c) => c === colorInt);
            if (colorExists !== -1) {
                this.data[p] = colorExists;
            }
            else {
                this.data[p] = 0;
            }
            return i;
        });
    }
    bit16() {
        this.writeImage((p, index) => {
            let i = index + 1;
            const b = this.buffer[i++] / 8; // b
            const g = this.buffer[i++] / 8; // g
            const r = this.buffer[i++] / 8; // r
            const color = (r << 10) | (g << 5) | b;
            this.data[p] = color & 0x00ff;
            this.data[p + 1] = (color & 0xff00) >> 8;
            return i;
        });
    }
    bit24() {
        this.writeImage((p, index) => {
            let i = index + 1;
            this.data[p] = this.buffer[i++]; //b
            this.data[p + 1] = this.buffer[i++]; //g
            this.data[p + 2] = this.buffer[i++]; //r
            return i;
        });
    }
    bit32() {
        this.writeImage((p, index) => {
            let i = index;
            this.data[p + 3] = this.buffer[i++]; // a
            this.data[p] = this.buffer[i++]; // b
            this.data[p + 1] = this.buffer[i++]; // g
            this.data[p + 2] = this.buffer[i++]; // r
            return i;
        });
    }
    writeImage(writePixel) {
        const rowBytes = this.extraBytes + this.width * this.bytesInColor;
        let i = 0;
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const p = Math.floor(this.pos + (this.height - 1 - y) * rowBytes + x * this.bytesInColor);
                i = writePixel.call(this, p, i, x, y);
            }
        }
    }
    initColors(bit) {
        const colors = [];
        if (this.palette.length) {
            for (let i = 0; i < this.colors; i++) {
                const rootColor = createColor(this.palette[i]);
                this.writeUInt32LE(rootColor);
                colors.push(rootColor);
            }
        }
        else {
            throw new Error(`To encode ${bit}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
        }
        return colors;
    }
    writeUInt32LE(value) {
        this.data.writeUInt32LE(value, this.pos);
        this.pos += 4;
    }
}

function decode$1(bmpData, options) {
    return new BmpDecoder(bmpData, options);
}
function encode$1(imgData) {
    return new BmpEncoder(imgData);
}

// This file is autogenerated. It's used to publish ESM to npm.
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};

  // If input is already a tinycolor, return itself
  if (color instanceof tinycolor) {
    return color;
  }
  // If we are called as a function, call using new instead
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;

  // Don't let the range of [0,255] come back in [0,1].
  // Potentially lose a little bit of precision here, but will fix issues where
  // .5 gets interpreted as half of the total, instead of half of 1
  // If it was supposed to be 128, this was already taken care of by `inputToRgb`
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    //http://www.w3.org/TR/AERT#color-contrast
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  },
  getLuminance: function getLuminance() {
    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360),
      s = Math.round(hsv.s * 100),
      v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360),
      s = Math.round(hsl.s * 100),
      l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      // Special case for "transparent", all other non-alpha formats
      // will return rgba when there is transparency.
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function (color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a
  };
}

// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    l: l
  };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    v: v
  };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h),
    f = h - i,
    p = v * (1 - s),
    q = v * (1 - f * s),
    t = v * (1 - (1 - f) * s),
    mod = i % 6,
    r = [v, q, p, p, t, v][mod],
    g = [t, v, v, q, p, p][mod],
    b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];

  // Return a 3 character hex if possible
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];

  // Return a 4 character hex if possible
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function () {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};

// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h,
    s = hsv.s,
    v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h,
      s: s,
      v: v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function (color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};

// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function (color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function (color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function (baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level: level,
    size: size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};

// Big List of Colors
// ------------------
// <https://www.w3.org/TR/css-color-4/#named-colors>
var names$1 = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names$1);

// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));

  // Automatically convert percentage into number
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }

  // Handle floating point rounding errors
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }

  // Convert into [0, 1] range if it isn't already
  return n % max / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
  return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function () {
  // <http://www.w3.org/TR/css3-values/#integers>
  var CSS_INTEGER = "[-\\+]?\\d+%?";

  // <http://www.w3.org/TR/css3-values/#number-value>
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

  // Actual matching.
  // Parentheses and commas are optional, but not required.
  // Whitespace can take the place of commas or opening paren
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names$1[color]) {
    color = names$1[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }

  // Try to match string input using regular expressions.
  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
  // Just return an object and let the conversion functions handle that.
  // This way the result will be the same whether the tinycolor is initialized with string or object.
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  // return valid WCAG2 parms for isReadable.
  // If input parms are invalid, return {"level":"AA", "size":"small"}
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level: level,
    size: size
  };
}

function clone(image) {
    const newBitmap = {
        width: image.bitmap.width,
        height: image.bitmap.height,
        data: Buffer.from(image.bitmap.data),
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new image.constructor(newBitmap);
}
function scan(image, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
xArg, yArg, wArg, hArg, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
cbArg) {
    let x;
    let y;
    let w;
    let h;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let cb;
    if (typeof xArg === "function") {
        cb = xArg;
        x = 0;
        y = 0;
        w = image.bitmap.width;
        h = image.bitmap.height;
    }
    else {
        x = xArg;
        if (typeof yArg !== "number")
            throw new Error("y must be a number");
        y = yArg;
        if (typeof wArg !== "number")
            throw new Error("w must be a number");
        w = wArg;
        if (typeof hArg !== "number")
            throw new Error("h must be a number");
        h = hArg;
        if (typeof cbArg !== "function")
            throw new Error("cb must be a function");
        cb = cbArg;
    }
    // round input
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    const bound = cb.bind(image);
    for (let _y = y; _y < y + h; _y++) {
        for (let _x = x; _x < x + w; _x++) {
            const idx = (image.bitmap.width * _y + _x) << 2;
            // Bind the images so this.bitmap works
            bound(_x, _y, idx);
        }
    }
    return image;
}
function* scanIterator(image, x, y, w, h) {
    // round input
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    for (let _y = y; _y < y + h; _y++) {
        for (let _x = x; _x < x + w; _x++) {
            const idx = (image.bitmap.width * _y + _x) << 2;
            yield { x: _x, y: _y, idx, image };
        }
    }
}
/**
 * A helper method that converts RGBA values to a single integer value
 * @param i A single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)
 * @returns An object with the properties r, g, b and a representing RGBA values
 * @example
 * ```ts
 * import { intToRGBA } from "@jimp/utils";
 *
 * intToRGBA(0xFF0000FF); // { r: 255, g: 0, b: 0, a:255 }
 * ```
 */
function intToRGBA$1(i) {
    if (typeof i !== "number") {
        throw new Error("i must be a number");
    }
    const rgba = {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    rgba.r = Math.floor(i / Math.pow(256, 3));
    rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
    rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /
        Math.pow(256, 1));
    rgba.a = Math.floor((i -
        rgba.r * Math.pow(256, 3) -
        rgba.g * Math.pow(256, 2) -
        rgba.b * Math.pow(256, 1)) /
        Math.pow(256, 0));
    return rgba;
}
/**
 * Compute color difference
 * 0 means no difference, 1 means maximum difference.
 * Both parameters must be an color object `{ r:val, g:val, b:val, a:val }`
 * Where `a` is optional and `val` is an integer between 0 and 255.
 * @param rgba1 first color to compare.
 * @param rgba2 second color to compare.
 * @returns float between 0 and 1.
 * @example
 * ```ts
 * import { colorDiff } from "@jimp/utils";
 *
 * colorDiff(
 *  { r: 255, g: 0, b: 0, a: 0 },
 *  { r: 0, g: 255, b: 0, a: 0 },
 * ); // 0.5
 *
 * colorDiff(
 *  { r: 0, g: 0, b: 0, },
 *  { r: 255, g: 255, b: 255, }
 * ); // 0.7
 * ```
 */
function colorDiff(rgba1, rgba2) {
    const sq = (n) => Math.pow(n, 2);
    const { max } = Math;
    const maxVal = 255 * 255 * 3;
    const rgba1A = "a" in rgba1 ? rgba1.a : 255;
    const rgba2A = "a" in rgba2 ? rgba2.a : 255;
    return ((max(sq(rgba1.r - rgba2.r), sq(rgba1.r - rgba2.r - rgba1A + rgba2A)) +
        max(sq(rgba1.g - rgba2.g), sq(rgba1.g - rgba2.g - rgba1A + rgba2A)) +
        max(sq(rgba1.b - rgba2.b), sq(rgba1.b - rgba2.b - rgba1A + rgba2A))) /
        maxVal);
}
/**
 * Limits a number to between 0 or 255
 * @example
 * ```ts
 * import { limit255 } from "@jimp/utils";
 *
 * limit255(256); // 255
 * limit255(-1); // 0
 * ```
 */
function limit255(n) {
    n = Math.max(n, 0);
    n = Math.min(n, 255);
    return n;
}
/**
 * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number
 * @returns A hex number representing a color
 * @example
 * ```ts
 * import { cssColorToHex } from "@jimp/utils";
 *
 * cssColorToHex("rgba(255, 0, 0, 0.5)"); // "ff000080"
 * ```
 */
function cssColorToHex(cssColor) {
    if (typeof cssColor === "number") {
        return cssColor;
    }
    return parseInt(tinycolor(cssColor).toHex8(), 16);
}

function encode(image, options = {}) {
    scan({ bitmap: image }, 0, 0, image.width, image.height, function (_, __, index) {
        const red = image.data[index + 0];
        const green = image.data[index + 1];
        const blue = image.data[index + 2];
        const alpha = image.data[index + 3];
        image.data[index + 0] = alpha;
        image.data[index + 1] = blue;
        image.data[index + 2] = green;
        image.data[index + 3] = red;
    });
    return encode$1({ ...image, ...options }).data;
}
function decode(data, options) {
    const result = decode$1(data, options);
    scan({ bitmap: result }, 0, 0, result.width, result.height, function (_, __, index) {
        // const alpha = result.data[index + 0]!;
        const blue = result.data[index + 1];
        const green = result.data[index + 2];
        const red = result.data[index + 3];
        result.data[index + 0] = red;
        result.data[index + 1] = green;
        result.data[index + 2] = blue;
        result.data[index + 3] = 0xff;
    });
    return result;
}
function msBmp() {
    return {
        mime: "image/x-ms-bmp",
        encode,
        decode,
    };
}
function bmp() {
    return {
        mime: "image/bmp",
        encode,
        decode,
    };
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var omggif = {};

var hasRequiredOmggif;

function requireOmggif () {
	if (hasRequiredOmggif) return omggif;
	hasRequiredOmggif = 1;

	function GifWriter(buf, width, height, gopts) {
	  var p = 0;

	  var gopts = gopts === undefined ? { } : gopts;
	  var loop_count = gopts.loop === undefined ? null : gopts.loop;
	  var global_palette = gopts.palette === undefined ? null : gopts.palette;

	  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
	    throw new Error("Width/Height invalid.");

	  function check_palette_and_num_colors(palette) {
	    var num_colors = palette.length;
	    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
	      throw new Error(
	          "Invalid code/color length, must be power of 2 and 2 .. 256.");
	    }
	    return num_colors;
	  }

	  // - Header.
	  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
	  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

	  // Handling of Global Color Table (palette) and background index.
	  var gp_num_colors_pow2 = 0;
	  var background = 0;
	  if (global_palette !== null) {
	    var gp_num_colors = check_palette_and_num_colors(global_palette);
	    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
	    gp_num_colors = 1 << gp_num_colors_pow2;
	    --gp_num_colors_pow2;
	    if (gopts.background !== undefined) {
	      background = gopts.background;
	      if (background >= gp_num_colors)
	        throw new Error("Background index out of range.");
	      // The GIF spec states that a background index of 0 should be ignored, so
	      // this is probably a mistake and you really want to set it to another
	      // slot in the palette.  But actually in the end most browsers, etc end
	      // up ignoring this almost completely (including for dispose background).
	      if (background === 0)
	        throw new Error("Background index explicitly passed as 0.");
	    }
	  }

	  // - Logical Screen Descriptor.
	  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
	  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
	  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
	  // NOTE: Indicates 0-bpp original color resolution (unused?).
	  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
	             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
	  buf[p++] = background;  // Background Color Index.
	  buf[p++] = 0;  // Pixel aspect ratio (unused?).

	  // - Global Color Table
	  if (global_palette !== null) {
	    for (var i = 0, il = global_palette.length; i < il; ++i) {
	      var rgb = global_palette[i];
	      buf[p++] = rgb >> 16 & 0xff;
	      buf[p++] = rgb >> 8 & 0xff;
	      buf[p++] = rgb & 0xff;
	    }
	  }

	  if (loop_count !== null) {  // Netscape block for looping.
	    if (loop_count < 0 || loop_count > 65535)
	      throw new Error("Loop count invalid.")
	    // Extension code, label, and length.
	    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
	    // NETSCAPE2.0
	    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
	    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
	    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
	    // Sub-block
	    buf[p++] = 0x03; buf[p++] = 0x01;
	    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
	    buf[p++] = 0x00;  // Terminator.
	  }


	  var ended = false;

	  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
	    if (ended === true) { --p; ended = false; }  // Un-end.

	    opts = opts === undefined ? { } : opts;

	    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
	    // canvas width/height, I imagine?
	    if (x < 0 || y < 0 || x > 65535 || y > 65535)
	      throw new Error("x/y invalid.")

	    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
	      throw new Error("Width/Height invalid.")

	    if (indexed_pixels.length < w * h)
	      throw new Error("Not enough pixels for the frame size.");

	    var using_local_palette = true;
	    var palette = opts.palette;
	    if (palette === undefined || palette === null) {
	      using_local_palette = false;
	      palette = global_palette;
	    }

	    if (palette === undefined || palette === null)
	      throw new Error("Must supply either a local or global palette.");

	    var num_colors = check_palette_and_num_colors(palette);

	    // Compute the min_code_size (power of 2), destroying num_colors.
	    var min_code_size = 0;
	    while (num_colors >>= 1) ++min_code_size;
	    num_colors = 1 << min_code_size;  // Now we can easily get it back.

	    var delay = opts.delay === undefined ? 0 : opts.delay;

	    // From the spec:
	    //     0 -   No disposal specified. The decoder is
	    //           not required to take any action.
	    //     1 -   Do not dispose. The graphic is to be left
	    //           in place.
	    //     2 -   Restore to background color. The area used by the
	    //           graphic must be restored to the background color.
	    //     3 -   Restore to previous. The decoder is required to
	    //           restore the area overwritten by the graphic with
	    //           what was there prior to rendering the graphic.
	    //  4-7 -    To be defined.
	    // NOTE(deanm): Dispose background doesn't really work, apparently most
	    // browsers ignore the background palette index and clear to transparency.
	    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
	    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
	      throw new Error("Disposal out of range.");

	    var use_transparency = false;
	    var transparent_index = 0;
	    if (opts.transparent !== undefined && opts.transparent !== null) {
	      use_transparency = true;
	      transparent_index = opts.transparent;
	      if (transparent_index < 0 || transparent_index >= num_colors)
	        throw new Error("Transparent color index.");
	    }

	    if (disposal !== 0 || use_transparency || delay !== 0) {
	      // - Graphics Control Extension
	      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
	      buf[p++] = 4;  // Byte size.

	      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
	      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
	      buf[p++] = transparent_index;  // Transparent color index.
	      buf[p++] = 0;  // Block Terminator.
	    }

	    // - Image Descriptor
	    buf[p++] = 0x2c;  // Image Seperator.
	    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
	    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
	    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
	    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
	    // NOTE: No sort flag (unused?).
	    // TODO(deanm): Support interlace.
	    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

	    // - Local Color Table
	    if (using_local_palette === true) {
	      for (var i = 0, il = palette.length; i < il; ++i) {
	        var rgb = palette[i];
	        buf[p++] = rgb >> 16 & 0xff;
	        buf[p++] = rgb >> 8 & 0xff;
	        buf[p++] = rgb & 0xff;
	      }
	    }

	    p = GifWriterOutputLZWCodeStream(
	            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

	    return p;
	  };

	  this.end = function() {
	    if (ended === false) {
	      buf[p++] = 0x3b;  // Trailer.
	      ended = true;
	    }
	    return p;
	  };

	  this.getOutputBuffer = function() { return buf; };
	  this.setOutputBuffer = function(v) { buf = v; };
	  this.getOutputBufferPosition = function() { return p; };
	  this.setOutputBufferPosition = function(v) { p = v; };
	}

	// Main compression routine, palette indexes -> LZW code stream.
	// |index_stream| must have at least one entry.
	function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
	  buf[p++] = min_code_size;
	  var cur_subblock = p++;  // Pointing at the length field.

	  var clear_code = 1 << min_code_size;
	  var code_mask = clear_code - 1;
	  var eoi_code = clear_code + 1;
	  var next_code = eoi_code + 1;

	  var cur_code_size = min_code_size + 1;  // Number of bits per code.
	  var cur_shift = 0;
	  // We have at most 12-bit codes, so we should have to hold a max of 19
	  // bits here (and then we would write out).
	  var cur = 0;

	  function emit_bytes_to_buffer(bit_block_size) {
	    while (cur_shift >= bit_block_size) {
	      buf[p++] = cur & 0xff;
	      cur >>= 8; cur_shift -= 8;
	      if (p === cur_subblock + 256) {  // Finished a subblock.
	        buf[cur_subblock] = 255;
	        cur_subblock = p++;
	      }
	    }
	  }

	  function emit_code(c) {
	    cur |= c << cur_shift;
	    cur_shift += cur_code_size;
	    emit_bytes_to_buffer(8);
	  }

	  // I am not an expert on the topic, and I don't want to write a thesis.
	  // However, it is good to outline here the basic algorithm and the few data
	  // structures and optimizations here that make this implementation fast.
	  // The basic idea behind LZW is to build a table of previously seen runs
	  // addressed by a short id (herein called output code).  All data is
	  // referenced by a code, which represents one or more values from the
	  // original input stream.  All input bytes can be referenced as the same
	  // value as an output code.  So if you didn't want any compression, you
	  // could more or less just output the original bytes as codes (there are
	  // some details to this, but it is the idea).  In order to achieve
	  // compression, values greater then the input range (codes can be up to
	  // 12-bit while input only 8-bit) represent a sequence of previously seen
	  // inputs.  The decompressor is able to build the same mapping while
	  // decoding, so there is always a shared common knowledge between the
	  // encoding and decoder, which is also important for "timing" aspects like
	  // how to handle variable bit width code encoding.
	  //
	  // One obvious but very important consequence of the table system is there
	  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
	  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
	  // can be used for an effecient lookup strategy for the code mapping.  We
	  // need to know if a run has been seen before, and be able to map that run
	  // to the output code.  Since we start with known unique ids (input bytes),
	  // and then from those build more unique ids (table entries), we can
	  // continue this chain (almost like a linked list) to always have small
	  // integer values that represent the current byte chains in the encoder.
	  // This means instead of tracking the input bytes (AAAABCD) to know our
	  // current state, we can track the table entry for AAAABC (it is guaranteed
	  // to exist by the nature of the algorithm) and the next character D.
	  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
	  // unique.  This allows us to create a simple lookup key for mapping input
	  // sequences to codes (table indices) without having to store or search
	  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
	  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
	  // key.  This leads to a integer value at most 20-bits, which can always
	  // fit in an SMI value and be used as a fast sparse array / object key.

	  // Output code for the current contents of the index buffer.
	  var ib_code = index_stream[0] & code_mask;  // Load first input index.
	  var code_table = { };  // Key'd on our 20-bit "tuple".

	  emit_code(clear_code);  // Spec says first code should be a clear code.

	  // First index already loaded, process the rest of the stream.
	  for (var i = 1, il = index_stream.length; i < il; ++i) {
	    var k = index_stream[i] & code_mask;
	    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
	    var cur_code = code_table[cur_key];  // buffer + k.

	    // Check if we have to create a new code table entry.
	    if (cur_code === undefined) {  // We don't have buffer + k.
	      // Emit index buffer (without k).
	      // This is an inline version of emit_code, because this is the core
	      // writing routine of the compressor (and V8 cannot inline emit_code
	      // because it is a closure here in a different context).  Additionally
	      // we can call emit_byte_to_buffer less often, because we can have
	      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
	      // be 12-bits, so can safely have 18-bits there without overflow.
	      // emit_code(ib_code);
	      cur |= ib_code << cur_shift;
	      cur_shift += cur_code_size;
	      while (cur_shift >= 8) {
	        buf[p++] = cur & 0xff;
	        cur >>= 8; cur_shift -= 8;
	        if (p === cur_subblock + 256) {  // Finished a subblock.
	          buf[cur_subblock] = 255;
	          cur_subblock = p++;
	        }
	      }

	      if (next_code === 4096) {  // Table full, need a clear.
	        emit_code(clear_code);
	        next_code = eoi_code + 1;
	        cur_code_size = min_code_size + 1;
	        code_table = { };
	      } else {  // Table not full, insert a new entry.
	        // Increase our variable bit code sizes if necessary.  This is a bit
	        // tricky as it is based on "timing" between the encoding and
	        // decoder.  From the encoders perspective this should happen after
	        // we've already emitted the index buffer and are about to create the
	        // first table entry that would overflow our current code bit size.
	        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
	        code_table[cur_key] = next_code++;  // Insert into code table.
	      }

	      ib_code = k;  // Index buffer to single input k.
	    } else {
	      ib_code = cur_code;  // Index buffer to sequence in code table.
	    }
	  }

	  emit_code(ib_code);  // There will still be something in the index buffer.
	  emit_code(eoi_code);  // End Of Information.

	  // Flush / finalize the sub-blocks stream to the buffer.
	  emit_bytes_to_buffer(1);

	  // Finish the sub-blocks, writing out any unfinished lengths and
	  // terminating with a sub-block of length 0.  If we have already started
	  // but not yet used a sub-block it can just become the terminator.
	  if (cur_subblock + 1 === p) {  // Started but unused.
	    buf[cur_subblock] = 0;
	  } else {  // Started and used, write length and additional terminator block.
	    buf[cur_subblock] = p - cur_subblock - 1;
	    buf[p++] = 0;
	  }
	  return p;
	}

	function GifReader(buf) {
	  var p = 0;

	  // - Header (GIF87a or GIF89a).
	  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
	      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
	    throw new Error("Invalid GIF 87a/89a header.");
	  }

	  // - Logical Screen Descriptor.
	  var width = buf[p++] | buf[p++] << 8;
	  var height = buf[p++] | buf[p++] << 8;
	  var pf0 = buf[p++];  // <Packed Fields>.
	  var global_palette_flag = pf0 >> 7;
	  var num_global_colors_pow2 = pf0 & 0x7;
	  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
	  buf[p++];
	  buf[p++];  // Pixel aspect ratio (unused?).

	  var global_palette_offset = null;
	  var global_palette_size   = null;

	  if (global_palette_flag) {
	    global_palette_offset = p;
	    global_palette_size = num_global_colors;
	    p += num_global_colors * 3;  // Seek past palette.
	  }

	  var no_eof = true;

	  var frames = [ ];

	  var delay = 0;
	  var transparent_index = null;
	  var disposal = 0;  // 0 - No disposal specified.
	  var loop_count = null;

	  this.width = width;
	  this.height = height;

	  while (no_eof && p < buf.length) {
	    switch (buf[p++]) {
	      case 0x21:  // Graphics Control Extension Block
	        switch (buf[p++]) {
	          case 0xff:  // Application specific block
	            // Try if it's a Netscape block (with animation loop counter).
	            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
	                // NETSCAPE2.0
	                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
	                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
	                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
	                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
	                // Sub-block
	                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
	              p += 14;
	              loop_count = buf[p++] | buf[p++] << 8;
	              p++;  // Skip terminator.
	            } else {  // We don't know what it is, just try to get past it.
	              p += 12;
	              while (true) {  // Seek through subblocks.
	                var block_size = buf[p++];
	                // Bad block size (ex: undefined from an out of bounds read).
	                if (!(block_size >= 0)) throw Error("Invalid block size");
	                if (block_size === 0) break;  // 0 size is terminator
	                p += block_size;
	              }
	            }
	            break;

	          case 0xf9:  // Graphics Control Extension
	            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
	              throw new Error("Invalid graphics extension block.");
	            var pf1 = buf[p++];
	            delay = buf[p++] | buf[p++] << 8;
	            transparent_index = buf[p++];
	            if ((pf1 & 1) === 0) transparent_index = null;
	            disposal = pf1 >> 2 & 0x7;
	            p++;  // Skip terminator.
	            break;

	          case 0xfe:  // Comment Extension.
	            while (true) {  // Seek through subblocks.
	              var block_size = buf[p++];
	              // Bad block size (ex: undefined from an out of bounds read).
	              if (!(block_size >= 0)) throw Error("Invalid block size");
	              if (block_size === 0) break;  // 0 size is terminator
	              // console.log(buf.slice(p, p+block_size).toString('ascii'));
	              p += block_size;
	            }
	            break;

	          default:
	            throw new Error(
	                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
	        }
	        break;

	      case 0x2c:  // Image Descriptor.
	        var x = buf[p++] | buf[p++] << 8;
	        var y = buf[p++] | buf[p++] << 8;
	        var w = buf[p++] | buf[p++] << 8;
	        var h = buf[p++] | buf[p++] << 8;
	        var pf2 = buf[p++];
	        var local_palette_flag = pf2 >> 7;
	        var interlace_flag = pf2 >> 6 & 1;
	        var num_local_colors_pow2 = pf2 & 0x7;
	        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
	        var palette_offset = global_palette_offset;
	        var palette_size = global_palette_size;
	        var has_local_palette = false;
	        if (local_palette_flag) {
	          var has_local_palette = true;
	          palette_offset = p;  // Override with local palette.
	          palette_size = num_local_colors;
	          p += num_local_colors * 3;  // Seek past palette.
	        }

	        var data_offset = p;

	        p++;  // codesize
	        while (true) {
	          var block_size = buf[p++];
	          // Bad block size (ex: undefined from an out of bounds read).
	          if (!(block_size >= 0)) throw Error("Invalid block size");
	          if (block_size === 0) break;  // 0 size is terminator
	          p += block_size;
	        }

	        frames.push({x: x, y: y, width: w, height: h,
	                     has_local_palette: has_local_palette,
	                     palette_offset: palette_offset,
	                     palette_size: palette_size,
	                     data_offset: data_offset,
	                     data_length: p - data_offset,
	                     transparent_index: transparent_index,
	                     interlaced: !!interlace_flag,
	                     delay: delay,
	                     disposal: disposal});
	        break;

	      case 0x3b:  // Trailer Marker (end of file).
	        no_eof = false;
	        break;

	      default:
	        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
	    }
	  }

	  this.numFrames = function() {
	    return frames.length;
	  };

	  this.loopCount = function() {
	    return loop_count;
	  };

	  this.frameInfo = function(frame_num) {
	    if (frame_num < 0 || frame_num >= frames.length)
	      throw new Error("Frame index out of range.");
	    return frames[frame_num];
	  };

	  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
	    var frame = this.frameInfo(frame_num);
	    var num_pixels = frame.width * frame.height;
	    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
	    GifReaderLZWOutputIndexStream(
	        buf, frame.data_offset, index_stream, num_pixels);
	    var palette_offset = frame.palette_offset;

	    // NOTE(deanm): It seems to be much faster to compare index to 256 than
	    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
	    // the profile, not sure if it's related to using a Uint8Array.
	    var trans = frame.transparent_index;
	    if (trans === null) trans = 256;

	    // We are possibly just blitting to a portion of the entire frame.
	    // That is a subrect within the framerect, so the additional pixels
	    // must be skipped over after we finished a scanline.
	    var framewidth  = frame.width;
	    var framestride = width - framewidth;
	    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

	    // Output indicies of the top left and bottom right corners of the subrect.
	    var opbeg = ((frame.y * width) + frame.x) * 4;
	    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
	    var op    = opbeg;

	    var scanstride = framestride * 4;

	    // Use scanstride to skip past the rows when interlacing.  This is skipping
	    // 7 rows for the first two passes, then 3 then 1.
	    if (frame.interlaced === true) {
	      scanstride += width * 4 * 7;  // Pass 1.
	    }

	    var interlaceskip = 8;  // Tracking the row interval in the current pass.

	    for (var i = 0, il = index_stream.length; i < il; ++i) {
	      var index = index_stream[i];

	      if (xleft === 0) {  // Beginning of new scan line
	        op += scanstride;
	        xleft = framewidth;
	        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
	          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
	          // interlaceskip / 2 * 4 is interlaceskip << 1.
	          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
	          interlaceskip >>= 1;
	        }
	      }

	      if (index === trans) {
	        op += 4;
	      } else {
	        var r = buf[palette_offset + index * 3];
	        var g = buf[palette_offset + index * 3 + 1];
	        var b = buf[palette_offset + index * 3 + 2];
	        pixels[op++] = b;
	        pixels[op++] = g;
	        pixels[op++] = r;
	        pixels[op++] = 255;
	      }
	      --xleft;
	    }
	  };

	  // I will go to copy and paste hell one day...
	  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
	    var frame = this.frameInfo(frame_num);
	    var num_pixels = frame.width * frame.height;
	    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
	    GifReaderLZWOutputIndexStream(
	        buf, frame.data_offset, index_stream, num_pixels);
	    var palette_offset = frame.palette_offset;

	    // NOTE(deanm): It seems to be much faster to compare index to 256 than
	    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
	    // the profile, not sure if it's related to using a Uint8Array.
	    var trans = frame.transparent_index;
	    if (trans === null) trans = 256;

	    // We are possibly just blitting to a portion of the entire frame.
	    // That is a subrect within the framerect, so the additional pixels
	    // must be skipped over after we finished a scanline.
	    var framewidth  = frame.width;
	    var framestride = width - framewidth;
	    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

	    // Output indicies of the top left and bottom right corners of the subrect.
	    var opbeg = ((frame.y * width) + frame.x) * 4;
	    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
	    var op    = opbeg;

	    var scanstride = framestride * 4;

	    // Use scanstride to skip past the rows when interlacing.  This is skipping
	    // 7 rows for the first two passes, then 3 then 1.
	    if (frame.interlaced === true) {
	      scanstride += width * 4 * 7;  // Pass 1.
	    }

	    var interlaceskip = 8;  // Tracking the row interval in the current pass.

	    for (var i = 0, il = index_stream.length; i < il; ++i) {
	      var index = index_stream[i];

	      if (xleft === 0) {  // Beginning of new scan line
	        op += scanstride;
	        xleft = framewidth;
	        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
	          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
	          // interlaceskip / 2 * 4 is interlaceskip << 1.
	          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
	          interlaceskip >>= 1;
	        }
	      }

	      if (index === trans) {
	        op += 4;
	      } else {
	        var r = buf[palette_offset + index * 3];
	        var g = buf[palette_offset + index * 3 + 1];
	        var b = buf[palette_offset + index * 3 + 2];
	        pixels[op++] = r;
	        pixels[op++] = g;
	        pixels[op++] = b;
	        pixels[op++] = 255;
	      }
	      --xleft;
	    }
	  };
	}

	function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
	  var min_code_size = code_stream[p++];

	  var clear_code = 1 << min_code_size;
	  var eoi_code = clear_code + 1;
	  var next_code = eoi_code + 1;

	  var cur_code_size = min_code_size + 1;  // Number of bits per code.
	  // NOTE: This shares the same name as the encoder, but has a different
	  // meaning here.  Here this masks each code coming from the code stream.
	  var code_mask = (1 << cur_code_size) - 1;
	  var cur_shift = 0;
	  var cur = 0;

	  var op = 0;  // Output pointer.

	  var subblock_size = code_stream[p++];

	  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
	  // solve the fast mode / backing store uncertainty.
	  // var code_table = Array(4096);
	  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

	  var prev_code = null;  // Track code-1.

	  while (true) {
	    // Read up to two bytes, making sure we always 12-bits for max sized code.
	    while (cur_shift < 16) {
	      if (subblock_size === 0) break;  // No more data to be read.

	      cur |= code_stream[p++] << cur_shift;
	      cur_shift += 8;

	      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
	        subblock_size = code_stream[p++];  // Next subblock.
	      } else {
	        --subblock_size;
	      }
	    }

	    // TODO(deanm): We should never really get here, we should have received
	    // and EOI.
	    if (cur_shift < cur_code_size)
	      break;

	    var code = cur & code_mask;
	    cur >>= cur_code_size;
	    cur_shift -= cur_code_size;

	    // TODO(deanm): Maybe should check that the first code was a clear code,
	    // at least this is what you're supposed to do.  But actually our encoder
	    // now doesn't emit a clear code first anyway.
	    if (code === clear_code) {
	      // We don't actually have to clear the table.  This could be a good idea
	      // for greater error checking, but we don't really do any anyway.  We
	      // will just track it with next_code and overwrite old entries.

	      next_code = eoi_code + 1;
	      cur_code_size = min_code_size + 1;
	      code_mask = (1 << cur_code_size) - 1;

	      // Don't update prev_code ?
	      prev_code = null;
	      continue;
	    } else if (code === eoi_code) {
	      break;
	    }

	    // We have a similar situation as the decoder, where we want to store
	    // variable length entries (code table entries), but we want to do in a
	    // faster manner than an array of arrays.  The code below stores sort of a
	    // linked list within the code table, and then "chases" through it to
	    // construct the dictionary entries.  When a new entry is created, just the
	    // last byte is stored, and the rest (prefix) of the entry is only
	    // referenced by its table entry.  Then the code chases through the
	    // prefixes until it reaches a single byte code.  We have to chase twice,
	    // first to compute the length, and then to actually copy the data to the
	    // output (backwards, since we know the length).  The alternative would be
	    // storing something in an intermediate stack, but that doesn't make any
	    // more sense.  I implemented an approach where it also stored the length
	    // in the code table, although it's a bit tricky because you run out of
	    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
	    // entries are generally not the long).  Even when I created benchmarks for
	    // very long table entries the complexity did not seem worth it.
	    // The code table stores the prefix entry in 12 bits and then the suffix
	    // byte in 8 bits, so each entry is 20 bits.

	    var chase_code = code < next_code ? code : prev_code;

	    // Chase what we will output, either {CODE} or {CODE-1}.
	    var chase_length = 0;
	    var chase = chase_code;
	    while (chase > clear_code) {
	      chase = code_table[chase] >> 8;
	      ++chase_length;
	    }

	    var k = chase;

	    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
	    if (op_end > output_length) {
	      console.log("Warning, gif stream longer than expected.");
	      return;
	    }

	    // Already have the first byte from the chase, might as well write it fast.
	    output[op++] = k;

	    op += chase_length;
	    var b = op;  // Track pointer, writing backwards.

	    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
	      output[op++] = k;

	    chase = chase_code;
	    while (chase_length--) {
	      chase = code_table[chase];
	      output[--b] = chase & 0xff;  // Write backwards.
	      chase >>= 8;  // Pull down to the prefix code.
	    }

	    if (prev_code !== null && next_code < 4096) {
	      code_table[next_code++] = prev_code << 8 | k;
	      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
	      // have an feeling that it should just happen somewhere else, for now it
	      // is awkward between when we grow past the max and then hit a clear code.
	      // For now just check if we hit the max 12-bits (then a clear code should
	      // follow, also of course encoded in 12-bits).
	      if (next_code >= code_mask+1 && cur_code_size < 12) {
	        ++cur_code_size;
	        code_mask = code_mask << 1 | 1;
	      }
	    }

	    prev_code = code;
	  }

	  if (op !== output_length) {
	    console.log("Warning, gif stream shorter than expected.");
	  }

	  return output;
	}

	// CommonJS.
	try { omggif.GifWriter = GifWriter; omggif.GifReader = GifReader; } catch(e) {}
	return omggif;
}

var omggifExports = requireOmggif();
const GIF = /*@__PURE__*/getDefaultExportFromCjs(omggifExports);

var bitmapimage;
var hasRequiredBitmapimage;

function requireBitmapimage () {
	if (hasRequiredBitmapimage) return bitmapimage;
	hasRequiredBitmapimage = 1;

	/** @class BitmapImage */

	class BitmapImage {

	    /**
	     * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
	     * 
	     * Property | Description
	     * --- | ---
	     * bitmap.width | width of image in pixels
	     * bitmap.height | height of image in pixels
	     * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
	     *
	     * Its constructor supports the following signatures:
	     *
	     * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
	     * * new BitmapImage(bitmapImage: BitmapImage)
	     * * new BitmapImage(width: number, height: number, buffer: Buffer)
	     * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
	     * 
	     * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
	     *
	     * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
	     */

	    constructor(...args) {
	        // don't confirm the number of args, because a subclass may have
	        // additional args and pass them all to the superclass
	        if (args.length === 0) {
	            throw new Error("constructor requires parameters");
	        }
	        const firstArg = args[0];
	        if (firstArg !== null && typeof firstArg === 'object') {
	            if (firstArg instanceof BitmapImage) {
	                // copy a provided BitmapImage
	                const sourceBitmap = firstArg.bitmap;
	                this.bitmap = {
	                    width: sourceBitmap.width,
	                    height: sourceBitmap.height,
	                    data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
	                };
	                sourceBitmap.data.copy(this.bitmap.data);
	            }
	            else if (firstArg.width && firstArg.height && firstArg.data) {
	                // share a provided bitmap
	                this.bitmap = firstArg;
	            }
	            else {
	                throw new Error("unrecognized constructor parameters");
	            }
	        }
	        else if (typeof firstArg === 'number' && typeof args[1] === 'number')
	        {
	            const width = firstArg;
	            const height = args[1];
	            const thirdArg = args[2];
	            this.bitmap = { width, height };

	            if (Buffer.isBuffer(thirdArg)) {
	                this.bitmap.data = thirdArg;
	            }
	            else {
	                this.bitmap.data = new Buffer(width * height * 4);
	                if (typeof thirdArg === 'number') {
	                    this.fillRGBA(thirdArg);
	                }
	            }
	        }
	        else {
	            throw new Error("unrecognized constructor parameters");
	        }
	    }

	    /**
	     * Copy a square portion of this image into another image. 
	     * 
	     * @param {BitmapImage} toImage Image into which to copy the square
	     * @param {number} toX x-coord in toImage of upper-left corner of receiving square
	     * @param {number} toY y-coord in toImage of upper-left corner of receiving square
	     * @param {number} fromX x-coord in this image of upper-left corner of source square
	     * @param {number} fromY y-coord in this image of upper-left corner of source square
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
	        if (fromX + fromWidth > this.bitmap.width) {
	            throw new Error("copy exceeds width of source bitmap");
	        }
	        if (toX + fromWidth > toImage.bitmap.width) {
	            throw new Error("copy exceeds width of target bitmap");
	        }
	        if (fromY + fromHeight > this.bitmap.height) {
	            throw new Error("copy exceeds height of source bitmap");
	        }
	        if (toY + fromHeight > toImage.bitmap.height) {
	            throw new Erro("copy exceeds height of target bitmap");
	        }
	        
	        const sourceBuf = this.bitmap.data;
	        const targetBuf = toImage.bitmap.data;
	        const sourceByteWidth = this.bitmap.width * 4;
	        const targetByteWidth = toImage.bitmap.width * 4;
	        const copyByteWidth = fromWidth * 4;
	        let si = fromY * sourceByteWidth + fromX * 4;
	        let ti = toY * targetByteWidth + toX * 4;

	        while (--fromHeight >= 0) {
	            sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
	            si += sourceByteWidth;
	            ti += targetByteWidth;
	        }
	        return this;
	    }

	    /**
	     * Fills the image with a single color.
	     * 
	     * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    fillRGBA(rgba) {
	        const buf = this.bitmap.data;
	        const bufByteWidth = this.bitmap.height * 4;
	        
	        let bi = 0;
	        while (bi < bufByteWidth) {
	            buf.writeUInt32BE(rgba, bi);
	            bi += 4;
	        }
	        while (bi < buf.length) {
	            buf.copy(buf, bi, 0, bufByteWidth);
	            bi += bufByteWidth;
	        }
	        return this;
	    }

	    /**
	     * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
	     * 
	     * @param {number} x x-coord of pixel
	     * @param {number} y y-coord of pixel
	     * @return {number} RGBA of pixel in 0xRRGGBBAA form
	     */

	    getRGBA(x, y) {
	        const bi = (y * this.bitmap.width + x) * 4;
	        return this.bitmap.data.readUInt32BE(bi);
	    }

	    /**
	     * Gets a set of all RGBA colors found within the image.
	     * 
	     * @return {Set} Set of all RGBA colors that the image contains.
	     */

	    getRGBASet() {
	        const rgbaSet = new Set();
	        const buf = this.bitmap.data;
	        for (let bi = 0; bi < buf.length; bi += 4) {
	            rgbaSet.add(buf.readUInt32BE(bi, true));
	        }
	        return rgbaSet;
	    }

	    /**
	     * Converts the image to greyscale using inferred Adobe metrics.
	     * 
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    greyscale() {
	        const buf = this.bitmap.data;
	        this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
	            const grey = Math.round(
	                0.299 * buf[idx] +
	                0.587 * buf[idx + 1] +
	                0.114 * buf[idx + 2]
	            );
	            buf[idx] = grey;
	            buf[idx + 1] = grey;
	            buf[idx + 2] = grey;
	        });
	        return this;
	    }

	    /**
	     * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
	     * 
	     * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
	     * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
	     * @param {number} width The width of the new image after reframing
	     * @param {number} height The height of the new image after reframing
	     * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    reframe(xOffset, yOffset, width, height, fillRGBA) {
	        const cropX = (xOffset < 0 ? 0 : xOffset);
	        const cropY = (yOffset < 0 ? 0 : yOffset);
	        const cropWidth = (width + cropX > this.bitmap.width ?
	                this.bitmap.width - cropX : width);
	        const cropHeight = (height + cropY > this.bitmap.height ?
	                this.bitmap.height - cropY : height);
	        const newX = (xOffset < 0 ? -xOffset : 0);
	        const newY = (yOffset < 0 ? -yOffset : 0);

	        let image;
	        if (fillRGBA === undefined) {
	            if (cropX !== xOffset || cropY != yOffset ||
	                    cropWidth !== width || cropHeight !== height)
	            {
	                throw new GifError(`fillRGBA required for this reframing`);
	            }
	            image = new BitmapImage(width, height);
	        }
	        else {
	            image = new BitmapImage(width, height, fillRGBA);
	        }
	        this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);
	        this.bitmap = image.bitmap;
	        return this;
	    }

	    /**
	     * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
	     * 
	     * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    scale(factor) {
	        if (factor === 1) {
	            return;
	        }
	        if (!Number.isInteger(factor) || factor < 1) {
	            throw new Error("the scale must be an integer >= 1");
	        }
	        const sourceWidth = this.bitmap.width;
	        const sourceHeight = this.bitmap.height;
	        const destByteWidth = sourceWidth * factor * 4;
	        const sourceBuf = this.bitmap.data;
	        const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
	        let sourceIndex = 0;
	        let priorDestRowIndex;
	        let destIndex = 0;
	        for (let y = 0; y < sourceHeight; ++y) {
	            priorDestRowIndex = destIndex;
	            for (let x = 0; x < sourceWidth; ++x) {
	                const color = sourceBuf.readUInt32BE(sourceIndex, true);
	                for (let cx = 0; cx < factor; ++cx) {
	                    destBuf.writeUInt32BE(color, destIndex);
	                    destIndex += 4;
	                }
	                sourceIndex += 4;
	            }
	            for (let cy = 1; cy < factor; ++cy) {
	                destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
	                destIndex += destByteWidth;
	                priorDestRowIndex += destByteWidth;
	            }
	        }
	        this.bitmap = {
	            width: sourceWidth * factor,
	            height: sourceHeight * factor,
	            data: destBuf
	        };
	        return this;
	    }

	    /**
	     * Scans all coordinates of the image, handing each in turn to the provided handler function.
	     *
	     * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
	     * @see scanAllIndexes
	     */

	    scanAllCoords(scanHandler) {
	        const width = this.bitmap.width;
	        const bufferLength = this.bitmap.data.length;
	        let x = 0;
	        let y = 0;

	        for (let bi = 0; bi < bufferLength; bi += 4) {
	            scanHandler(x, y, bi);
	            if (++x === width) {
	                x = 0;
	                ++y;
	            }
	        }
	    }

	    /**
	     * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
	     *
	     * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
	     * @see scanAllCoords
	     */

	    scanAllIndexes(scanHandler) {
	        const bufferLength = this.bitmap.data.length;
	        for (let bi = 0; bi < bufferLength; bi += 4) {
	            scanHandler(bi);
	        }
	    }
	}

	bitmapimage = BitmapImage;
	return bitmapimage;
}

var gif$1 = {};

var hasRequiredGif;

function requireGif () {
	if (hasRequiredGif) return gif$1;
	hasRequiredGif = 1;

	/** @class Gif */

	class Gif {

	    // width - width of GIF in pixels
	    // height - height of GIF in pixels
	    // loops - 0 = unending; (n > 0) = iterate n times
	    // usesTransparency - whether any frames have transparent pixels
	    // colorScope - scope of color tables in GIF
	    // frames - array of frames
	    // buffer - GIF-formatted data

	    /**
	     * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
	     * 
	     * Property | Description
	     * --- | ---
	     * width | width of the GIF at its widest
	     * height | height of the GIF at its highest
	     * loops | the number of times the GIF should loop before stopping; 0 => loop indefinitely
	     * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
	     * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
	     * frames | a array of GifFrame instances, one for each frame of the GIF
	     * buffer | a Buffer holding the encoding's byte data
	     * 
	     * Its constructor should only ever be called by the GIF encoder or decoder.
	     *
	     * @param {Buffer} buffer A Buffer containing the encoded bytes
	     * @param {GifFrame[]} frames Array of frames found in the encoding
	     * @param {object} spec Properties of the encoding as listed above
	     */

	    constructor(buffer, frames, spec) {
	        this.width = spec.width;
	        this.height = spec.height;
	        this.loops = spec.loops;
	        this.usesTransparency = spec.usesTransparency;
	        this.colorScope = spec.colorScope;
	        this.frames = frames;
	        this.buffer = buffer;
	    }
	}

	Gif.GlobalColorsPreferred = 0;
	Gif.GlobalColorsOnly = 1;
	Gif.LocalColorsOnly = 2;

	/** @class GifError */

	class GifError extends Error {

	    /**
	     * GifError is a class representing a GIF-related error
	     * 
	     * @param {string|Error} messageOrError
	     */

	    constructor(messageOrError) {
	        super(messageOrError);
	        if (messageOrError instanceof Error) {
	            this.stack = 'Gif' + messageOrError.stack;
	        }
	    }
	}

	gif$1.Gif = Gif;
	gif$1.GifError = GifError;
	return gif$1;
}

var gifcodec = {};

var gifutil = {};

var imageQ;
var hasRequiredImageQ;

function requireImageQ () {
	if (hasRequiredImageQ) return imageQ;
	hasRequiredImageQ = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
	var __export = (target, all) => {
	  for (var name in all)
	    __defProp(target, name, { get: all[name], enumerable: true });
	};
	var __reExport = (target, module2, copyDefault, desc) => {
	  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
	    for (let key of __getOwnPropNames(module2))
	      if (!__hasOwnProp.call(target, key) && (copyDefault))
	        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
	  }
	  return target;
	};
	var __toCommonJS = /* @__PURE__ */ ((cache) => {
	  return (module2, temp) => {
	    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
	  };
	})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
	var __publicField = (obj, key, value) => {
	  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
	  return value;
	};

	// src/index.ts
	var src_exports = {};
	__export(src_exports, {
	  applyPalette: () => applyPalette,
	  applyPaletteSync: () => applyPaletteSync,
	  buildPalette: () => buildPalette,
	  buildPaletteSync: () => buildPaletteSync,
	  constants: () => constants_exports,
	  conversion: () => conversion_exports,
	  distance: () => distance_exports,
	  image: () => image_exports,
	  palette: () => palette_exports,
	  quality: () => quality_exports,
	  utils: () => utils_exports
	});

	// src/constants/index.ts
	var constants_exports = {};
	__export(constants_exports, {
	  bt709: () => bt709_exports
	});

	// src/constants/bt709.ts
	var bt709_exports = {};
	__export(bt709_exports, {
	  Y: () => Y,
	  x: () => x,
	  y: () => y
	});
	var Y = /* @__PURE__ */ ((Y2) => {
	  Y2[Y2["RED"] = 0.2126] = "RED";
	  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
	  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
	  Y2[Y2["WHITE"] = 1] = "WHITE";
	  return Y2;
	})(Y || {});
	var x = /* @__PURE__ */ ((x2) => {
	  x2[x2["RED"] = 0.64] = "RED";
	  x2[x2["GREEN"] = 0.3] = "GREEN";
	  x2[x2["BLUE"] = 0.15] = "BLUE";
	  x2[x2["WHITE"] = 0.3127] = "WHITE";
	  return x2;
	})(x || {});
	var y = /* @__PURE__ */ ((y2) => {
	  y2[y2["RED"] = 0.33] = "RED";
	  y2[y2["GREEN"] = 0.6] = "GREEN";
	  y2[y2["BLUE"] = 0.06] = "BLUE";
	  y2[y2["WHITE"] = 0.329] = "WHITE";
	  return y2;
	})(y || {});

	// src/conversion/index.ts
	var conversion_exports = {};
	__export(conversion_exports, {
	  lab2rgb: () => lab2rgb,
	  lab2xyz: () => lab2xyz,
	  rgb2hsl: () => rgb2hsl,
	  rgb2lab: () => rgb2lab,
	  rgb2xyz: () => rgb2xyz,
	  xyz2lab: () => xyz2lab,
	  xyz2rgb: () => xyz2rgb
	});

	// src/conversion/rgb2xyz.ts
	function correctGamma(n) {
	  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
	}
	function rgb2xyz(r, g, b) {
	  r = correctGamma(r / 255);
	  g = correctGamma(g / 255);
	  b = correctGamma(b / 255);
	  return {
	    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
	    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
	    z: r * 0.0193 + g * 0.1192 + b * 0.9505
	  };
	}

	// src/utils/arithmetic.ts
	var arithmetic_exports = {};
	__export(arithmetic_exports, {
	  degrees2radians: () => degrees2radians,
	  inRange0to255: () => inRange0to255,
	  inRange0to255Rounded: () => inRange0to255Rounded,
	  intInRange: () => intInRange,
	  max3: () => max3,
	  min3: () => min3,
	  stableSort: () => stableSort
	});
	function degrees2radians(n) {
	  return n * (Math.PI / 180);
	}
	function max3(a, b, c) {
	  let m = a;
	  if (m < b)
	    m = b;
	  if (m < c)
	    m = c;
	  return m;
	}
	function min3(a, b, c) {
	  let m = a;
	  if (m > b)
	    m = b;
	  if (m > c)
	    m = c;
	  return m;
	}
	function intInRange(value, low, high) {
	  if (value > high)
	    value = high;
	  if (value < low)
	    value = low;
	  return value | 0;
	}
	function inRange0to255Rounded(n) {
	  n = Math.round(n);
	  if (n > 255)
	    n = 255;
	  else if (n < 0)
	    n = 0;
	  return n;
	}
	function inRange0to255(n) {
	  if (n > 255)
	    n = 255;
	  else if (n < 0)
	    n = 0;
	  return n;
	}
	function stableSort(arrayToSort, callback) {
	  const type = typeof arrayToSort[0];
	  let sorted;
	  if (type === "number" || type === "string") {
	    const ord = /* @__PURE__ */ Object.create(null);
	    for (let i = 0, l = arrayToSort.length; i < l; i++) {
	      const val = arrayToSort[i];
	      if (ord[val] || ord[val] === 0)
	        continue;
	      ord[val] = i;
	    }
	    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
	  } else {
	    const ord2 = arrayToSort.slice(0);
	    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
	  }
	  return sorted;
	}

	// src/conversion/rgb2hsl.ts
	function rgb2hsl(r, g, b) {
	  const min = min3(r, g, b);
	  const max = max3(r, g, b);
	  const delta = max - min;
	  const l = (min + max) / 510;
	  let s = 0;
	  if (l > 0 && l < 1)
	    s = delta / (l < 0.5 ? max + min : 510 - max - min);
	  let h = 0;
	  if (delta > 0) {
	    if (max === r) {
	      h = (g - b) / delta;
	    } else if (max === g) {
	      h = 2 + (b - r) / delta;
	    } else {
	      h = 4 + (r - g) / delta;
	    }
	    h *= 60;
	    if (h < 0)
	      h += 360;
	  }
	  return { h, s, l };
	}

	// src/conversion/xyz2lab.ts
	var refX = 0.95047;
	var refY = 1;
	var refZ = 1.08883;
	function pivot(n) {
	  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
	}
	function xyz2lab(x2, y2, z) {
	  x2 = pivot(x2 / refX);
	  y2 = pivot(y2 / refY);
	  z = pivot(z / refZ);
	  if (116 * y2 - 16 < 0)
	    throw new Error("xxx");
	  return {
	    L: Math.max(0, 116 * y2 - 16),
	    a: 500 * (x2 - y2),
	    b: 200 * (y2 - z)
	  };
	}

	// src/conversion/rgb2lab.ts
	function rgb2lab(r, g, b) {
	  const xyz = rgb2xyz(r, g, b);
	  return xyz2lab(xyz.x, xyz.y, xyz.z);
	}

	// src/conversion/lab2xyz.ts
	var refX2 = 0.95047;
	var refY2 = 1;
	var refZ2 = 1.08883;
	function pivot2(n) {
	  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
	}
	function lab2xyz(L, a, b) {
	  const y2 = (L + 16) / 116;
	  const x2 = a / 500 + y2;
	  const z = y2 - b / 200;
	  return {
	    x: refX2 * pivot2(x2),
	    y: refY2 * pivot2(y2),
	    z: refZ2 * pivot2(z)
	  };
	}

	// src/conversion/xyz2rgb.ts
	function correctGamma2(n) {
	  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
	}
	function xyz2rgb(x2, y2, z) {
	  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
	  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
	  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
	  return {
	    r: inRange0to255Rounded(r * 255),
	    g: inRange0to255Rounded(g * 255),
	    b: inRange0to255Rounded(b * 255)
	  };
	}

	// src/conversion/lab2rgb.ts
	function lab2rgb(L, a, b) {
	  const xyz = lab2xyz(L, a, b);
	  return xyz2rgb(xyz.x, xyz.y, xyz.z);
	}

	// src/distance/index.ts
	var distance_exports = {};
	__export(distance_exports, {
	  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
	  AbstractEuclidean: () => AbstractEuclidean,
	  AbstractManhattan: () => AbstractManhattan,
	  CIE94GraphicArts: () => CIE94GraphicArts,
	  CIE94Textiles: () => CIE94Textiles,
	  CIEDE2000: () => CIEDE2000,
	  CMetric: () => CMetric,
	  Euclidean: () => Euclidean,
	  EuclideanBT709: () => EuclideanBT709,
	  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
	  Manhattan: () => Manhattan,
	  ManhattanBT709: () => ManhattanBT709,
	  ManhattanNommyde: () => ManhattanNommyde,
	  PNGQuant: () => PNGQuant
	});

	// src/distance/distanceCalculator.ts
	var AbstractDistanceCalculator = class {
	  constructor() {
	    __publicField(this, "_maxDistance");
	    __publicField(this, "_whitePoint");
	    this._setDefaults();
	    this.setWhitePoint(255, 255, 255, 255);
	  }
	  setWhitePoint(r, g, b, a) {
	    this._whitePoint = {
	      r: r > 0 ? 255 / r : 0,
	      g: g > 0 ? 255 / g : 0,
	      b: b > 0 ? 255 / b : 0,
	      a: a > 0 ? 255 / a : 0
	    };
	    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
	  }
	  calculateNormalized(colorA, colorB) {
	    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
	  }
	};

	// src/distance/cie94.ts
	var AbstractCIE94 = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
	    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
	    const dL = lab1.L - lab2.L;
	    const dA = lab1.a - lab2.a;
	    const dB = lab1.b - lab2.b;
	    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
	    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
	    const dC = c1 - c2;
	    let deltaH = dA * dA + dB * dB - dC * dC;
	    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
	    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
	    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
	  }
	};
	var CIE94Textiles = class extends AbstractCIE94 {
	  _setDefaults() {
	    this._Kl = 2;
	    this._K1 = 0.048;
	    this._K2 = 0.014;
	    this._kA = 0.25 * 50 / 255;
	  }
	};
	var CIE94GraphicArts = class extends AbstractCIE94 {
	  _setDefaults() {
	    this._Kl = 1;
	    this._K1 = 0.045;
	    this._K2 = 0.015;
	    this._kA = 0.25 * 100 / 255;
	  }
	};

	// src/distance/ciede2000.ts
	var _CIEDE2000 = class extends AbstractDistanceCalculator {
	  _setDefaults() {
	  }
	  static _calculatehp(b, ap) {
	    const hp = Math.atan2(b, ap);
	    if (hp >= 0)
	      return hp;
	    return hp + _CIEDE2000._deg360InRad;
	  }
	  static _calculateRT(ahp, aCp) {
	    const aCp_to_7 = aCp ** 7;
	    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
	    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
	    return -Math.sin(2 * delta_theta) * R_C;
	  }
	  static _calculateT(ahp) {
	    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
	  }
	  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
	    const hpSum = h1p + h2p;
	    if (C1pC2p === 0)
	      return hpSum;
	    if (h_bar <= _CIEDE2000._deg180InRad)
	      return hpSum / 2;
	    if (hpSum < _CIEDE2000._deg360InRad) {
	      return (hpSum + _CIEDE2000._deg360InRad) / 2;
	    }
	    return (hpSum - _CIEDE2000._deg360InRad) / 2;
	  }
	  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
	    let dhp;
	    if (C1pC2p === 0) {
	      dhp = 0;
	    } else if (h_bar <= _CIEDE2000._deg180InRad) {
	      dhp = h2p - h1p;
	    } else if (h2p <= h1p) {
	      dhp = h2p - h1p + _CIEDE2000._deg360InRad;
	    } else {
	      dhp = h2p - h1p - _CIEDE2000._deg360InRad;
	    }
	    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
	  }
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
	    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
	    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
	    const dE2 = this.calculateRawInLab(lab1, lab2);
	    return Math.sqrt(dE2 + dA * dA);
	  }
	  calculateRawInLab(Lab1, Lab2) {
	    const L1 = Lab1.L;
	    const a1 = Lab1.a;
	    const b1 = Lab1.b;
	    const L2 = Lab2.L;
	    const a2 = Lab2.a;
	    const b2 = Lab2.b;
	    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
	    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
	    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
	    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
	    const a1p = (1 + G) * a1;
	    const a2p = (1 + G) * a2;
	    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
	    const C2p = Math.sqrt(a2p * a2p + b2 * b2);
	    const C1pC2p = C1p * C2p;
	    const h1p = _CIEDE2000._calculatehp(b1, a1p);
	    const h2p = _CIEDE2000._calculatehp(b2, a2p);
	    const h_bar = Math.abs(h1p - h2p);
	    const dLp = L2 - L1;
	    const dCp = C2p - C1p;
	    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
	    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
	    const T = _CIEDE2000._calculateT(ahp);
	    const aCp = (C1p + C2p) / 2;
	    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
	    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
	    const S_C = 1 + 0.045 * aCp;
	    const S_H = 1 + 0.015 * T * aCp;
	    const R_T = _CIEDE2000._calculateRT(ahp, aCp);
	    const dLpSL = dLp / S_L;
	    const dCpSC = dCp / S_C;
	    const dHpSH = dHp / S_H;
	    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
	  }
	};
	var CIEDE2000 = _CIEDE2000;
	__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
	__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
	__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
	__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
	__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
	__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
	__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
	__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
	__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));

	// src/distance/cmetric.ts
	var CMetric = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const rmean = (r1 + r2) / 2 * this._whitePoint.r;
	    const r = (r1 - r2) * this._whitePoint.r;
	    const g = (g1 - g2) * this._whitePoint.g;
	    const b = (b1 - b2) * this._whitePoint.b;
	    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
	    const dA = (a2 - a1) * this._whitePoint.a;
	    return Math.sqrt(dE + dA * dA);
	  }
	  _setDefaults() {
	  }
	};

	// src/distance/euclidean.ts
	var AbstractEuclidean = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const dR = r2 - r1;
	    const dG = g2 - g1;
	    const dB = b2 - b1;
	    const dA = a2 - a1;
	    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
	  }
	};
	var Euclidean = class extends AbstractEuclidean {
	  _setDefaults() {
	    this._kR = 1;
	    this._kG = 1;
	    this._kB = 1;
	    this._kA = 1;
	  }
	};
	var EuclideanBT709 = class extends AbstractEuclidean {
	  _setDefaults() {
	    this._kR = 0.2126 /* RED */;
	    this._kG = 0.7152 /* GREEN */;
	    this._kB = 0.0722 /* BLUE */;
	    this._kA = 1;
	  }
	};
	var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
	  _setDefaults() {
	    this._kR = 0.2126 /* RED */;
	    this._kG = 0.7152 /* GREEN */;
	    this._kB = 0.0722 /* BLUE */;
	    this._kA = 0;
	  }
	};

	// src/distance/manhattan.ts
	var AbstractManhattan = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    let dR = r2 - r1;
	    let dG = g2 - g1;
	    let dB = b2 - b1;
	    let dA = a2 - a1;
	    if (dR < 0)
	      dR = 0 - dR;
	    if (dG < 0)
	      dG = 0 - dG;
	    if (dB < 0)
	      dB = 0 - dB;
	    if (dA < 0)
	      dA = 0 - dA;
	    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
	  }
	};
	var Manhattan = class extends AbstractManhattan {
	  _setDefaults() {
	    this._kR = 1;
	    this._kG = 1;
	    this._kB = 1;
	    this._kA = 1;
	  }
	};
	var ManhattanNommyde = class extends AbstractManhattan {
	  _setDefaults() {
	    this._kR = 0.4984;
	    this._kG = 0.8625;
	    this._kB = 0.2979;
	    this._kA = 1;
	  }
	};
	var ManhattanBT709 = class extends AbstractManhattan {
	  _setDefaults() {
	    this._kR = 0.2126 /* RED */;
	    this._kG = 0.7152 /* GREEN */;
	    this._kB = 0.0722 /* BLUE */;
	    this._kA = 1;
	  }
	};

	// src/distance/pngQuant.ts
	var PNGQuant = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const alphas = (a2 - a1) * this._whitePoint.a;
	    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
	  }
	  _colordifferenceCh(x2, y2, alphas) {
	    const black = x2 - y2;
	    const white = black + alphas;
	    return black * black + white * white;
	  }
	  _setDefaults() {
	  }
	};

	// src/palette/index.ts
	var palette_exports = {};
	__export(palette_exports, {
	  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
	  ColorHistogram: () => ColorHistogram,
	  NeuQuant: () => NeuQuant,
	  NeuQuantFloat: () => NeuQuantFloat,
	  RGBQuant: () => RGBQuant,
	  WuColorCube: () => WuColorCube,
	  WuQuant: () => WuQuant
	});

	// src/palette/paletteQuantizer.ts
	var AbstractPaletteQuantizer = class {
	  quantizeSync() {
	    for (const value of this.quantize()) {
	      if (value.palette) {
	        return value.palette;
	      }
	    }
	    throw new Error("unreachable");
	  }
	};

	// src/utils/point.ts
	var Point = class {
	  constructor() {
	    __publicField(this, "r");
	    __publicField(this, "g");
	    __publicField(this, "b");
	    __publicField(this, "a");
	    __publicField(this, "uint32");
	    __publicField(this, "rgba");
	    this.uint32 = -1 >>> 0;
	    this.r = this.g = this.b = this.a = 0;
	    this.rgba = new Array(4);
	    this.rgba[0] = 0;
	    this.rgba[1] = 0;
	    this.rgba[2] = 0;
	    this.rgba[3] = 0;
	  }
	  static createByQuadruplet(quadruplet) {
	    const point = new Point();
	    point.r = quadruplet[0] | 0;
	    point.g = quadruplet[1] | 0;
	    point.b = quadruplet[2] | 0;
	    point.a = quadruplet[3] | 0;
	    point._loadUINT32();
	    point._loadQuadruplet();
	    return point;
	  }
	  static createByRGBA(red, green, blue, alpha) {
	    const point = new Point();
	    point.r = red | 0;
	    point.g = green | 0;
	    point.b = blue | 0;
	    point.a = alpha | 0;
	    point._loadUINT32();
	    point._loadQuadruplet();
	    return point;
	  }
	  static createByUint32(uint32) {
	    const point = new Point();
	    point.uint32 = uint32 >>> 0;
	    point._loadRGBA();
	    point._loadQuadruplet();
	    return point;
	  }
	  from(point) {
	    this.r = point.r;
	    this.g = point.g;
	    this.b = point.b;
	    this.a = point.a;
	    this.uint32 = point.uint32;
	    this.rgba[0] = point.r;
	    this.rgba[1] = point.g;
	    this.rgba[2] = point.b;
	    this.rgba[3] = point.a;
	  }
	  getLuminosity(useAlphaChannel) {
	    let r = this.r;
	    let g = this.g;
	    let b = this.b;
	    if (useAlphaChannel) {
	      r = Math.min(255, 255 - this.a + this.a * r / 255);
	      g = Math.min(255, 255 - this.a + this.a * g / 255);
	      b = Math.min(255, 255 - this.a + this.a * b / 255);
	    }
	    return r * 0.2126 /* RED */ + g * 0.7152 /* GREEN */ + b * 0.0722 /* BLUE */;
	  }
	  _loadUINT32() {
	    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
	  }
	  _loadRGBA() {
	    this.r = this.uint32 & 255;
	    this.g = this.uint32 >>> 8 & 255;
	    this.b = this.uint32 >>> 16 & 255;
	    this.a = this.uint32 >>> 24 & 255;
	  }
	  _loadQuadruplet() {
	    this.rgba[0] = this.r;
	    this.rgba[1] = this.g;
	    this.rgba[2] = this.b;
	    this.rgba[3] = this.a;
	  }
	};

	// src/utils/pointContainer.ts
	var PointContainer = class {
	  constructor() {
	    __publicField(this, "_pointArray");
	    __publicField(this, "_width");
	    __publicField(this, "_height");
	    this._width = 0;
	    this._height = 0;
	    this._pointArray = [];
	  }
	  getWidth() {
	    return this._width;
	  }
	  getHeight() {
	    return this._height;
	  }
	  setWidth(width) {
	    this._width = width;
	  }
	  setHeight(height) {
	    this._height = height;
	  }
	  getPointArray() {
	    return this._pointArray;
	  }
	  clone() {
	    const clone = new PointContainer();
	    clone._width = this._width;
	    clone._height = this._height;
	    for (let i = 0, l = this._pointArray.length; i < l; i++) {
	      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);
	    }
	    return clone;
	  }
	  toUint32Array() {
	    const l = this._pointArray.length;
	    const uint32Array = new Uint32Array(l);
	    for (let i = 0; i < l; i++) {
	      uint32Array[i] = this._pointArray[i].uint32;
	    }
	    return uint32Array;
	  }
	  toUint8Array() {
	    return new Uint8Array(this.toUint32Array().buffer);
	  }
	  static fromHTMLImageElement(img) {
	    const width = img.naturalWidth;
	    const height = img.naturalHeight;
	    const canvas = document.createElement("canvas");
	    canvas.width = width;
	    canvas.height = height;
	    const ctx = canvas.getContext("2d");
	    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
	    return PointContainer.fromHTMLCanvasElement(canvas);
	  }
	  static fromHTMLCanvasElement(canvas) {
	    const width = canvas.width;
	    const height = canvas.height;
	    const ctx = canvas.getContext("2d");
	    const imgData = ctx.getImageData(0, 0, width, height);
	    return PointContainer.fromImageData(imgData);
	  }
	  static fromImageData(imageData) {
	    const width = imageData.width;
	    const height = imageData.height;
	    return PointContainer.fromUint8Array(imageData.data, width, height);
	  }
	  static fromUint8Array(uint8Array, width, height) {
	    switch (Object.prototype.toString.call(uint8Array)) {
	      case "[object Uint8ClampedArray]":
	      case "[object Uint8Array]":
	        break;
	      default:
	        uint8Array = new Uint8Array(uint8Array);
	    }
	    const uint32Array = new Uint32Array(uint8Array.buffer);
	    return PointContainer.fromUint32Array(uint32Array, width, height);
	  }
	  static fromUint32Array(uint32Array, width, height) {
	    const container = new PointContainer();
	    container._width = width;
	    container._height = height;
	    for (let i = 0, l = uint32Array.length; i < l; i++) {
	      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);
	    }
	    return container;
	  }
	  static fromBuffer(buffer, width, height) {
	    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
	    return PointContainer.fromUint32Array(uint32Array, width, height);
	  }
	};

	// src/utils/palette.ts
	var hueGroups = 10;
	function hueGroup(hue, segmentsNumber) {
	  const maxHue = 360;
	  const seg = maxHue / segmentsNumber;
	  const half = seg / 2;
	  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
	    if (hue >= mid && hue < mid + seg)
	      return i;
	  }
	  return 0;
	}
	var Palette = class {
	  constructor() {
	    __publicField(this, "_pointContainer");
	    __publicField(this, "_pointArray", []);
	    __publicField(this, "_i32idx", {});
	    this._pointContainer = new PointContainer();
	    this._pointContainer.setHeight(1);
	    this._pointArray = this._pointContainer.getPointArray();
	  }
	  add(color) {
	    this._pointArray.push(color);
	    this._pointContainer.setWidth(this._pointArray.length);
	  }
	  has(color) {
	    for (let i = this._pointArray.length - 1; i >= 0; i--) {
	      if (color.uint32 === this._pointArray[i].uint32)
	        return true;
	    }
	    return false;
	  }
	  getNearestColor(colorDistanceCalculator, color) {
	    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
	  }
	  getPointContainer() {
	    return this._pointContainer;
	  }
	  _nearestPointFromCache(key) {
	    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
	  }
	  _getNearestIndex(colorDistanceCalculator, point) {
	    let idx = this._nearestPointFromCache("" + point.uint32);
	    if (idx >= 0)
	      return idx;
	    let minimalDistance = Number.MAX_VALUE;
	    idx = 0;
	    for (let i = 0, l = this._pointArray.length; i < l; i++) {
	      const p = this._pointArray[i];
	      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
	      if (distance < minimalDistance) {
	        minimalDistance = distance;
	        idx = i;
	      }
	    }
	    this._i32idx[point.uint32] = idx;
	    return idx;
	  }
	  sort() {
	    this._i32idx = {};
	    this._pointArray.sort((a, b) => {
	      const hslA = rgb2hsl(a.r, a.g, a.b);
	      const hslB = rgb2hsl(b.r, b.g, b.b);
	      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
	      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
	      const hueDiff = hueB - hueA;
	      if (hueDiff)
	        return -hueDiff;
	      const lA = a.getLuminosity(true);
	      const lB = b.getLuminosity(true);
	      if (lB - lA !== 0)
	        return lB - lA;
	      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
	      if (satDiff)
	        return -satDiff;
	      return 0;
	    });
	  }
	};

	// src/utils/index.ts
	var utils_exports = {};
	__export(utils_exports, {
	  HueStatistics: () => HueStatistics,
	  Palette: () => Palette,
	  Point: () => Point,
	  PointContainer: () => PointContainer,
	  ProgressTracker: () => ProgressTracker,
	  arithmetic: () => arithmetic_exports
	});

	// src/utils/hueStatistics.ts
	var HueGroup = class {
	  constructor() {
	    __publicField(this, "num", 0);
	    __publicField(this, "cols", []);
	  }
	};
	var HueStatistics = class {
	  constructor(numGroups, minCols) {
	    __publicField(this, "_numGroups");
	    __publicField(this, "_minCols");
	    __publicField(this, "_stats");
	    __publicField(this, "_groupsFull");
	    this._numGroups = numGroups;
	    this._minCols = minCols;
	    this._stats = [];
	    for (let i = 0; i <= numGroups; i++) {
	      this._stats[i] = new HueGroup();
	    }
	    this._groupsFull = 0;
	  }
	  check(i32) {
	    if (this._groupsFull === this._numGroups + 1) {
	      this.check = () => {
	      };
	    }
	    const r = i32 & 255;
	    const g = i32 >>> 8 & 255;
	    const b = i32 >>> 16 & 255;
	    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
	    const gr = this._stats[hg];
	    const min = this._minCols;
	    gr.num++;
	    if (gr.num > min) {
	      return;
	    }
	    if (gr.num === min) {
	      this._groupsFull++;
	    }
	    if (gr.num <= min) {
	      this._stats[hg].cols.push(i32);
	    }
	  }
	  injectIntoDictionary(histG) {
	    for (let i = 0; i <= this._numGroups; i++) {
	      if (this._stats[i].num <= this._minCols) {
	        this._stats[i].cols.forEach((col) => {
	          if (!histG[col]) {
	            histG[col] = 1;
	          } else {
	            histG[col]++;
	          }
	        });
	      }
	    }
	  }
	  injectIntoArray(histG) {
	    for (let i = 0; i <= this._numGroups; i++) {
	      if (this._stats[i].num <= this._minCols) {
	        this._stats[i].cols.forEach((col) => {
	          if (histG.indexOf(col) === -1) {
	            histG.push(col);
	          }
	        });
	      }
	    }
	  }
	};

	// src/utils/progressTracker.ts
	var _ProgressTracker = class {
	  constructor(valueRange, progressRange) {
	    __publicField(this, "progress");
	    __publicField(this, "_step");
	    __publicField(this, "_range");
	    __publicField(this, "_last");
	    __publicField(this, "_progressRange");
	    this._range = valueRange;
	    this._progressRange = progressRange;
	    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
	    this._last = -this._step;
	    this.progress = 0;
	  }
	  shouldNotify(current) {
	    if (current - this._last >= this._step) {
	      this._last = current;
	      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
	      return true;
	    }
	    return false;
	  }
	};
	var ProgressTracker = _ProgressTracker;
	__publicField(ProgressTracker, "steps", 100);

	// src/palette/neuquant/neuquant.ts
	var networkBiasShift = 3;
	var Neuron = class {
	  constructor(defaultValue) {
	    __publicField(this, "r");
	    __publicField(this, "g");
	    __publicField(this, "b");
	    __publicField(this, "a");
	    this.r = this.g = this.b = this.a = defaultValue;
	  }
	  toPoint() {
	    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
	  }
	  subtract(r, g, b, a) {
	    this.r -= r | 0;
	    this.g -= g | 0;
	    this.b -= b | 0;
	    this.a -= a | 0;
	  }
	};
	var _NeuQuant = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256) {
	    super();
	    __publicField(this, "_pointArray");
	    __publicField(this, "_networkSize");
	    __publicField(this, "_network");
	    __publicField(this, "_sampleFactor");
	    __publicField(this, "_radPower");
	    __publicField(this, "_freq");
	    __publicField(this, "_bias");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._pointArray = [];
	    this._sampleFactor = 1;
	    this._networkSize = colors;
	    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
	  }
	  sample(pointContainer) {
	    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
	  }
	  *quantize() {
	    this._init();
	    yield* this._learn();
	    yield {
	      palette: this._buildPalette(),
	      progress: 100
	    };
	  }
	  _init() {
	    this._freq = [];
	    this._bias = [];
	    this._radPower = [];
	    this._network = [];
	    for (let i = 0; i < this._networkSize; i++) {
	      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
	      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;
	      this._bias[i] = 0;
	    }
	  }
	  *_learn() {
	    let sampleFactor = this._sampleFactor;
	    const pointsNumber = this._pointArray.length;
	    if (pointsNumber < _NeuQuant._minpicturebytes)
	      sampleFactor = 1;
	    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
	    const pointsToSample = pointsNumber / sampleFactor | 0;
	    let delta = pointsToSample / _NeuQuant._nCycles | 0;
	    let alpha = _NeuQuant._initAlpha;
	    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
	    let rad = radius >> _NeuQuant._radiusBiasShift;
	    if (rad <= 1)
	      rad = 0;
	    for (let i = 0; i < rad; i++) {
	      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
	    }
	    let step;
	    if (pointsNumber < _NeuQuant._minpicturebytes) {
	      step = 1;
	    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
	      step = _NeuQuant._prime1;
	    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
	      step = _NeuQuant._prime2;
	    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
	      step = _NeuQuant._prime3;
	    } else {
	      step = _NeuQuant._prime4;
	    }
	    const tracker = new ProgressTracker(pointsToSample, 99);
	    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
	      if (tracker.shouldNotify(i)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      const point = this._pointArray[pointIndex];
	      const b = point.b << networkBiasShift;
	      const g = point.g << networkBiasShift;
	      const r = point.r << networkBiasShift;
	      const a = point.a << networkBiasShift;
	      const neuronIndex = this._contest(b, g, r, a);
	      this._alterSingle(alpha, neuronIndex, b, g, r, a);
	      if (rad !== 0)
	        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
	      pointIndex += step;
	      if (pointIndex >= pointsNumber)
	        pointIndex -= pointsNumber;
	      i++;
	      if (delta === 0)
	        delta = 1;
	      if (i % delta === 0) {
	        alpha -= alpha / alphadec | 0;
	        radius -= radius / _NeuQuant._radiusDecrease | 0;
	        rad = radius >> _NeuQuant._radiusBiasShift;
	        if (rad <= 1)
	          rad = 0;
	        for (let j = 0; j < rad; j++) {
	          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
	        }
	      }
	    }
	  }
	  _buildPalette() {
	    const palette = new Palette();
	    this._network.forEach((neuron) => {
	      palette.add(neuron.toPoint());
	    });
	    palette.sort();
	    return palette;
	  }
	  _alterNeighbour(rad, i, b, g, r, al) {
	    let lo = i - rad;
	    if (lo < -1)
	      lo = -1;
	    let hi = i + rad;
	    if (hi > this._networkSize)
	      hi = this._networkSize;
	    let j = i + 1;
	    let k = i - 1;
	    let m = 1;
	    while (j < hi || k > lo) {
	      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
	      if (j < hi) {
	        const p = this._network[j++];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	      if (k > lo) {
	        const p = this._network[k--];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	    }
	  }
	  _alterSingle(alpha, i, b, g, r, a) {
	    alpha /= _NeuQuant._initAlpha;
	    const n = this._network[i];
	    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
	  }
	  _contest(b, g, r, a) {
	    const multiplier = 255 * 4 << networkBiasShift;
	    let bestd = 2147483647;
	    let bestbiasd = bestd;
	    let bestpos = -1;
	    let bestbiaspos = bestpos;
	    for (let i = 0; i < this._networkSize; i++) {
	      const n = this._network[i];
	      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
	      if (dist < bestd) {
	        bestd = dist;
	        bestpos = i;
	      }
	      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);
	      if (biasdist < bestbiasd) {
	        bestbiasd = biasdist;
	        bestbiaspos = i;
	      }
	      const betafreq = this._freq[i] >> _NeuQuant._betaShift;
	      this._freq[i] -= betafreq;
	      this._bias[i] += betafreq << _NeuQuant._gammaShift;
	    }
	    this._freq[bestpos] += _NeuQuant._beta;
	    this._bias[bestpos] -= _NeuQuant._betaGamma;
	    return bestbiaspos;
	  }
	};
	var NeuQuant = _NeuQuant;
	__publicField(NeuQuant, "_prime1", 499);
	__publicField(NeuQuant, "_prime2", 491);
	__publicField(NeuQuant, "_prime3", 487);
	__publicField(NeuQuant, "_prime4", 503);
	__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
	__publicField(NeuQuant, "_nCycles", 100);
	__publicField(NeuQuant, "_initialBiasShift", 16);
	__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
	__publicField(NeuQuant, "_gammaShift", 10);
	__publicField(NeuQuant, "_betaShift", 10);
	__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
	__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
	__publicField(NeuQuant, "_radiusBiasShift", 6);
	__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
	__publicField(NeuQuant, "_radiusDecrease", 30);
	__publicField(NeuQuant, "_alphaBiasShift", 10);
	__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
	__publicField(NeuQuant, "_radBiasShift", 8);
	__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
	__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
	__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);

	// src/palette/neuquant/neuquantFloat.ts
	var networkBiasShift2 = 3;
	var NeuronFloat = class {
	  constructor(defaultValue) {
	    __publicField(this, "r");
	    __publicField(this, "g");
	    __publicField(this, "b");
	    __publicField(this, "a");
	    this.r = this.g = this.b = this.a = defaultValue;
	  }
	  toPoint() {
	    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
	  }
	  subtract(r, g, b, a) {
	    this.r -= r;
	    this.g -= g;
	    this.b -= b;
	    this.a -= a;
	  }
	};
	var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256) {
	    super();
	    __publicField(this, "_pointArray");
	    __publicField(this, "_networkSize");
	    __publicField(this, "_network");
	    __publicField(this, "_sampleFactor");
	    __publicField(this, "_radPower");
	    __publicField(this, "_freq");
	    __publicField(this, "_bias");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._pointArray = [];
	    this._sampleFactor = 1;
	    this._networkSize = colors;
	    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
	  }
	  sample(pointContainer) {
	    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
	  }
	  *quantize() {
	    this._init();
	    yield* this._learn();
	    yield {
	      palette: this._buildPalette(),
	      progress: 100
	    };
	  }
	  _init() {
	    this._freq = [];
	    this._bias = [];
	    this._radPower = [];
	    this._network = [];
	    for (let i = 0; i < this._networkSize; i++) {
	      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);
	      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;
	      this._bias[i] = 0;
	    }
	  }
	  *_learn() {
	    let sampleFactor = this._sampleFactor;
	    const pointsNumber = this._pointArray.length;
	    if (pointsNumber < _NeuQuantFloat._minpicturebytes)
	      sampleFactor = 1;
	    const alphadec = 30 + (sampleFactor - 1) / 3;
	    const pointsToSample = pointsNumber / sampleFactor;
	    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
	    let alpha = _NeuQuantFloat._initAlpha;
	    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
	    let rad = radius >> _NeuQuantFloat._radiusBiasShift;
	    if (rad <= 1)
	      rad = 0;
	    for (let i = 0; i < rad; i++) {
	      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
	    }
	    let step;
	    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
	      step = 1;
	    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
	      step = _NeuQuantFloat._prime1;
	    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
	      step = _NeuQuantFloat._prime2;
	    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
	      step = _NeuQuantFloat._prime3;
	    } else {
	      step = _NeuQuantFloat._prime4;
	    }
	    const tracker = new ProgressTracker(pointsToSample, 99);
	    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
	      if (tracker.shouldNotify(i)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      const point = this._pointArray[pointIndex];
	      const b = point.b << networkBiasShift2;
	      const g = point.g << networkBiasShift2;
	      const r = point.r << networkBiasShift2;
	      const a = point.a << networkBiasShift2;
	      const neuronIndex = this._contest(b, g, r, a);
	      this._alterSingle(alpha, neuronIndex, b, g, r, a);
	      if (rad !== 0)
	        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
	      pointIndex += step;
	      if (pointIndex >= pointsNumber)
	        pointIndex -= pointsNumber;
	      i++;
	      if (delta === 0)
	        delta = 1;
	      if (i % delta === 0) {
	        alpha -= alpha / alphadec;
	        radius -= radius / _NeuQuantFloat._radiusDecrease;
	        rad = radius >> _NeuQuantFloat._radiusBiasShift;
	        if (rad <= 1)
	          rad = 0;
	        for (let j = 0; j < rad; j++) {
	          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
	        }
	      }
	    }
	  }
	  _buildPalette() {
	    const palette = new Palette();
	    this._network.forEach((neuron) => {
	      palette.add(neuron.toPoint());
	    });
	    palette.sort();
	    return palette;
	  }
	  _alterNeighbour(rad, i, b, g, r, al) {
	    let lo = i - rad;
	    if (lo < -1)
	      lo = -1;
	    let hi = i + rad;
	    if (hi > this._networkSize)
	      hi = this._networkSize;
	    let j = i + 1;
	    let k = i - 1;
	    let m = 1;
	    while (j < hi || k > lo) {
	      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
	      if (j < hi) {
	        const p = this._network[j++];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	      if (k > lo) {
	        const p = this._network[k--];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	    }
	  }
	  _alterSingle(alpha, i, b, g, r, a) {
	    alpha /= _NeuQuantFloat._initAlpha;
	    const n = this._network[i];
	    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
	  }
	  _contest(b, g, r, al) {
	    const multiplier = 255 * 4 << networkBiasShift2;
	    let bestd = 2147483647;
	    let bestbiasd = bestd;
	    let bestpos = -1;
	    let bestbiaspos = bestpos;
	    for (let i = 0; i < this._networkSize; i++) {
	      const n = this._network[i];
	      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
	      if (dist < bestd) {
	        bestd = dist;
	        bestpos = i;
	      }
	      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
	      if (biasdist < bestbiasd) {
	        bestbiasd = biasdist;
	        bestbiaspos = i;
	      }
	      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
	      this._freq[i] -= betafreq;
	      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
	    }
	    this._freq[bestpos] += _NeuQuantFloat._beta;
	    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
	    return bestbiaspos;
	  }
	};
	var NeuQuantFloat = _NeuQuantFloat;
	__publicField(NeuQuantFloat, "_prime1", 499);
	__publicField(NeuQuantFloat, "_prime2", 491);
	__publicField(NeuQuantFloat, "_prime3", 487);
	__publicField(NeuQuantFloat, "_prime4", 503);
	__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
	__publicField(NeuQuantFloat, "_nCycles", 100);
	__publicField(NeuQuantFloat, "_initialBiasShift", 16);
	__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
	__publicField(NeuQuantFloat, "_gammaShift", 10);
	__publicField(NeuQuantFloat, "_betaShift", 10);
	__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
	__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
	__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
	__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
	__publicField(NeuQuantFloat, "_radiusDecrease", 30);
	__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
	__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
	__publicField(NeuQuantFloat, "_radBiasShift", 8);
	__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
	__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
	__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);

	// src/palette/rgbquant/colorHistogram.ts
	var _ColorHistogram = class {
	  constructor(method, colors) {
	    __publicField(this, "_method");
	    __publicField(this, "_hueStats");
	    __publicField(this, "_histogram");
	    __publicField(this, "_initColors");
	    __publicField(this, "_minHueCols");
	    this._method = method;
	    this._minHueCols = colors << 2;
	    this._initColors = colors << 2;
	    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
	    this._histogram = /* @__PURE__ */ Object.create(null);
	  }
	  sample(pointContainer) {
	    switch (this._method) {
	      case 1:
	        this._colorStats1D(pointContainer);
	        break;
	      case 2:
	        this._colorStats2D(pointContainer);
	        break;
	    }
	  }
	  getImportanceSortedColorsIDXI32() {
	    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
	    if (sorted.length === 0) {
	      return [];
	    }
	    let idxi32;
	    switch (this._method) {
	      case 1:
	        const initialColorsLimit = Math.min(sorted.length, this._initColors);
	        const last = sorted[initialColorsLimit - 1];
	        const freq = this._histogram[last];
	        idxi32 = sorted.slice(0, initialColorsLimit);
	        let pos = initialColorsLimit;
	        const len = sorted.length;
	        while (pos < len && this._histogram[sorted[pos]] === freq) {
	          idxi32.push(sorted[pos++]);
	        }
	        this._hueStats.injectIntoArray(idxi32);
	        break;
	      case 2:
	        idxi32 = sorted;
	        break;
	      default:
	        throw new Error("Incorrect method");
	    }
	    return idxi32.map((v) => +v);
	  }
	  _colorStats1D(pointContainer) {
	    const histG = this._histogram;
	    const pointArray = pointContainer.getPointArray();
	    const len = pointArray.length;
	    for (let i = 0; i < len; i++) {
	      const col = pointArray[i].uint32;
	      this._hueStats.check(col);
	      if (col in histG) {
	        histG[col]++;
	      } else {
	        histG[col] = 1;
	      }
	    }
	  }
	  _colorStats2D(pointContainer) {
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const pointArray = pointContainer.getPointArray();
	    const boxW = _ColorHistogram._boxSize[0];
	    const boxH = _ColorHistogram._boxSize[1];
	    const area = boxW * boxH;
	    const boxes = this._makeBoxes(width, height, boxW, boxH);
	    const histG = this._histogram;
	    boxes.forEach((box) => {
	      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
	      if (effc < 2)
	        effc = 2;
	      const histL = {};
	      this._iterateBox(box, width, (i) => {
	        const col = pointArray[i].uint32;
	        this._hueStats.check(col);
	        if (col in histG) {
	          histG[col]++;
	        } else if (col in histL) {
	          if (++histL[col] >= effc) {
	            histG[col] = histL[col];
	          }
	        } else {
	          histL[col] = 1;
	        }
	      });
	    });
	    this._hueStats.injectIntoDictionary(histG);
	  }
	  _iterateBox(bbox, wid, fn) {
	    const b = bbox;
	    const i0 = b.y * wid + b.x;
	    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
	    const incr = wid - b.w + 1;
	    let cnt = 0;
	    let i = i0;
	    do {
	      fn.call(this, i);
	      i += ++cnt % b.w === 0 ? incr : 1;
	    } while (i <= i1);
	  }
	  _makeBoxes(width, height, stepX, stepY) {
	    const wrem = width % stepX;
	    const hrem = height % stepY;
	    const xend = width - wrem;
	    const yend = height - hrem;
	    const boxesArray = [];
	    for (let y2 = 0; y2 < height; y2 += stepY) {
	      for (let x2 = 0; x2 < width; x2 += stepX) {
	        boxesArray.push({
	          x: x2,
	          y: y2,
	          w: x2 === xend ? wrem : stepX,
	          h: y2 === yend ? hrem : stepY
	        });
	      }
	    }
	    return boxesArray;
	  }
	};
	var ColorHistogram = _ColorHistogram;
	__publicField(ColorHistogram, "_boxSize", [64, 64]);
	__publicField(ColorHistogram, "_boxPixels", 2);
	__publicField(ColorHistogram, "_hueGroups", 10);

	// src/palette/rgbquant/rgbquant.ts
	var RemovedColor = class {
	  constructor(index, color, distance) {
	    __publicField(this, "index");
	    __publicField(this, "color");
	    __publicField(this, "distance");
	    this.index = index;
	    this.color = color;
	    this.distance = distance;
	  }
	};
	var RGBQuant = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256, method = 2) {
	    super();
	    __publicField(this, "_colors");
	    __publicField(this, "_initialDistance");
	    __publicField(this, "_distanceIncrement");
	    __publicField(this, "_histogram");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._colors = colors;
	    this._histogram = new ColorHistogram(method, colors);
	    this._initialDistance = 0.01;
	    this._distanceIncrement = 5e-3;
	  }
	  sample(image) {
	    this._histogram.sample(image);
	  }
	  *quantize() {
	    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
	    if (idxi32.length === 0) {
	      throw new Error("No colors in image");
	    }
	    yield* this._buildPalette(idxi32);
	  }
	  *_buildPalette(idxi32) {
	    const palette = new Palette();
	    const colorArray = palette.getPointContainer().getPointArray();
	    const usageArray = new Array(idxi32.length);
	    for (let i = 0; i < idxi32.length; i++) {
	      colorArray.push(Point.createByUint32(idxi32[i]));
	      usageArray[i] = 1;
	    }
	    const len = colorArray.length;
	    const memDist = [];
	    let palLen = len;
	    let thold = this._initialDistance;
	    const tracker = new ProgressTracker(palLen - this._colors, 99);
	    while (palLen > this._colors) {
	      memDist.length = 0;
	      for (let i = 0; i < len; i++) {
	        if (tracker.shouldNotify(len - palLen)) {
	          yield {
	            progress: tracker.progress
	          };
	        }
	        if (usageArray[i] === 0)
	          continue;
	        const pxi = colorArray[i];
	        for (let j = i + 1; j < len; j++) {
	          if (usageArray[j] === 0)
	            continue;
	          const pxj = colorArray[j];
	          const dist = this._distance.calculateNormalized(pxi, pxj);
	          if (dist < thold) {
	            memDist.push(new RemovedColor(j, pxj, dist));
	            usageArray[j] = 0;
	            palLen--;
	          }
	        }
	      }
	      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
	    }
	    if (palLen < this._colors) {
	      stableSort(memDist, (a, b) => b.distance - a.distance);
	      let k = 0;
	      while (palLen < this._colors && k < memDist.length) {
	        const removedColor = memDist[k];
	        usageArray[removedColor.index] = 1;
	        palLen++;
	        k++;
	      }
	    }
	    let colors = colorArray.length;
	    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
	      if (usageArray[colorIndex] === 0) {
	        if (colorIndex !== colors - 1) {
	          colorArray[colorIndex] = colorArray[colors - 1];
	        }
	        --colors;
	      }
	    }
	    colorArray.length = colors;
	    palette.sort();
	    yield {
	      palette,
	      progress: 100
	    };
	  }
	};

	// src/palette/wu/wuQuant.ts
	function createArray1D(dimension1) {
	  const a = [];
	  for (let k = 0; k < dimension1; k++) {
	    a[k] = 0;
	  }
	  return a;
	}
	function createArray4D(dimension1, dimension2, dimension3, dimension4) {
	  const a = new Array(dimension1);
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = new Array(dimension2);
	    for (let j = 0; j < dimension2; j++) {
	      a[i][j] = new Array(dimension3);
	      for (let k = 0; k < dimension3; k++) {
	        a[i][j][k] = new Array(dimension4);
	        for (let l = 0; l < dimension4; l++) {
	          a[i][j][k][l] = 0;
	        }
	      }
	    }
	  }
	  return a;
	}
	function createArray3D(dimension1, dimension2, dimension3) {
	  const a = new Array(dimension1);
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = new Array(dimension2);
	    for (let j = 0; j < dimension2; j++) {
	      a[i][j] = new Array(dimension3);
	      for (let k = 0; k < dimension3; k++) {
	        a[i][j][k] = 0;
	      }
	    }
	  }
	  return a;
	}
	function fillArray3D(a, dimension1, dimension2, dimension3, value) {
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = [];
	    for (let j = 0; j < dimension2; j++) {
	      a[i][j] = [];
	      for (let k = 0; k < dimension3; k++) {
	        a[i][j][k] = value;
	      }
	    }
	  }
	}
	function fillArray1D(a, dimension1, value) {
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = value;
	  }
	}
	var WuColorCube = class {
	  constructor() {
	    __publicField(this, "redMinimum");
	    __publicField(this, "redMaximum");
	    __publicField(this, "greenMinimum");
	    __publicField(this, "greenMaximum");
	    __publicField(this, "blueMinimum");
	    __publicField(this, "blueMaximum");
	    __publicField(this, "volume");
	    __publicField(this, "alphaMinimum");
	    __publicField(this, "alphaMaximum");
	  }
	};
	var _WuQuant = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
	    super();
	    __publicField(this, "_reds");
	    __publicField(this, "_greens");
	    __publicField(this, "_blues");
	    __publicField(this, "_alphas");
	    __publicField(this, "_sums");
	    __publicField(this, "_weights");
	    __publicField(this, "_momentsRed");
	    __publicField(this, "_momentsGreen");
	    __publicField(this, "_momentsBlue");
	    __publicField(this, "_momentsAlpha");
	    __publicField(this, "_moments");
	    __publicField(this, "_table");
	    __publicField(this, "_pixels");
	    __publicField(this, "_cubes");
	    __publicField(this, "_colors");
	    __publicField(this, "_significantBitsPerChannel");
	    __publicField(this, "_maxSideIndex");
	    __publicField(this, "_alphaMaxSideIndex");
	    __publicField(this, "_sideSize");
	    __publicField(this, "_alphaSideSize");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._setQuality(significantBitsPerChannel);
	    this._initialize(colors);
	  }
	  sample(image) {
	    const pointArray = image.getPointArray();
	    for (let i = 0, l = pointArray.length; i < l; i++) {
	      this._addColor(pointArray[i]);
	    }
	    this._pixels = this._pixels.concat(pointArray);
	  }
	  *quantize() {
	    yield* this._preparePalette();
	    const palette = new Palette();
	    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
	      if (this._sums[paletteIndex] > 0) {
	        const sum = this._sums[paletteIndex];
	        const r = this._reds[paletteIndex] / sum;
	        const g = this._greens[paletteIndex] / sum;
	        const b = this._blues[paletteIndex] / sum;
	        const a = this._alphas[paletteIndex] / sum;
	        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
	        palette.add(color);
	      }
	    }
	    palette.sort();
	    yield {
	      palette,
	      progress: 100
	    };
	  }
	  *_preparePalette() {
	    yield* this._calculateMoments();
	    let next = 0;
	    const volumeVariance = createArray1D(this._colors);
	    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
	      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
	        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
	        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
	      } else {
	        volumeVariance[next] = 0;
	        cubeIndex--;
	      }
	      next = 0;
	      let temp = volumeVariance[0];
	      for (let index = 1; index <= cubeIndex; ++index) {
	        if (volumeVariance[index] > temp) {
	          temp = volumeVariance[index];
	          next = index;
	        }
	      }
	      if (temp <= 0) {
	        this._colors = cubeIndex + 1;
	        break;
	      }
	    }
	    const lookupRed = [];
	    const lookupGreen = [];
	    const lookupBlue = [];
	    const lookupAlpha = [];
	    for (let k = 0; k < this._colors; ++k) {
	      const weight = _WuQuant._volume(this._cubes[k], this._weights);
	      if (weight > 0) {
	        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
	        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
	        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
	        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
	      } else {
	        lookupRed[k] = 0;
	        lookupGreen[k] = 0;
	        lookupBlue[k] = 0;
	        lookupAlpha[k] = 0;
	      }
	    }
	    this._reds = createArray1D(this._colors + 1);
	    this._greens = createArray1D(this._colors + 1);
	    this._blues = createArray1D(this._colors + 1);
	    this._alphas = createArray1D(this._colors + 1);
	    this._sums = createArray1D(this._colors + 1);
	    for (let index = 0, l = this._pixels.length; index < l; index++) {
	      const color = this._pixels[index];
	      const match = -1;
	      let bestMatch = match;
	      let bestDistance = Number.MAX_VALUE;
	      for (let lookup = 0; lookup < this._colors; lookup++) {
	        const foundRed = lookupRed[lookup];
	        const foundGreen = lookupGreen[lookup];
	        const foundBlue = lookupBlue[lookup];
	        const foundAlpha = lookupAlpha[lookup];
	        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
	        if (distance < bestDistance) {
	          bestDistance = distance;
	          bestMatch = lookup;
	        }
	      }
	      this._reds[bestMatch] += color.r;
	      this._greens[bestMatch] += color.g;
	      this._blues[bestMatch] += color.b;
	      this._alphas[bestMatch] += color.a;
	      this._sums[bestMatch]++;
	    }
	  }
	  _addColor(color) {
	    const bitsToRemove = 8 - this._significantBitsPerChannel;
	    const indexRed = (color.r >> bitsToRemove) + 1;
	    const indexGreen = (color.g >> bitsToRemove) + 1;
	    const indexBlue = (color.b >> bitsToRemove) + 1;
	    const indexAlpha = (color.a >> bitsToRemove) + 1;
	    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
	    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
	    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
	    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
	    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
	    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
	  }
	  *_calculateMoments() {
	    const area = [];
	    const areaRed = [];
	    const areaGreen = [];
	    const areaBlue = [];
	    const areaAlpha = [];
	    const area2 = [];
	    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    let trackerProgress = 0;
	    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
	    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
	      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
	      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
	        if (tracker.shouldNotify(trackerProgress)) {
	          yield {
	            progress: tracker.progress
	          };
	        }
	        fillArray1D(area, this._sideSize, 0);
	        fillArray1D(areaRed, this._sideSize, 0);
	        fillArray1D(areaGreen, this._sideSize, 0);
	        fillArray1D(areaBlue, this._sideSize, 0);
	        fillArray1D(areaAlpha, this._sideSize, 0);
	        fillArray1D(area2, this._sideSize, 0);
	        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
	          let line = 0;
	          let lineRed = 0;
	          let lineGreen = 0;
	          let lineBlue = 0;
	          let lineAlpha = 0;
	          let line2 = 0;
	          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
	            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
	            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
	            area[blueIndex] += line;
	            areaRed[blueIndex] += lineRed;
	            areaGreen[blueIndex] += lineGreen;
	            areaBlue[blueIndex] += lineBlue;
	            areaAlpha[blueIndex] += lineAlpha;
	            area2[blueIndex] += line2;
	            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
	            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
	            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
	            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
	            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
	            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
	            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
	            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
	            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
	            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
	            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
	            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
	          }
	        }
	      }
	    }
	  }
	  static _volumeFloat(cube, moment) {
	    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	  }
	  static _volume(cube, moment) {
	    return _WuQuant._volumeFloat(cube, moment) | 0;
	  }
	  static _top(cube, direction, position, moment) {
	    let result;
	    switch (direction) {
	      case _WuQuant._alpha:
	        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	        break;
	      case _WuQuant._red:
	        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
	        break;
	      case _WuQuant._green:
	        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
	        break;
	      case _WuQuant._blue:
	        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
	        break;
	      default:
	        throw new Error("impossible");
	    }
	    return result | 0;
	  }
	  static _bottom(cube, direction, moment) {
	    switch (direction) {
	      case _WuQuant._alpha:
	        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      case _WuQuant._red:
	        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      case _WuQuant._green:
	        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      case _WuQuant._blue:
	        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      default:
	        return 0;
	    }
	  }
	  _calculateVariance(cube) {
	    const volumeRed = _WuQuant._volume(cube, this._momentsRed);
	    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
	    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
	    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
	    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
	    const volumeWeight = _WuQuant._volume(cube, this._weights);
	    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
	    return volumeMoment - distance / volumeWeight;
	  }
	  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
	    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
	    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
	    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
	    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
	    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
	    let result = 0;
	    let cutPosition = -1;
	    for (let position = first; position < last; ++position) {
	      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
	      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
	      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
	      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
	      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
	      if (halfWeight !== 0) {
	        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
	        let temp = halfDistance / halfWeight;
	        halfRed = wholeRed - halfRed;
	        halfGreen = wholeGreen - halfGreen;
	        halfBlue = wholeBlue - halfBlue;
	        halfAlpha = wholeAlpha - halfAlpha;
	        halfWeight = wholeWeight - halfWeight;
	        if (halfWeight !== 0) {
	          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
	          temp += halfDistance / halfWeight;
	          if (temp > result) {
	            result = temp;
	            cutPosition = position;
	          }
	        }
	      }
	    }
	    return { max: result, position: cutPosition };
	  }
	  _cut(first, second) {
	    let direction;
	    const wholeRed = _WuQuant._volume(first, this._momentsRed);
	    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
	    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
	    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
	    const wholeWeight = _WuQuant._volume(first, this._weights);
	    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
	      direction = _WuQuant._alpha;
	      if (alpha.position < 0)
	        return false;
	    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
	      direction = _WuQuant._red;
	    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
	      direction = _WuQuant._green;
	    } else {
	      direction = _WuQuant._blue;
	    }
	    second.redMaximum = first.redMaximum;
	    second.greenMaximum = first.greenMaximum;
	    second.blueMaximum = first.blueMaximum;
	    second.alphaMaximum = first.alphaMaximum;
	    switch (direction) {
	      case _WuQuant._red:
	        second.redMinimum = first.redMaximum = red.position;
	        second.greenMinimum = first.greenMinimum;
	        second.blueMinimum = first.blueMinimum;
	        second.alphaMinimum = first.alphaMinimum;
	        break;
	      case _WuQuant._green:
	        second.greenMinimum = first.greenMaximum = green.position;
	        second.redMinimum = first.redMinimum;
	        second.blueMinimum = first.blueMinimum;
	        second.alphaMinimum = first.alphaMinimum;
	        break;
	      case _WuQuant._blue:
	        second.blueMinimum = first.blueMaximum = blue.position;
	        second.redMinimum = first.redMinimum;
	        second.greenMinimum = first.greenMinimum;
	        second.alphaMinimum = first.alphaMinimum;
	        break;
	      case _WuQuant._alpha:
	        second.alphaMinimum = first.alphaMaximum = alpha.position;
	        second.blueMinimum = first.blueMinimum;
	        second.redMinimum = first.redMinimum;
	        second.greenMinimum = first.greenMinimum;
	        break;
	    }
	    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
	    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
	    return true;
	  }
	  _initialize(colors) {
	    this._colors = colors;
	    this._cubes = [];
	    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
	      this._cubes[cubeIndex] = new WuColorCube();
	    }
	    this._cubes[0].redMinimum = 0;
	    this._cubes[0].greenMinimum = 0;
	    this._cubes[0].blueMinimum = 0;
	    this._cubes[0].alphaMinimum = 0;
	    this._cubes[0].redMaximum = this._maxSideIndex;
	    this._cubes[0].greenMaximum = this._maxSideIndex;
	    this._cubes[0].blueMaximum = this._maxSideIndex;
	    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
	    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._table = [];
	    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
	      this._table[tableIndex] = tableIndex * tableIndex;
	    }
	    this._pixels = [];
	  }
	  _setQuality(significantBitsPerChannel = 5) {
	    this._significantBitsPerChannel = significantBitsPerChannel;
	    this._maxSideIndex = 1 << this._significantBitsPerChannel;
	    this._alphaMaxSideIndex = this._maxSideIndex;
	    this._sideSize = this._maxSideIndex + 1;
	    this._alphaSideSize = this._alphaMaxSideIndex + 1;
	  }
	};
	var WuQuant = _WuQuant;
	__publicField(WuQuant, "_alpha", 3);
	__publicField(WuQuant, "_red", 2);
	__publicField(WuQuant, "_green", 1);
	__publicField(WuQuant, "_blue", 0);

	// src/image/index.ts
	var image_exports = {};
	__export(image_exports, {
	  AbstractImageQuantizer: () => AbstractImageQuantizer,
	  ErrorDiffusionArray: () => ErrorDiffusionArray,
	  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
	  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
	  NearestColor: () => NearestColor
	});

	// src/image/imageQuantizer.ts
	var AbstractImageQuantizer = class {
	  quantizeSync(pointContainer, palette) {
	    for (const value of this.quantize(pointContainer, palette)) {
	      if (value.pointContainer) {
	        return value.pointContainer;
	      }
	    }
	    throw new Error("unreachable");
	  }
	};

	// src/image/nearestColor.ts
	var NearestColor = class extends AbstractImageQuantizer {
	  constructor(colorDistanceCalculator) {
	    super();
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	  }
	  *quantize(pointContainer, palette) {
	    const pointArray = pointContainer.getPointArray();
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const tracker = new ProgressTracker(height, 99);
	    for (let y2 = 0; y2 < height; y2++) {
	      if (tracker.shouldNotify(y2)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
	        const point = pointArray[idx];
	        point.from(palette.getNearestColor(this._distance, point));
	      }
	    }
	    yield {
	      pointContainer,
	      progress: 100
	    };
	  }
	};

	// src/image/array.ts
	var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
	  return ErrorDiffusionArrayKernel2;
	})(ErrorDiffusionArrayKernel || {});
	var ErrorDiffusionArray = class extends AbstractImageQuantizer {
	  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
	    super();
	    __publicField(this, "_minColorDistance");
	    __publicField(this, "_serpentine");
	    __publicField(this, "_kernel");
	    __publicField(this, "_calculateErrorLikeGIMP");
	    __publicField(this, "_distance");
	    this._setKernel(kernel);
	    this._distance = colorDistanceCalculator;
	    this._minColorDistance = minimumColorDistanceToDither;
	    this._serpentine = serpentine;
	    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
	  }
	  *quantize(pointContainer, palette) {
	    const pointArray = pointContainer.getPointArray();
	    const originalPoint = new Point();
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const errorLines = [];
	    let dir = 1;
	    let maxErrorLines = 1;
	    for (const kernel of this._kernel) {
	      const kernelErrorLines = kernel[2] + 1;
	      if (maxErrorLines < kernelErrorLines)
	        maxErrorLines = kernelErrorLines;
	    }
	    for (let i = 0; i < maxErrorLines; i++) {
	      this._fillErrorLine(errorLines[i] = [], width);
	    }
	    const tracker = new ProgressTracker(height, 99);
	    for (let y2 = 0; y2 < height; y2++) {
	      if (tracker.shouldNotify(y2)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      if (this._serpentine)
	        dir *= -1;
	      const lni = y2 * width;
	      const xStart = dir === 1 ? 0 : width - 1;
	      const xEnd = dir === 1 ? width : -1;
	      this._fillErrorLine(errorLines[0], width);
	      errorLines.push(errorLines.shift());
	      const errorLine = errorLines[0];
	      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
	        const point = pointArray[idx];
	        const error = errorLine[x2];
	        originalPoint.from(point);
	        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
	        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);
	        point.from(palettePoint);
	        if (this._minColorDistance) {
	          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
	          if (dist < this._minColorDistance)
	            continue;
	        }
	        let er;
	        let eg;
	        let eb;
	        let ea;
	        if (this._calculateErrorLikeGIMP) {
	          er = correctedPoint.r - palettePoint.r;
	          eg = correctedPoint.g - palettePoint.g;
	          eb = correctedPoint.b - palettePoint.b;
	          ea = correctedPoint.a - palettePoint.a;
	        } else {
	          er = originalPoint.r - palettePoint.r;
	          eg = originalPoint.g - palettePoint.g;
	          eb = originalPoint.b - palettePoint.b;
	          ea = originalPoint.a - palettePoint.a;
	        }
	        const dStart = dir === 1 ? 0 : this._kernel.length - 1;
	        const dEnd = dir === 1 ? this._kernel.length : -1;
	        for (let i = dStart; i !== dEnd; i += dir) {
	          const x1 = this._kernel[i][1] * dir;
	          const y1 = this._kernel[i][2];
	          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
	            const d = this._kernel[i][0];
	            const e = errorLines[y1][x1 + x2];
	            e[0] += er * d;
	            e[1] += eg * d;
	            e[2] += eb * d;
	            e[3] += ea * d;
	          }
	        }
	      }
	    }
	    yield {
	      pointContainer,
	      progress: 100
	    };
	  }
	  _fillErrorLine(errorLine, width) {
	    if (errorLine.length > width) {
	      errorLine.length = width;
	    }
	    const l = errorLine.length;
	    for (let i = 0; i < l; i++) {
	      const error = errorLine[i];
	      error[0] = error[1] = error[2] = error[3] = 0;
	    }
	    for (let i = l; i < width; i++) {
	      errorLine[i] = [0, 0, 0, 0];
	    }
	  }
	  _setKernel(kernel) {
	    switch (kernel) {
	      case 0 /* FloydSteinberg */:
	        this._kernel = [
	          [7 / 16, 1, 0],
	          [3 / 16, -1, 1],
	          [5 / 16, 0, 1],
	          [1 / 16, 1, 1]
	        ];
	        break;
	      case 1 /* FalseFloydSteinberg */:
	        this._kernel = [
	          [3 / 8, 1, 0],
	          [3 / 8, 0, 1],
	          [2 / 8, 1, 1]
	        ];
	        break;
	      case 2 /* Stucki */:
	        this._kernel = [
	          [8 / 42, 1, 0],
	          [4 / 42, 2, 0],
	          [2 / 42, -2, 1],
	          [4 / 42, -1, 1],
	          [8 / 42, 0, 1],
	          [4 / 42, 1, 1],
	          [2 / 42, 2, 1],
	          [1 / 42, -2, 2],
	          [2 / 42, -1, 2],
	          [4 / 42, 0, 2],
	          [2 / 42, 1, 2],
	          [1 / 42, 2, 2]
	        ];
	        break;
	      case 3 /* Atkinson */:
	        this._kernel = [
	          [1 / 8, 1, 0],
	          [1 / 8, 2, 0],
	          [1 / 8, -1, 1],
	          [1 / 8, 0, 1],
	          [1 / 8, 1, 1],
	          [1 / 8, 0, 2]
	        ];
	        break;
	      case 4 /* Jarvis */:
	        this._kernel = [
	          [7 / 48, 1, 0],
	          [5 / 48, 2, 0],
	          [3 / 48, -2, 1],
	          [5 / 48, -1, 1],
	          [7 / 48, 0, 1],
	          [5 / 48, 1, 1],
	          [3 / 48, 2, 1],
	          [1 / 48, -2, 2],
	          [3 / 48, -1, 2],
	          [5 / 48, 0, 2],
	          [3 / 48, 1, 2],
	          [1 / 48, 2, 2]
	        ];
	        break;
	      case 5 /* Burkes */:
	        this._kernel = [
	          [8 / 32, 1, 0],
	          [4 / 32, 2, 0],
	          [2 / 32, -2, 1],
	          [4 / 32, -1, 1],
	          [8 / 32, 0, 1],
	          [4 / 32, 1, 1],
	          [2 / 32, 2, 1]
	        ];
	        break;
	      case 6 /* Sierra */:
	        this._kernel = [
	          [5 / 32, 1, 0],
	          [3 / 32, 2, 0],
	          [2 / 32, -2, 1],
	          [4 / 32, -1, 1],
	          [5 / 32, 0, 1],
	          [4 / 32, 1, 1],
	          [2 / 32, 2, 1],
	          [2 / 32, -1, 2],
	          [3 / 32, 0, 2],
	          [2 / 32, 1, 2]
	        ];
	        break;
	      case 7 /* TwoSierra */:
	        this._kernel = [
	          [4 / 16, 1, 0],
	          [3 / 16, 2, 0],
	          [1 / 16, -2, 1],
	          [2 / 16, -1, 1],
	          [3 / 16, 0, 1],
	          [2 / 16, 1, 1],
	          [1 / 16, 2, 1]
	        ];
	        break;
	      case 8 /* SierraLite */:
	        this._kernel = [
	          [2 / 4, 1, 0],
	          [1 / 4, -1, 1],
	          [1 / 4, 0, 1]
	        ];
	        break;
	      default:
	        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
	    }
	  }
	};

	// src/image/spaceFillingCurves/hilbertCurve.ts
	function* hilbertCurve(width, height, callback) {
	  const maxBound = Math.max(width, height);
	  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
	  const tracker = new ProgressTracker(width * height, 99);
	  const data = {
	    width,
	    height,
	    level,
	    callback,
	    tracker,
	    index: 0,
	    x: 0,
	    y: 0
	  };
	  yield* walkHilbert(data, 1 /* UP */);
	  visit(data, 0 /* NONE */);
	}
	function* walkHilbert(data, direction) {
	  if (data.level < 1)
	    return;
	  if (data.tracker.shouldNotify(data.index)) {
	    yield { progress: data.tracker.progress };
	  }
	  data.level--;
	  switch (direction) {
	    case 2 /* LEFT */:
	      yield* walkHilbert(data, 1 /* UP */);
	      visit(data, 3 /* RIGHT */);
	      yield* walkHilbert(data, 2 /* LEFT */);
	      visit(data, 4 /* DOWN */);
	      yield* walkHilbert(data, 2 /* LEFT */);
	      visit(data, 2 /* LEFT */);
	      yield* walkHilbert(data, 4 /* DOWN */);
	      break;
	    case 3 /* RIGHT */:
	      yield* walkHilbert(data, 4 /* DOWN */);
	      visit(data, 2 /* LEFT */);
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      visit(data, 1 /* UP */);
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      visit(data, 3 /* RIGHT */);
	      yield* walkHilbert(data, 1 /* UP */);
	      break;
	    case 1 /* UP */:
	      yield* walkHilbert(data, 2 /* LEFT */);
	      visit(data, 4 /* DOWN */);
	      yield* walkHilbert(data, 1 /* UP */);
	      visit(data, 3 /* RIGHT */);
	      yield* walkHilbert(data, 1 /* UP */);
	      visit(data, 1 /* UP */);
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      break;
	    case 4 /* DOWN */:
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      visit(data, 1 /* UP */);
	      yield* walkHilbert(data, 4 /* DOWN */);
	      visit(data, 2 /* LEFT */);
	      yield* walkHilbert(data, 4 /* DOWN */);
	      visit(data, 4 /* DOWN */);
	      yield* walkHilbert(data, 2 /* LEFT */);
	      break;
	  }
	  data.level++;
	}
	function visit(data, direction) {
	  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
	    data.callback(data.x, data.y);
	    data.index++;
	  }
	  switch (direction) {
	    case 2 /* LEFT */:
	      data.x--;
	      break;
	    case 3 /* RIGHT */:
	      data.x++;
	      break;
	    case 1 /* UP */:
	      data.y--;
	      break;
	    case 4 /* DOWN */:
	      data.y++;
	      break;
	  }
	}

	// src/image/riemersma.ts
	var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
	  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
	    super();
	    __publicField(this, "_distance");
	    __publicField(this, "_weights");
	    __publicField(this, "_errorQueueSize");
	    this._distance = colorDistanceCalculator;
	    this._errorQueueSize = errorQueueSize;
	    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
	  }
	  *quantize(pointContainer, palette) {
	    const pointArray = pointContainer.getPointArray();
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const errorQueue = [];
	    let head = 0;
	    for (let i = 0; i < this._errorQueueSize; i++) {
	      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
	    }
	    yield* hilbertCurve(width, height, (x2, y2) => {
	      const p = pointArray[x2 + y2 * width];
	      let { r, g, b, a } = p;
	      for (let i = 0; i < this._errorQueueSize; i++) {
	        const weight = this._weights[i];
	        const e = errorQueue[(i + head) % this._errorQueueSize];
	        r += e.r * weight;
	        g += e.g * weight;
	        b += e.b * weight;
	        a += e.a * weight;
	      }
	      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
	      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
	      head = (head + 1) % this._errorQueueSize;
	      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
	      errorQueue[tail].r = p.r - quantizedPoint.r;
	      errorQueue[tail].g = p.g - quantizedPoint.g;
	      errorQueue[tail].b = p.b - quantizedPoint.b;
	      errorQueue[tail].a = p.a - quantizedPoint.a;
	      p.from(quantizedPoint);
	    });
	    yield {
	      pointContainer,
	      progress: 100
	    };
	  }
	  static _createWeights(errorPropagation, errorQueueSize) {
	    const weights = [];
	    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
	    for (let i = 0, next = 1; i < errorQueueSize; i++) {
	      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
	      next *= multiplier;
	    }
	    return weights;
	  }
	};

	// src/quality/index.ts
	var quality_exports = {};
	__export(quality_exports, {
	  ssim: () => ssim
	});

	// src/quality/ssim.ts
	var K1 = 0.01;
	var K2 = 0.03;
	function ssim(image1, image2) {
	  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
	    throw new Error("Images have different sizes!");
	  }
	  const bitsPerComponent = 8;
	  const L = (1 << bitsPerComponent) - 1;
	  const c1 = (K1 * L) ** 2;
	  const c2 = (K2 * L) ** 2;
	  let numWindows = 0;
	  let mssim = 0;
	  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
	    let sigxy = 0;
	    let sigsqx = 0;
	    let sigsqy = 0;
	    for (let i = 0; i < lumaValues1.length; i++) {
	      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;
	      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;
	      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
	    }
	    const numPixelsInWin = lumaValues1.length - 1;
	    sigsqx /= numPixelsInWin;
	    sigsqy /= numPixelsInWin;
	    sigxy /= numPixelsInWin;
	    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
	    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
	    const ssim2 = numerator / denominator;
	    mssim += ssim2;
	    numWindows++;
	  });
	  return mssim / numWindows;
	}
	function iterate(image1, image2, callback) {
	  const windowSize = 8;
	  const width = image1.getWidth();
	  const height = image1.getHeight();
	  for (let y2 = 0; y2 < height; y2 += windowSize) {
	    for (let x2 = 0; x2 < width; x2 += windowSize) {
	      const windowWidth = Math.min(windowSize, width - x2);
	      const windowHeight = Math.min(windowSize, height - y2);
	      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
	      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
	      const averageLuma1 = calculateAverageLuma(lumaValues1);
	      const averageLuma2 = calculateAverageLuma(lumaValues2);
	      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
	    }
	  }
	}
	function calculateLumaValuesForWindow(image, x2, y2, width, height) {
	  const pointArray = image.getPointArray();
	  const lumaValues = [];
	  let counter = 0;
	  for (let j = y2; j < y2 + height; j++) {
	    const offset = j * image.getWidth();
	    for (let i = x2; i < x2 + width; i++) {
	      const point = pointArray[offset + i];
	      lumaValues[counter] = point.r * 0.2126 /* RED */ + point.g * 0.7152 /* GREEN */ + point.b * 0.0722 /* BLUE */;
	      counter++;
	    }
	  }
	  return lumaValues;
	}
	function calculateAverageLuma(lumaValues) {
	  let sumLuma = 0;
	  for (const luma of lumaValues) {
	    sumLuma += luma;
	  }
	  return sumLuma / lumaValues.length;
	}

	// src/basicAPI.ts
	var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? void 0 : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
	function buildPaletteSync(images, {
	  colorDistanceFormula,
	  paletteQuantization,
	  colors
	} = {}) {
	  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
	  images.forEach((image) => paletteQuantizer.sample(image));
	  return paletteQuantizer.quantizeSync();
	}
	async function buildPalette(images, {
	  colorDistanceFormula,
	  paletteQuantization,
	  colors,
	  onProgress
	} = {}) {
	  return new Promise((resolve, reject) => {
	    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
	    images.forEach((image) => paletteQuantizer.sample(image));
	    let palette;
	    const iterator = paletteQuantizer.quantize();
	    const next = () => {
	      try {
	        const result = iterator.next();
	        if (result.done) {
	          resolve(palette);
	        } else {
	          if (result.value.palette)
	            palette = result.value.palette;
	          if (onProgress)
	            onProgress(result.value.progress);
	          setImmediateImpl(next);
	        }
	      } catch (error) {
	        reject(error);
	      }
	    };
	    setImmediateImpl(next);
	  });
	}
	function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
	  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
	  return imageQuantizer.quantizeSync(image, palette);
	}
	async function applyPalette(image, palette, {
	  colorDistanceFormula,
	  imageQuantization,
	  onProgress
	} = {}) {
	  return new Promise((resolve, reject) => {
	    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
	    let outPointContainer;
	    const iterator = imageQuantizer.quantize(image, palette);
	    const next = () => {
	      try {
	        const result = iterator.next();
	        if (result.done) {
	          resolve(outPointContainer);
	        } else {
	          if (result.value.pointContainer) {
	            outPointContainer = result.value.pointContainer;
	          }
	          if (onProgress)
	            onProgress(result.value.progress);
	          setImmediateImpl(next);
	        }
	      } catch (error) {
	        reject(error);
	      }
	    };
	    setImmediateImpl(next);
	  });
	}
	function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
	  switch (colorDistanceFormula) {
	    case "cie94-graphic-arts":
	      return new CIE94GraphicArts();
	    case "cie94-textiles":
	      return new CIE94Textiles();
	    case "ciede2000":
	      return new CIEDE2000();
	    case "color-metric":
	      return new CMetric();
	    case "euclidean":
	      return new Euclidean();
	    case "euclidean-bt709":
	      return new EuclideanBT709();
	    case "euclidean-bt709-noalpha":
	      return new EuclideanBT709NoAlpha();
	    case "manhattan":
	      return new Manhattan();
	    case "manhattan-bt709":
	      return new ManhattanBT709();
	    case "manhattan-nommyde":
	      return new ManhattanNommyde();
	    case "pngquant":
	      return new PNGQuant();
	    default:
	      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
	  }
	}
	function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
	  switch (imageQuantization) {
	    case "nearest":
	      return new NearestColor(distanceCalculator);
	    case "riemersma":
	      return new ErrorDiffusionRiemersma(distanceCalculator);
	    case "floyd-steinberg":
	      return new ErrorDiffusionArray(distanceCalculator, 0 /* FloydSteinberg */);
	    case "false-floyd-steinberg":
	      return new ErrorDiffusionArray(distanceCalculator, 1 /* FalseFloydSteinberg */);
	    case "stucki":
	      return new ErrorDiffusionArray(distanceCalculator, 2 /* Stucki */);
	    case "atkinson":
	      return new ErrorDiffusionArray(distanceCalculator, 3 /* Atkinson */);
	    case "jarvis":
	      return new ErrorDiffusionArray(distanceCalculator, 4 /* Jarvis */);
	    case "burkes":
	      return new ErrorDiffusionArray(distanceCalculator, 5 /* Burkes */);
	    case "sierra":
	      return new ErrorDiffusionArray(distanceCalculator, 6 /* Sierra */);
	    case "two-sierra":
	      return new ErrorDiffusionArray(distanceCalculator, 7 /* TwoSierra */);
	    case "sierra-lite":
	      return new ErrorDiffusionArray(distanceCalculator, 8 /* SierraLite */);
	    default:
	      throw new Error(`Unknown imageQuantization ${imageQuantization}`);
	  }
	}
	function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
	  switch (paletteQuantization) {
	    case "neuquant":
	      return new NeuQuant(distanceCalculator, colors);
	    case "rgbquant":
	      return new RGBQuant(distanceCalculator, colors);
	    case "wuquant":
	      return new WuQuant(distanceCalculator, colors);
	    case "neuquant-float":
	      return new NeuQuantFloat(distanceCalculator, colors);
	    default:
	      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
	  }
	}
	imageQ = __toCommonJS(src_exports);
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * cie94.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ciede2000.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * cmetric.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * common.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * constants.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * euclidean.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * helper.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * hueStatistics.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * lab2rgb.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * lab2xyz.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * manhattanNeuQuant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * nearestColor.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * palette.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * pngQuant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * point.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * pointContainer.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2hsl.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2lab.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2xyz.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ssim.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * wuQuant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * xyz2lab.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * xyz2rgb.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * MIT License
	 *
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 *
	 * riemersma.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve TypeScript port:
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * colorHistogram.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve TypeScript port:
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * neuquant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve TypeScript port:
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgbquant.ts - part of Image Quantization Library
	 */
	
	return imageQ;
}

var gifframe = {};

var hasRequiredGifframe;

function requireGifframe () {
	if (hasRequiredGifframe) return gifframe;
	hasRequiredGifframe = 1;

	const BitmapImage = requireBitmapimage();
	const { GifError } = requireGif();

	/** @class GifFrame */

	class GifFrame extends BitmapImage {

	    // xOffset - x offset of bitmap on GIF (defaults to 0)
	    // yOffset - y offset of bitmap on GIF (defaults to 0)
	    // disposalMethod - pixel disposal method when handling partial images
	    // delayCentisecs - duration of frame in hundredths of a second
	    // interlaced - whether the image is interlaced (defaults to false)

	    /**
	     * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
	     * 
	     * Property | Description
	     * --- | ---
	     * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
	     * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
	     * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
	     * delayCentisecs | duration of the frame in hundreths of a second
	     * interlaced | boolean indicating whether the frame renders interlaced
	     * 
	     * Its constructor supports the following signatures:
	     * 
	     * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
	     * * new GifFrame(bitmapImage: BitmapImage, options?)
	     * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
	     * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
	     * * new GifFrame(frame: GifFrame)
	     * 
	     * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
	     * 
	     * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
	     */

	    constructor(...args) {
	        super(...args);
	        if (args[0] instanceof GifFrame) {
	            // copy a provided GifFrame
	            const source = args[0];
	            this.xOffset = source.xOffset;
	            this.yOffset = source.yOffset;
	            this.disposalMethod = source.disposalMethod;
	            this.delayCentisecs = source.delayCentisecs;
	            this.interlaced = source.interlaced;
	        }
	        else {
	            const lastArg = args[args.length - 1];
	            let options = {};
	            if (typeof lastArg === 'object' && !(lastArg instanceof BitmapImage)) {
	                options = lastArg;
	            }
	            this.xOffset = options.xOffset || 0;
	            this.yOffset = options.yOffset || 0;
	            this.disposalMethod = (options.disposalMethod !== undefined ?
	                    options.disposalMethod : GifFrame.DisposeToBackgroundColor);
	            this.delayCentisecs = options.delayCentisecs || 8;
	            this.interlaced = options.interlaced || false;
	        }
	    }

	    /**
	     * Get a summary of the colors found within the frame. The return value is an object of the following form:
	     * 
	     * Property | Description
	     * --- | ---
	     * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
	     * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
	     * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
	     * 
	     * @return {object} An object representing a color palette as described above.
	     */

	    getPalette() {
	        // returns with colors sorted low to high
	        const colorSet = new Set();
	        const buf = this.bitmap.data;
	        let i = 0;
	        let usesTransparency = false;
	        while (i < buf.length) {
	            if (buf[i + 3] === 0) {
	                usesTransparency = true;
	            }
	            else {
	                // can eliminate the bitshift by starting one byte prior
	                const color = (buf.readUInt32BE(i, true) >> 8) & 0xFFFFFF;
	                colorSet.add(color);
	            }
	            i += 4; // skip alpha
	        }
	        const colors = new Array(colorSet.size);
	        const iter = colorSet.values();
	        for (i = 0; i < colors.length; ++i) {
	            colors[i] = iter.next().value;
	        }
	        colors.sort((a, b) => (a - b));
	        let indexCount = colors.length;
	        if (usesTransparency) {
	            ++indexCount;
	        }
	        return { colors, usesTransparency, indexCount };
	    }
	}

	GifFrame.DisposeToAnything = 0;
	GifFrame.DisposeNothing = 1;
	GifFrame.DisposeToBackgroundColor = 2;
	GifFrame.DisposeToPrevious = 3;

	gifframe.GifFrame = GifFrame;
	return gifframe;
}

var hasRequiredGifutil;

function requireGifutil () {
	if (hasRequiredGifutil) return gifutil;
	hasRequiredGifutil = 1;
	(function (exports$1) {

		/** @namespace GifUtil */

		const fs$1 = fs;
		const ImageQ = requireImageQ();

		const BitmapImage = requireBitmapimage();
		const { GifFrame } = requireGifframe();
		const { GifError } = requireGif();
		const { GifCodec } = requireGifcodec();

		const INVALID_SUFFIXES = ['.jpg', '.jpeg', '.png', '.bmp'];

		const defaultCodec = new GifCodec();

		/**
		 * cloneFrames() clones provided frames. It's a utility method for cloning an entire array of frames at once.
		 * 
		 * @function cloneFrames
		 * @memberof GifUtil
		 * @param {GifFrame[]} frames An array of GifFrame instances to clone
		 * @return {GifFrame[]} An array of GifFrame clones of the provided frames.
		 */

		exports$1.cloneFrames = function (frames) {
		    let clones = [];
		    frames.forEach(frame => {

		        clones.push(new GifFrame(frame));
		    });
		    return clones;
		};

		/**
		 * getColorInfo() gets information about the colors used in the provided frames. The method is able to return an array of all colors found across all frames.
		 * 
		 * `maxGlobalIndex` controls whether the computation short-circuits to avoid doing work that the caller doesn't need. The method only returns `colors` and `indexCount` for the colors across all frames when the number of indexes required to store the colors and transparency in a GIF (which is the value of `indexCount`) is less than or equal to `maxGlobalIndex`. Such short-circuiting is useful when the caller just needs to determine whether any frame includes transparency.
		 * 
		 * @function getColorInfo
		 * @memberof GifUtil
		 * @param {GifFrame[]} frames Frames to examine for color and transparency.
		 * @param {number} maxGlobalIndex Maximum number of color indexes (including one for transparency) allowed among the returned compilation of colors. `colors` and `indexCount` are not returned if the number of color indexes required to accommodate  all frames exceeds this number. Returns `colors` and `indexCount` by default.
		 * @returns {object} Object containing at least `palettes` and `usesTransparency`. `palettes` is an array of all the palettes returned by GifFrame#getPalette(). `usesTransparency` indicates whether at least one frame uses transparency. If `maxGlobalIndex` is not exceeded, the object also contains `colors`, an array of all colors (RGB) found across all palettes, sorted by increasing value, and `indexCount` indicating the number of indexes required to store the colors and the transparency in a GIF.
		 * @throws {GifError} When any frame requires more than 256 color indexes.
		 */

		exports$1.getColorInfo = function (frames, maxGlobalIndex) {
		    let usesTransparency = false;
		    const palettes = [];
		    for (let i = 0; i < frames.length; ++i) {
		        let palette = frames[i].getPalette();
		        if (palette.usesTransparency) {
		            usesTransparency = true;
		        }
		        if (palette.indexCount > 256) {
		            throw new GifError(`Frame ${i} uses more than 256 color indexes`);
		        }
		        palettes.push(palette);
		    }
		    if (maxGlobalIndex === 0) {
		        return { usesTransparency, palettes };
		    }

		    const globalColorSet = new Set();
		    palettes.forEach(palette => {

		        palette.colors.forEach(color => {

		            globalColorSet.add(color);
		        });
		    });
		    let indexCount = globalColorSet.size;
		    if (usesTransparency) {
		        // odd that GIF requires a color table entry at transparent index
		        ++indexCount;
		    }
		    if (maxGlobalIndex && indexCount > maxGlobalIndex) {
		        return { usesTransparency, palettes };
		    }
		    
		    const colors = new Array(globalColorSet.size);
		    const iter = globalColorSet.values();
		    for (let i = 0; i < colors.length; ++i) {
		        colors[i] = iter.next().value;
		    }
		    colors.sort((a, b) => (a - b));
		    return { colors, indexCount, usesTransparency, palettes };
		};

		/**
		 * copyAsJimp() returns a Jimp that contains a copy of the provided bitmap image (which may be either a BitmapImage or a GifFrame). Modifying the Jimp does not affect the provided bitmap image. This method serves as a macro for simplifying working with Jimp.
		 *
		 * @function copyAsJimp
		 * @memberof GifUtil
		 * @param {object} Reference to the Jimp package, keeping this library from being dependent on Jimp.
		 * @param {bitmapImageToCopy} Instance of BitmapImage (may be a GifUtil) with which to source the Jimp.
		 * @return {object} An new instance of Jimp containing a copy of the image in bitmapImageToCopy.
		 */
		 
		exports$1.copyAsJimp = function (jimp, bitmapImageToCopy) {
		    return exports$1.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
		};

		/**
		 * getMaxDimensions() returns the pixel width and height required to accommodate all of the provided frames, according to the offsets and dimensions of each frame.
		 * 
		 * @function getMaxDimensions
		 * @memberof GifUtil
		 * @param {GifFrame[]} frames Frames to measure for their aggregate maximum dimensions.
		 * @return {object} An object of the form {maxWidth, maxHeight} indicating the maximum width and height required to accommodate all frames.
		 */

		exports$1.getMaxDimensions = function (frames) {
		    let maxWidth = 0, maxHeight = 0;
		    frames.forEach(frame => {
		        const width = frame.xOffset + frame.bitmap.width;
		        if (width > maxWidth) {
		            maxWidth = width;
		        }
		        const height = frame.yOffset + frame.bitmap.height;
		        if (height > maxHeight) {
		            maxHeight = height;
		        }
		    });
		    return { maxWidth, maxHeight };
		};

		/**
		 * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Anthony Dekker.
		 * 
		 * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.
		 * 
		 * The method may increase the number of colors if there are fewer than the provided maximum.
		 * 
		 * @function quantizeDekker
		 * @memberof GifUtil
		 * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.
		 * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.
		 * @param {object} dither (optional) An object configuring the dithering to apply. The properties are as followings, imported from the [`image-q` package](https://github.com/ibezkrovnyi/image-quantization) without explanation: { `ditherAlgorithm`: One of 'FloydSteinberg', 'FalseFloydSteinberg', 'Stucki', 'Atkinson', 'Jarvis', 'Burkes', 'Sierra', 'TwoSierra', 'SierraLite'; `minimumColorDistanceToDither`: (optional) A number defaulting to 0; `serpentine`: (optional) A boolean defaulting to true; `calculateErrorLikeGIMP`: (optional) A boolean defaulting to false. }
		 */

		exports$1.quantizeDekker = function (imageOrImages, maxColorIndexes, dither) {
		    maxColorIndexes = maxColorIndexes || 256;
		    _quantize(imageOrImages, 'NeuQuantFloat', maxColorIndexes, 0, dither);
		};

		/**
		 * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Leon Sorokin. This quantization method differs from the other two by likely never increasing the number of colors, should there be fewer than the provided maximum.
		 * 
		 * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.
		 * 
		 * @function quantizeSorokin
		 * @memberof GifUtil
		 * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.
		 * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.
		 * @param {string} histogram (optional) Histogram method: 'top-pop' for global top-population, 'min-pop' for minimum-population threshhold within subregions. Defaults to 'min-pop'.
		 * @param {object} dither (optional) An object configuring the dithering to apply, as explained for `quantizeDekker()`.
		 */

		exports$1.quantizeSorokin = function (imageOrImages, maxColorIndexes, histogram, dither) {
		    maxColorIndexes = maxColorIndexes || 256;
		    histogram = histogram || 'min-pop';
		    let histogramID;
		    switch (histogram) {
		        case 'min-pop':
		        histogramID = 2;
		        break;

		        case 'top-pop':
		        histogramID = 1;
		        break

		        default:
		        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
		    }
		    _quantize(imageOrImages, 'RGBQuant', maxColorIndexes, histogramID, dither);
		};

		/**
		 * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Xiaolin Wu.
		 * 
		 * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.
		 * 
		 * The method may increase the number of colors if there are fewer than the provided maximum.
		 * 
		 * @function quantizeWu
		 * @memberof GifUtil
		 * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.
		 * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.
		 * @param {number} significantBits (optional) This is the number of significant high bits in each RGB color channel. Takes integer values from 1 through 8. Higher values correspond to higher quality. Defaults to 5.
		 * @param {object} dither (optional) An object configuring the dithering to apply, as explained for `quantizeDekker()`.
		 */

		exports$1.quantizeWu = function (imageOrImages, maxColorIndexes, significantBits, dither) {
		    maxColorIndexes = maxColorIndexes || 256;
		    significantBits = significantBits || 5;
		    if (significantBits < 1 || significantBits > 8) {
		        throw new Error("Invalid quantization quality");
		    }
		    _quantize(imageOrImages, 'WuQuant', maxColorIndexes, significantBits, dither);
		};

		/**
		 * read() decodes an encoded GIF, whether provided as a filename or as a byte buffer.
		 * 
		 * @function read
		 * @memberof GifUtil
		 * @param {string|Buffer} source Source to decode. When a string, it's the GIF filename to load and parse. When a Buffer, it's an encoded GIF to parse.
		 * @param {object} decoder An optional GIF decoder object implementing the `decode` method of class GifCodec. When provided, the method decodes the GIF using this decoder. When not provided, the method uses GifCodec.
		 * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the decoded GIF.
		 */

		exports$1.read = function (source, decoder) {
		    decoder = decoder || defaultCodec;
		    if (Buffer.isBuffer(source)) {
		        return decoder.decodeGif(source);
		    }
		    return _readBinary(source)
		    .then(buffer => {

		        return decoder.decodeGif(buffer);
		    });
		};

		/**
		 * shareAsJimp() returns a Jimp that shares a bitmap with the provided bitmap image (which may be either a BitmapImage or a GifFrame). Modifying the image in either the Jimp or the BitmapImage affects the other objects. This method serves as a macro for simplifying working with Jimp.
		 *
		 * @function shareAsJimp
		 * @memberof GifUtil
		 * @param {object} Reference to the Jimp package, keeping this library from being dependent on Jimp.
		 * @param {bitmapImageToShare} Instance of BitmapImage (may be a GifUtil) with which to source the Jimp.
		 * @return {object} An new instance of Jimp that shares the image in bitmapImageToShare.
		 */
		 
		exports$1.shareAsJimp = function (jimp, bitmapImageToShare) {
		    const jimpImage = new jimp(bitmapImageToShare.bitmap.width,
		            bitmapImageToShare.bitmap.height, 0);
		    jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
		    return jimpImage;
		};

		/**
		 * write() encodes a GIF and saves it as a file.
		 * 
		 * @function write
		 * @memberof GifUtil
		 * @param {string} path Filename to write GIF out as. Will overwrite an existing file.
		 * @param {GifFrame[]} frames Array of frames to be written into GIF.
		 * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.
		 * @param {object} encoder An optional GIF encoder object implementing the `encode` method of class GifCodec. When provided, the method encodes the GIF using this encoder. When not provided, the method uses GifCodec.
		 * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
		 */

		exports$1.write = function (path, frames, spec, encoder) {
		    encoder = encoder || defaultCodec;
		    const matches = path.match(/\.[a-zA-Z]+$/); // prevent accidents
		    if (matches !== null &&
		            INVALID_SUFFIXES.includes(matches[0].toLowerCase()))
		    {
		        throw new Error(`GIF '${path}' has an unexpected suffix`);
		    }

		    return encoder.encodeGif(frames, spec)
		    .then(gif => {

		        return _writeBinary(path, gif.buffer)
		        .then(() => {

		            return gif;
		        });
		    });
		};

		function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
		    const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
		    const ditherAlgs = [
		        'FloydSteinberg',
		        'FalseFloydSteinberg',
		        'Stucki',
		        'Atkinson',
		        'Jarvis',
		        'Burkes',
		        'Sierra',
		        'TwoSierra',
		        'SierraLite'
		    ];

		    if (dither) {
		        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
		            throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
		        }
		        if (dither.serpentine === undefined) {
		            dither.serpentine = true;
		        }
		        if (dither.minimumColorDistanceToDither === undefined) {
		            dither.minimumColorDistanceToDither = 0;
		        }
		        if (dither.calculateErrorLikeGIMP === undefined) {
		            dither.calculateErrorLikeGIMP = false;
		        }
		    }

		    const distCalculator = new ImageQ.distance.Euclidean();
		    const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
		    let imageMaker;
		    if (dither) {
		        imageMaker = new ImageQ.image.ErrorDiffusionArray(
		            distCalculator,
		            ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm],
		            dither.serpentine,
		            dither.minimumColorDistanceToDither,
		            dither.calculateErrorLikeGIMP
		        );
		    }
		    else {
		        imageMaker = new ImageQ.image.NearestColor(distCalculator);
		    }

		    const inputContainers = [];
		    images.forEach(image => {

		        const imageBuf = image.bitmap.data;
		        const inputBuf = new ArrayBuffer(imageBuf.length);
		        const inputArray = new Uint32Array(inputBuf);
		        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
		            inputArray[ai] = imageBuf.readUInt32LE(bi, true);
		        }
		        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(
		                inputArray, image.bitmap.width, image.bitmap.height);
		        quantizer.sample(inputContainer);
		        inputContainers.push(inputContainer);
		    });
		    
		    const limitedPalette = quantizer.quantizeSync();

		    for (let i = 0; i < images.length; ++i) {
		        const imageBuf = images[i].bitmap.data;
		        const outputContainer = imageMaker.quantizeSync(inputContainers[i], limitedPalette);
		        const outputArray = outputContainer.toUint32Array();
		        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
		            imageBuf.writeUInt32LE(outputArray[ai], bi);
		        }
		    }
		}

		function _readBinary(path) {
		    // TBD: add support for URLs
		    return new Promise((resolve, reject) => {

		        fs$1.readFile(path, (err, buffer) => {

		            if (err) {
		                return reject(err);
		            }
		            return resolve(buffer);
		        });
		    });
		}

		function _writeBinary(path, buffer) {
		    // TBD: add support for URLs
		    return new Promise((resolve, reject) => {

		        fs$1.writeFile(path, buffer, err => {
		            
		            if (err) {
		                return reject(err);
		            }
		            return resolve();
		        });
		    });
		} 
	} (gifutil));
	return gifutil;
}

var hasRequiredGifcodec;

function requireGifcodec () {
	if (hasRequiredGifcodec) return gifcodec;
	hasRequiredGifcodec = 1;

	const Omggif = requireOmggif();
	const { Gif, GifError } = requireGif();

	// allow circular dependency with GifUtil
	function GifUtil() {
	    const data = requireGifutil();

	    GifUtil = function () {
	      return data;
	    };

	  return data;
	}

	const { GifFrame } = requireGifframe();

	const PER_GIF_OVERHEAD = 200; // these are guesses at upper limits
	const PER_FRAME_OVERHEAD = 100;

	// Note: I experimented with accepting a global color table when encoding and returning the global color table when decoding. Doing this properly greatly increased the complexity of the code and the amount of clock cycles required. The main issue is that each frame can specify any color of the global color table to be transparent within the frame, while this GIF library strives to hide GIF formatting details from its clients. E.g. it's possible to have 256 colors in the global color table and different transparencies in each frame, requiring clients to either provide per-frame transparency indexes, or for arcane reasons that won't be apparent to client developers, encode some GIFs with local color tables that previously decoded with global tables.

	/** @class GifCodec */

	class GifCodec
	{
	    // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest

	    /**
	     * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
	     * 
	     * Instances of this class are stateless and can be shared across multiple encodings and decodings.
	     * 
	     * Its constructor takes one option argument:
	     * 
	     * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
	     */

	    constructor(options = {}) {
	        this._transparentRGB = null; // 0x000000
	        if (typeof options.transparentRGB === 'number' &&
	                options.transparentRGB !== 0)
	        {
	            this._transparentRGBA = options.transparentRGB * 256;
	        }
	        this._testInitialBufferSize = 0; // assume no buffer scaling test
	    }

	    /**
	     * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
	     * 
	     * @param {Buffer} buffer Bytes of an encoded GIF to decode.
	     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
	     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
	     */

	    decodeGif(buffer) {
	        try {
	            let reader;
	            try {
	                reader = new Omggif.GifReader(buffer);
	            }
	            catch (err) {
	                throw new GifError(err);
	            }
	            const frameCount = reader.numFrames();
	            const frames = [];
	            const spec = {
	                width: reader.width,
	                height: reader.height,
	                loops: reader.loopCount()
	            };

	            spec.usesTransparency = false;
	            for (let i = 0; i < frameCount; ++i) {
	                const frameInfo =
	                        this._decodeFrame(reader, i, spec.usesTransparency);
	                frames.push(frameInfo.frame);
	                if (frameInfo.usesTransparency) {
	                    spec.usesTransparency = true;
	                }
	            }
	            return Promise.resolve(new Gif(buffer, frames, spec));
	        }
	        catch (err) {
	            return Promise.reject(err);
	        }
	    }

	    /**
	     * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
	     * 
	     * @param {GifFrame[]} frames Array of frames to encode
	     * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely. Set `loop` to null to disable looping, playing only once. `colorScope` defaults to Gif.GlobalColorsPreferred.
	     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
	     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
	     */

	    encodeGif(frames, spec = {}) {
	        try {
	            if (frames === null || frames.length === 0) {
	                throw new GifError("there are no frames");
	            }
	            const dims = GifUtil().getMaxDimensions(frames);

	            spec = Object.assign({}, spec); // don't munge caller's spec
	            spec.width = dims.maxWidth;
	            spec.height = dims.maxHeight;
	            if (spec.loops === undefined) {
	                spec.loops = 0;
	            }
	            spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;

	            return Promise.resolve(this._encodeGif(frames, spec));
	        }
	        catch (err) {
	            return Promise.reject(err);
	        }
	    }

	    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
	        let info, buffer;
	        try {
	            info = reader.frameInfo(frameIndex);
	            buffer = new Buffer(reader.width * reader.height * 4);
	            reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
	            if (info.width !== reader.width || info.height !== reader.height) {
	                if (info.y) {
	                    // skip unused rows
	                    buffer = buffer.slice(info.y * reader.width * 4);
	                }
	                if (reader.width > info.width) {
	                    // skip scanstride
	                    for (let ii = 0; ii < info.height; ++ii) {
	                        buffer.copy(buffer, ii * info.width * 4,
	                            (info.x + ii * reader.width) * 4,
	                            (info.x + ii * reader.width) * 4 + info.width * 4);
	                    }
	                }
	                // trim buffer to size
	                buffer = buffer.slice(0, info.width * info.height * 4);
	            }
	        }
	        catch (err) {
	            throw new GifError(err);
	        }

	        let usesTransparency = false;
	        if (this._transparentRGBA === null) {
	            if (!alreadyUsedTransparency) {
	                for (let i = 3; i < buffer.length; i += 4) {
	                    if (buffer[i] === 0) {
	                        usesTransparency = true;
	                        i = buffer.length;
	                    }
	                }
	            }
	        }
	        else {
	            for (let i = 3; i < buffer.length; i += 4) {
	                if (buffer[i] === 0) {
	                    buffer.writeUInt32BE(this._transparentRGBA, i - 3);
	                    usesTransparency = true; // GIF might encode unused index
	                }
	            }
	        }

	        const frame = new GifFrame(info.width, info.height, buffer, {
	            xOffset: info.x,
	            yOffset: info.y,
	            disposalMethod: info.disposal,
	            interlaced: info.interlaced,
	            delayCentisecs: info.delay
	        });
	        return { frame, usesTransparency };
	    }

	    _encodeGif(frames, spec) {
	        let colorInfo;
	        if (spec.colorScope === Gif.LocalColorsOnly) {
	            colorInfo = GifUtil().getColorInfo(frames, 0);
	        }
	        else {
	            colorInfo = GifUtil().getColorInfo(frames, 256);
	            if (!colorInfo.colors) { // if global palette impossible
	                if (spec.colorScope === Gif.GlobalColorsOnly) {
	                    throw new GifError(
	                            "Too many color indexes for global color table");
	                }
	                spec.colorScope = Gif.LocalColorsOnly;
	            }
	        }
	        spec.usesTransparency = colorInfo.usesTransparency;

	        const localPalettes = colorInfo.palettes;
	        if (spec.colorScope === Gif.LocalColorsOnly) {
	            const localSizeEst = 2000; //this._getSizeEstimateLocal(localPalettes, frames);
	            return _encodeLocal(frames, spec, localSizeEst, localPalettes);
	        }

	        const globalSizeEst = 2000; //this._getSizeEstimateGlobal(colorInfo, frames);
	        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
	    }

	    _getSizeEstimateGlobal(globalPalette, frames) {
	        if (this._testInitialBufferSize > 0) {
	            return this._testInitialBufferSize;
	        }
	        let sizeEst = PER_GIF_OVERHEAD + 3*256 /* max palette size*/;
	        const pixelBitWidth = _getPixelBitWidth(globalPalette);
	        frames.forEach(frame => {
	            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
	        });
	        return sizeEst; // should be the upper limit
	    }

	    _getSizeEstimateLocal(palettes, frames) {
	        if (this._testInitialBufferSize > 0) {
	            return this._testInitialBufferSize;
	        }
	        let sizeEst = PER_GIF_OVERHEAD;
	        for (let i = 0; i < frames.length; ++i ) {
	            const palette = palettes[i];
	            const pixelBitWidth = _getPixelBitWidth(palette);
	            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
	        }
	        return sizeEst; // should be the upper limit
	    }
	}
	gifcodec.GifCodec = GifCodec;

	function _colorLookupLinear(colors, color) {
	    const index = colors.indexOf(color);
	    return (index === -1 ? null : index);
	}

	function _colorLookupBinary(colors, color) {
	    // adapted from https://stackoverflow.com/a/10264318/650894
	    var lo = 0, hi = colors.length - 1, mid;
	    while (lo <= hi) {
	        mid = Math.floor((lo + hi)/2);
	        if (colors[mid] > color)
	            hi = mid - 1;
	        else if (colors[mid] < color)
	            lo = mid + 1;
	        else
	            return mid;
	    }
	    return null;
	}

	function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
	    // would be inefficient for frames to lookup colors in extended palette 
	    const extendedGlobalPalette = {
	        colors: globalPalette.colors.slice(),
	        usesTransparency: globalPalette.usesTransparency
	    };
	    _extendPaletteToPowerOf2(extendedGlobalPalette);
	    const options = {
	        palette: extendedGlobalPalette.colors,
	        loop: spec.loops
	    };
	    let buffer = new Buffer(bufferSizeEst);
	    let gifWriter;
	    try {
	        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,
	                            options);
	    }
	    catch (err) {
	        throw new GifError(err);
	    }
	    for (let i = 0; i < frames.length; ++i) {
	        buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
	    }
	    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
	}

	function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
	    const options = {
	        loop: spec.loops
	    };
	    let buffer = new Buffer(bufferSizeEst);
	    let gifWriter;
	    try {
	        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,
	                            options);
	    }                            
	    catch (err) {
	        throw new GifError(err);
	    }
	    for (let i = 0; i < frames.length; ++i) {
	        buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
	    }
	    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
	}

	function _extendPaletteToPowerOf2(palette) {
	    const colors = palette.colors;
	    if (palette.usesTransparency) {
	        colors.push(0);
	    }
	    const colorCount = colors.length;
	    let powerOf2 = 2;
	    while (colorCount > powerOf2) {
	        powerOf2 <<= 1;
	    }
	    colors.length = powerOf2;
	    colors.fill(0, colorCount);
	}

	function _getFrameSizeEst(frame, pixelBitWidth) {
	    let byteLength = frame.bitmap.width * frame.bitmap.height;
	    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
	    byteLength += Math.ceil(byteLength / 255); // add block size bytes
	    // assume maximum palete size because it might get extended for power of 2
	    return (PER_FRAME_OVERHEAD + byteLength + 3 * 256 /* largest palette */);
	}

	function _getIndexedImage(frameIndex, frame, palette) {
	    const colors = palette.colors;
	    const colorToIndexFunc = (colors.length <= 8 ? // guess at the break-even
	            _colorLookupLinear : _colorLookupBinary);
	    const colorBuffer = frame.bitmap.data;
	    const indexBuffer = new Buffer(colorBuffer.length/4);
	    let transparentIndex = colors.length;
	    let i = 0, j = 0;

	    while (i < colorBuffer.length) {
	        if (colorBuffer[i + 3] !== 0) {
	            const color = (colorBuffer.readUInt32BE(i, true) >> 8) & 0xFFFFFF;
	            // caller guarantees that the color will be in the palette
	            indexBuffer[j] = colorToIndexFunc(colors, color);
	        }
	        else {
	            indexBuffer[j] = transparentIndex;
	        }
	        i += 4; // skip alpha
	        ++j;
	    }

	    if (palette.usesTransparency) {
	        if (transparentIndex === 256) {
	            throw new GifError(`Frame ${frameIndex} already has 256 colors` +
	                    `and so can't use transparency`);
	        }
	    }
	    else {
	        transparentIndex = null;
	    }

	    return { buffer: indexBuffer, transparentIndex };
	}

	function _getPixelBitWidth(palette) {
	    let indexCount = palette.indexCount;
	    let pixelBitWidth = 0;
	    --indexCount; // start at maximum index
	    while (indexCount) {
	        ++pixelBitWidth;
	        indexCount >>= 1;
	    }
	    return (pixelBitWidth > 0 ? pixelBitWidth : 1);
	}

	function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
	    if (frame.interlaced) {
	        throw new GifError("writing interlaced GIFs is not supported");
	    }
	    const frameInfo = _getIndexedImage(frameIndex, frame, palette);
	    const options = {
	        delay: frame.delayCentisecs,
	        disposal: frame.disposalMethod,
	        transparent: frameInfo.transparentIndex
	    };
	    if (isLocalPalette) {
	        _extendPaletteToPowerOf2(palette); // ok 'cause palette never used again
	        options.palette = palette.colors;
	    }
	    try {
	        let buffer = gifWriter.getOutputBuffer();
	        let startOfFrame = gifWriter.getOutputBufferPosition();
	        let endOfFrame;
	        let tryAgain = true;

	        while (tryAgain) {
	            endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset,
	                    frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);
	            tryAgain = false;
	            if (endOfFrame >= buffer.length - 1) {
	                const biggerBuffer = new Buffer(buffer.length * 1.5);
	                buffer.copy(biggerBuffer);
	                gifWriter.setOutputBuffer(biggerBuffer);
	                gifWriter.setOutputBufferPosition(startOfFrame);
	                buffer = biggerBuffer;
	                tryAgain = true;
	            }
	        }
	        return buffer;
	    }
	    catch (err) {
	        throw new GifError(err);
	    }
	}
	return gifcodec;
}

var src;
var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;

	const BitmapImage = requireBitmapimage();
	const { Gif, GifError } = requireGif();
	const { GifCodec } = requireGifcodec();
	const { GifFrame } = requireGifframe();
	const GifUtil = requireGifutil();

	src = {
	    BitmapImage,
	    Gif,
	    GifCodec,
	    GifFrame,
	    GifUtil,
	    GifError
	};
	return src;
}

var srcExports = requireSrc();

function gif() {
    return {
        mime: "image/gif",
        encode: async (bitmap) => {
            const gif = new srcExports.BitmapImage(bitmap);
            srcExports.GifUtil.quantizeDekker(gif, 256);
            const newFrame = new srcExports.GifFrame(bitmap);
            const gifCodec = new srcExports.GifCodec();
            const newGif = await gifCodec.encodeGif([newFrame], {});
            return newGif.buffer;
        },
        decode: (data) => {
            const gifObj = new GIF.GifReader(data);
            const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
            gifObj.decodeAndBlitFrameRGBA(0, gifData);
            return {
                data: gifData,
                width: gifObj.width,
                height: gifObj.height,
            };
        },
    };
}

var encoder = {exports: {}};

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder.exports;
	hasRequiredEncoder = 1;
	(function (module) {

		function JPEGEncoder(quality) {
			var ffloor = Math.floor;
			var YTable = new Array(64);
			var UVTable = new Array(64);
			var fdtbl_Y = new Array(64);
			var fdtbl_UV = new Array(64);
			var YDC_HT;
			var UVDC_HT;
			var YAC_HT;
			var UVAC_HT;
			
			var bitcode = new Array(65535);
			var category = new Array(65535);
			var outputfDCTQuant = new Array(64);
			var DU = new Array(64);
			var byteout = [];
			var bytenew = 0;
			var bytepos = 7;
			
			var YDU = new Array(64);
			var UDU = new Array(64);
			var VDU = new Array(64);
			var clt = new Array(256);
			var RGB_YUV_TABLE = new Array(2048);
			var currentQuality;
			
			var ZigZag = [
					 0, 1, 5, 6,14,15,27,28,
					 2, 4, 7,13,16,26,29,42,
					 3, 8,12,17,25,30,41,43,
					 9,11,18,24,31,40,44,53,
					10,19,23,32,39,45,52,54,
					20,22,33,38,46,51,55,60,
					21,34,37,47,50,56,59,61,
					35,36,48,49,57,58,62,63
				];
			
			var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
			var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
			var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
			var std_ac_luminance_values = [
					0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
					0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
					0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
					0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
					0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
					0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
					0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
					0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
					0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
					0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
					0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
					0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
					0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
					0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
					0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
					0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
					0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
					0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
					0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
					0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
					0xf9,0xfa
				];
			
			var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
			var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
			var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
			var std_ac_chrominance_values = [
					0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
					0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
					0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
					0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
					0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
					0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
					0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
					0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
					0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
					0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
					0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
					0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
					0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
					0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
					0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
					0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
					0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
					0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
					0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
					0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
					0xf9,0xfa
				];
			
			function initQuantTables(sf){
					var YQT = [
						16, 11, 10, 16, 24, 40, 51, 61,
						12, 12, 14, 19, 26, 58, 60, 55,
						14, 13, 16, 24, 40, 57, 69, 56,
						14, 17, 22, 29, 51, 87, 80, 62,
						18, 22, 37, 56, 68,109,103, 77,
						24, 35, 55, 64, 81,104,113, 92,
						49, 64, 78, 87,103,121,120,101,
						72, 92, 95, 98,112,100,103, 99
					];
					
					for (var i = 0; i < 64; i++) {
						var t = ffloor((YQT[i]*sf+50)/100);
						if (t < 1) {
							t = 1;
						} else if (t > 255) {
							t = 255;
						}
						YTable[ZigZag[i]] = t;
					}
					var UVQT = [
						17, 18, 24, 47, 99, 99, 99, 99,
						18, 21, 26, 66, 99, 99, 99, 99,
						24, 26, 56, 99, 99, 99, 99, 99,
						47, 66, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99
					];
					for (var j = 0; j < 64; j++) {
						var u = ffloor((UVQT[j]*sf+50)/100);
						if (u < 1) {
							u = 1;
						} else if (u > 255) {
							u = 255;
						}
						UVTable[ZigZag[j]] = u;
					}
					var aasf = [
						1.0, 1.387039845, 1.306562965, 1.175875602,
						1.0, 0.785694958, 0.541196100, 0.275899379
					];
					var k = 0;
					for (var row = 0; row < 8; row++)
					{
						for (var col = 0; col < 8; col++)
						{
							fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
							fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
							k++;
						}
					}
				}
				
				function computeHuffmanTbl(nrcodes, std_table){
					var codevalue = 0;
					var pos_in_table = 0;
					var HT = new Array();
					for (var k = 1; k <= 16; k++) {
						for (var j = 1; j <= nrcodes[k]; j++) {
							HT[std_table[pos_in_table]] = [];
							HT[std_table[pos_in_table]][0] = codevalue;
							HT[std_table[pos_in_table]][1] = k;
							pos_in_table++;
							codevalue++;
						}
						codevalue*=2;
					}
					return HT;
				}
				
				function initHuffmanTbl()
				{
					YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
					UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
					YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
					UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
				}
			
				function initCategoryNumber()
				{
					var nrlower = 1;
					var nrupper = 2;
					for (var cat = 1; cat <= 15; cat++) {
						//Positive numbers
						for (var nr = nrlower; nr<nrupper; nr++) {
							category[32767+nr] = cat;
							bitcode[32767+nr] = [];
							bitcode[32767+nr][1] = cat;
							bitcode[32767+nr][0] = nr;
						}
						//Negative numbers
						for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
							category[32767+nrneg] = cat;
							bitcode[32767+nrneg] = [];
							bitcode[32767+nrneg][1] = cat;
							bitcode[32767+nrneg][0] = nrupper-1+nrneg;
						}
						nrlower <<= 1;
						nrupper <<= 1;
					}
				}
				
				function initRGBYUVTable() {
					for(var i = 0; i < 256;i++) {
						RGB_YUV_TABLE[i]      		=  19595 * i;
						RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
						RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
						RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
						RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
						RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
						RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
						RGB_YUV_TABLE[(i+1792)>>0] 	= -5329 * i;
					}
				}
				
				// IO functions
				function writeBits(bs)
				{
					var value = bs[0];
					var posval = bs[1]-1;
					while ( posval >= 0 ) {
						if (value & (1 << posval) ) {
							bytenew |= (1 << bytepos);
						}
						posval--;
						bytepos--;
						if (bytepos < 0) {
							if (bytenew == 0xFF) {
								writeByte(0xFF);
								writeByte(0);
							}
							else {
								writeByte(bytenew);
							}
							bytepos=7;
							bytenew=0;
						}
					}
				}
			
				function writeByte(value)
				{
					//byteout.push(clt[value]); // write char directly instead of converting later
		      byteout.push(value);
				}
			
				function writeWord(value)
				{
					writeByte((value>>8)&0xFF);
					writeByte((value   )&0xFF);
				}
				
				// DCT & quantization core
				function fDCTQuant(data, fdtbl)
				{
					var d0, d1, d2, d3, d4, d5, d6, d7;
					/* Pass 1: process rows. */
					var dataOff=0;
					var i;
					var I8 = 8;
					var I64 = 64;
					for (i=0; i<I8; ++i)
					{
						d0 = data[dataOff];
						d1 = data[dataOff+1];
						d2 = data[dataOff+2];
						d3 = data[dataOff+3];
						d4 = data[dataOff+4];
						d5 = data[dataOff+5];
						d6 = data[dataOff+6];
						d7 = data[dataOff+7];
						
						var tmp0 = d0 + d7;
						var tmp7 = d0 - d7;
						var tmp1 = d1 + d6;
						var tmp6 = d1 - d6;
						var tmp2 = d2 + d5;
						var tmp5 = d2 - d5;
						var tmp3 = d3 + d4;
						var tmp4 = d3 - d4;
			
						/* Even part */
						var tmp10 = tmp0 + tmp3;	/* phase 2 */
						var tmp13 = tmp0 - tmp3;
						var tmp11 = tmp1 + tmp2;
						var tmp12 = tmp1 - tmp2;
			
						data[dataOff] = tmp10 + tmp11; /* phase 3 */
						data[dataOff+4] = tmp10 - tmp11;
			
						var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
						data[dataOff+2] = tmp13 + z1; /* phase 5 */
						data[dataOff+6] = tmp13 - z1;
			
						/* Odd part */
						tmp10 = tmp4 + tmp5; /* phase 2 */
						tmp11 = tmp5 + tmp6;
						tmp12 = tmp6 + tmp7;
			
						/* The rotator is modified from fig 4-8 to avoid extra negations. */
						var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
						var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
						var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
						var z3 = tmp11 * 0.707106781; /* c4 */
			
						var z11 = tmp7 + z3;	/* phase 5 */
						var z13 = tmp7 - z3;
			
						data[dataOff+5] = z13 + z2;	/* phase 6 */
						data[dataOff+3] = z13 - z2;
						data[dataOff+1] = z11 + z4;
						data[dataOff+7] = z11 - z4;
			
						dataOff += 8; /* advance pointer to next row */
					}
			
					/* Pass 2: process columns. */
					dataOff = 0;
					for (i=0; i<I8; ++i)
					{
						d0 = data[dataOff];
						d1 = data[dataOff + 8];
						d2 = data[dataOff + 16];
						d3 = data[dataOff + 24];
						d4 = data[dataOff + 32];
						d5 = data[dataOff + 40];
						d6 = data[dataOff + 48];
						d7 = data[dataOff + 56];
						
						var tmp0p2 = d0 + d7;
						var tmp7p2 = d0 - d7;
						var tmp1p2 = d1 + d6;
						var tmp6p2 = d1 - d6;
						var tmp2p2 = d2 + d5;
						var tmp5p2 = d2 - d5;
						var tmp3p2 = d3 + d4;
						var tmp4p2 = d3 - d4;
			
						/* Even part */
						var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
						var tmp13p2 = tmp0p2 - tmp3p2;
						var tmp11p2 = tmp1p2 + tmp2p2;
						var tmp12p2 = tmp1p2 - tmp2p2;
			
						data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
						data[dataOff+32] = tmp10p2 - tmp11p2;
			
						var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
						data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
						data[dataOff+48] = tmp13p2 - z1p2;
			
						/* Odd part */
						tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
						tmp11p2 = tmp5p2 + tmp6p2;
						tmp12p2 = tmp6p2 + tmp7p2;
			
						/* The rotator is modified from fig 4-8 to avoid extra negations. */
						var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
						var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
						var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
						var z3p2 = tmp11p2 * 0.707106781; /* c4 */
			
						var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
						var z13p2 = tmp7p2 - z3p2;
			
						data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
						data[dataOff+24] = z13p2 - z2p2;
						data[dataOff+ 8] = z11p2 + z4p2;
						data[dataOff+56] = z11p2 - z4p2;
			
						dataOff++; /* advance pointer to next column */
					}
			
					// Quantize/descale the coefficients
					var fDCTQuant;
					for (i=0; i<I64; ++i)
					{
						// Apply the quantization and scaling factor & Round to nearest integer
						fDCTQuant = data[i]*fdtbl[i];
						outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
						//outputfDCTQuant[i] = fround(fDCTQuant);

					}
					return outputfDCTQuant;
				}
				
				function writeAPP0()
				{
					writeWord(0xFFE0); // marker
					writeWord(16); // length
					writeByte(0x4A); // J
					writeByte(0x46); // F
					writeByte(0x49); // I
					writeByte(0x46); // F
					writeByte(0); // = "JFIF",'\0'
					writeByte(1); // versionhi
					writeByte(1); // versionlo
					writeByte(0); // xyunits
					writeWord(1); // xdensity
					writeWord(1); // ydensity
					writeByte(0); // thumbnwidth
					writeByte(0); // thumbnheight
				}

				function writeAPP1(exifBuffer) {
					if (!exifBuffer) return;

					writeWord(0xFFE1); // APP1 marker

					if (exifBuffer[0] === 0x45 &&
							exifBuffer[1] === 0x78 &&
							exifBuffer[2] === 0x69 &&
							exifBuffer[3] === 0x66) {
						// Buffer already starts with EXIF, just use it directly
						writeWord(exifBuffer.length + 2); // length is buffer + length itself!
					} else {
						// Buffer doesn't start with EXIF, write it for them
						writeWord(exifBuffer.length + 5 + 2); // length is buffer + EXIF\0 + length itself!
						writeByte(0x45); // E
						writeByte(0x78); // X
						writeByte(0x69); // I
						writeByte(0x66); // F
						writeByte(0); // = "EXIF",'\0'
					}

					for (var i = 0; i < exifBuffer.length; i++) {
						writeByte(exifBuffer[i]);
					}
				}

				function writeSOF0(width, height)
				{
					writeWord(0xFFC0); // marker
					writeWord(17);   // length, truecolor YUV JPG
					writeByte(8);    // precision
					writeWord(height);
					writeWord(width);
					writeByte(3);    // nrofcomponents
					writeByte(1);    // IdY
					writeByte(0x11); // HVY
					writeByte(0);    // QTY
					writeByte(2);    // IdU
					writeByte(0x11); // HVU
					writeByte(1);    // QTU
					writeByte(3);    // IdV
					writeByte(0x11); // HVV
					writeByte(1);    // QTV
				}
			
				function writeDQT()
				{
					writeWord(0xFFDB); // marker
					writeWord(132);	   // length
					writeByte(0);
					for (var i=0; i<64; i++) {
						writeByte(YTable[i]);
					}
					writeByte(1);
					for (var j=0; j<64; j++) {
						writeByte(UVTable[j]);
					}
				}
			
				function writeDHT()
				{
					writeWord(0xFFC4); // marker
					writeWord(0x01A2); // length
			
					writeByte(0); // HTYDCinfo
					for (var i=0; i<16; i++) {
						writeByte(std_dc_luminance_nrcodes[i+1]);
					}
					for (var j=0; j<=11; j++) {
						writeByte(std_dc_luminance_values[j]);
					}
			
					writeByte(0x10); // HTYACinfo
					for (var k=0; k<16; k++) {
						writeByte(std_ac_luminance_nrcodes[k+1]);
					}
					for (var l=0; l<=161; l++) {
						writeByte(std_ac_luminance_values[l]);
					}
			
					writeByte(1); // HTUDCinfo
					for (var m=0; m<16; m++) {
						writeByte(std_dc_chrominance_nrcodes[m+1]);
					}
					for (var n=0; n<=11; n++) {
						writeByte(std_dc_chrominance_values[n]);
					}
			
					writeByte(0x11); // HTUACinfo
					for (var o=0; o<16; o++) {
						writeByte(std_ac_chrominance_nrcodes[o+1]);
					}
					for (var p=0; p<=161; p++) {
						writeByte(std_ac_chrominance_values[p]);
					}
				}
				
				function writeCOM(comments)
				{
					if (typeof comments === "undefined" || comments.constructor !== Array) return;
					comments.forEach(e => {
						if (typeof e !== "string") return;
						writeWord(0xFFFE); // marker
						var l = e.length;
						writeWord(l + 2); // length itself as well
						var i;
						for (i = 0; i < l; i++)
							writeByte(e.charCodeAt(i));
					});
				}
			
				function writeSOS()
				{
					writeWord(0xFFDA); // marker
					writeWord(12); // length
					writeByte(3); // nrofcomponents
					writeByte(1); // IdY
					writeByte(0); // HTY
					writeByte(2); // IdU
					writeByte(0x11); // HTU
					writeByte(3); // IdV
					writeByte(0x11); // HTV
					writeByte(0); // Ss
					writeByte(0x3f); // Se
					writeByte(0); // Bf
				}
				
				function processDU(CDU, fdtbl, DC, HTDC, HTAC){
					var EOB = HTAC[0x00];
					var M16zeroes = HTAC[0xF0];
					var pos;
					var I16 = 16;
					var I63 = 63;
					var I64 = 64;
					var DU_DCT = fDCTQuant(CDU, fdtbl);
					//ZigZag reorder
					for (var j=0;j<I64;++j) {
						DU[ZigZag[j]]=DU_DCT[j];
					}
					var Diff = DU[0] - DC; DC = DU[0];
					//Encode DC
					if (Diff==0) {
						writeBits(HTDC[0]); // Diff might be 0
					} else {
						pos = 32767+Diff;
						writeBits(HTDC[category[pos]]);
						writeBits(bitcode[pos]);
					}
					//Encode ACs
					var end0pos = 63; // was const... which is crazy
					for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {}					//end0pos = first element in reverse order !=0
					if ( end0pos == 0) {
						writeBits(EOB);
						return DC;
					}
					var i = 1;
					var lng;
					while ( i <= end0pos ) {
						var startpos = i;
						for (; (DU[i]==0) && (i<=end0pos); ++i) {}
						var nrzeroes = i-startpos;
						if ( nrzeroes >= I16 ) {
							lng = nrzeroes>>4;
							for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
								writeBits(M16zeroes);
							nrzeroes = nrzeroes&0xF;
						}
						pos = 32767+DU[i];
						writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
						writeBits(bitcode[pos]);
						i++;
					}
					if ( end0pos != I63 ) {
						writeBits(EOB);
					}
					return DC;
				}

				function initCharLookupTable(){
					var sfcc = String.fromCharCode;
					for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
						clt[i] = sfcc(i);
					}
				}
				
				this.encode = function(image,quality) // image data object
				{
					new Date().getTime();
					
					if(quality) setQuality(quality);
					
					// Initialize bit writer
					byteout = new Array();
					bytenew=0;
					bytepos=7;
			
					// Add JPEG headers
					writeWord(0xFFD8); // SOI
					writeAPP0();
					writeCOM(image.comments);
					writeAPP1(image.exifBuffer);
					writeDQT();
					writeSOF0(image.width,image.height);
					writeDHT();
					writeSOS();

			
					// Encode 8x8 macroblocks
					var DCY=0;
					var DCU=0;
					var DCV=0;
					
					bytenew=0;
					bytepos=7;
					
					
					this.encode.displayName = "_encode_";

					var imageData = image.data;
					var width = image.width;
					var height = image.height;

					var quadWidth = width*4;
					
					var x, y = 0;
					var r, g, b;
					var start,p, col,row,pos;
					while(y < height){
						x = 0;
						while(x < quadWidth){
						start = quadWidth * y + x;
						p = start;
						col = -1;
						row = 0;
						
						for(pos=0; pos < 64; pos++){
							row = pos >> 3;// /8
							col = ( pos & 7 ) * 4; // %8
							p = start + ( row * quadWidth ) + col;		
							
							if(y+row >= height){ // padding bottom
								p-= (quadWidth*(y+1+row-height));
							}

							if(x+col >= quadWidth){ // padding right	
								p-= ((x+col) - quadWidth +4);
							}
							
							r = imageData[ p++ ];
							g = imageData[ p++ ];
							b = imageData[ p++ ];
							
							
							/* // calculate YUV values dynamically
							YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
							UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
							VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
							*/
							
							// use lookup table (slightly faster)
							YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
							UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
							VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

						}
						
						DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
						DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
						DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
						x+=32;
						}
						y+=8;
					}
					
					
					////////////////////////////////////////////////////////////////
			
					// Do the bit alignment of the EOI marker
					if ( bytepos >= 0 ) {
						var fillbits = [];
						fillbits[1] = bytepos+1;
						fillbits[0] = (1<<(bytepos+1))-1;
						writeBits(fillbits);
					}
			
					writeWord(0xFFD9); //EOI
		      return Buffer.from(byteout);
			};
			
			function setQuality(quality){
				if (quality <= 0) {
					quality = 1;
				}
				if (quality > 100) {
					quality = 100;
				}
				
				if(currentQuality == quality) return // don't recalc if unchanged
				
				var sf = 0;
				if (quality < 50) {
					sf = Math.floor(5000 / quality);
				} else {
					sf = Math.floor(200 - quality*2);
				}
				
				initQuantTables(sf);
				currentQuality = quality;
				//console.log('Quality set to: '+quality +'%');
			}
			
			function init(){
				var time_start = new Date().getTime();
				if(!quality) quality = 50;
				// Create tables
				initCharLookupTable();
				initHuffmanTbl();
				initCategoryNumber();
				initRGBYUVTable();
				
				setQuality(quality);
				new Date().getTime() - time_start;
		    	//console.log('Initialization '+ duration + 'ms');
			}
			
			init();
			
		}
		{
			module.exports = encode;
		}

		function encode(imgData, qu) {
		  if (typeof qu === 'undefined') qu = 50;
		  var encoder = new JPEGEncoder(qu);
			var data = encoder.encode(imgData, qu);
		  return {
		    data: data,
		    width: imgData.width,
		    height: imgData.height,
		  };
		}
	} (encoder));
	return encoder.exports;
}

var decoder = {exports: {}};

/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder.exports;
	hasRequiredDecoder = 1;
	(function (module) {
		/*
		   Copyright 2011 notmasteryet

		   Licensed under the Apache License, Version 2.0 (the "License");
		   you may not use this file except in compliance with the License.
		   You may obtain a copy of the License at

		       http://www.apache.org/licenses/LICENSE-2.0

		   Unless required by applicable law or agreed to in writing, software
		   distributed under the License is distributed on an "AS IS" BASIS,
		   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		   See the License for the specific language governing permissions and
		   limitations under the License.
		*/

		// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
		//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
		// - The JFIF specification can be found in the JPEG File Interchange Format
		//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
		// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
		//   in PostScript Level 2, Technical Note #5116
		//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

		var JpegImage = (function jpegImage() {
		  var dctZigZag = new Int32Array([
		     0,
		     1,  8,
		    16,  9,  2,
		     3, 10, 17, 24,
		    32, 25, 18, 11, 4,
		     5, 12, 19, 26, 33, 40,
		    48, 41, 34, 27, 20, 13,  6,
		     7, 14, 21, 28, 35, 42, 49, 56,
		    57, 50, 43, 36, 29, 22, 15,
		    23, 30, 37, 44, 51, 58,
		    59, 52, 45, 38, 31,
		    39, 46, 53, 60,
		    61, 54, 47,
		    55, 62,
		    63
		  ]);

		  var dctCos1  =  4017;   // cos(pi/16)
		  var dctSin1  =   799;   // sin(pi/16)
		  var dctCos3  =  3406;   // cos(3*pi/16)
		  var dctSin3  =  2276;   // sin(3*pi/16)
		  var dctCos6  =  1567;   // cos(6*pi/16)
		  var dctSin6  =  3784;   // sin(6*pi/16)
		  var dctSqrt2 =  5793;   // sqrt(2)
		  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

		  function constructor() {
		  }

		  function buildHuffmanTable(codeLengths, values) {
		    var k = 0, code = [], i, j, length = 16;
		    while (length > 0 && !codeLengths[length - 1])
		      length--;
		    code.push({children: [], index: 0});
		    var p = code[0], q;
		    for (i = 0; i < length; i++) {
		      for (j = 0; j < codeLengths[i]; j++) {
		        p = code.pop();
		        p.children[p.index] = values[k];
		        while (p.index > 0) {
		          if (code.length === 0)
		            throw new Error('Could not recreate Huffman Table');
		          p = code.pop();
		        }
		        p.index++;
		        code.push(p);
		        while (code.length <= i) {
		          code.push(q = {children: [], index: 0});
		          p.children[p.index] = q.children;
		          p = q;
		        }
		        k++;
		      }
		      if (i + 1 < length) {
		        // p here points to last code
		        code.push(q = {children: [], index: 0});
		        p.children[p.index] = q.children;
		        p = q;
		      }
		    }
		    return code[0].children;
		  }

		  function decodeScan(data, offset,
		                      frame, components, resetInterval,
		                      spectralStart, spectralEnd,
		                      successivePrev, successive, opts) {
		    frame.precision;
		    frame.samplesPerLine;
		    frame.scanLines;
		    var mcusPerLine = frame.mcusPerLine;
		    var progressive = frame.progressive;
		    frame.maxH; frame.maxV;

		    var startOffset = offset, bitsData = 0, bitsCount = 0;
		    function readBit() {
		      if (bitsCount > 0) {
		        bitsCount--;
		        return (bitsData >> bitsCount) & 1;
		      }
		      bitsData = data[offset++];
		      if (bitsData == 0xFF) {
		        var nextByte = data[offset++];
		        if (nextByte) {
		          throw new Error("unexpected marker: " + ((bitsData << 8) | nextByte).toString(16));
		        }
		        // unstuff 0
		      }
		      bitsCount = 7;
		      return bitsData >>> 7;
		    }
		    function decodeHuffman(tree) {
		      var node = tree, bit;
		      while ((bit = readBit()) !== null) {
		        node = node[bit];
		        if (typeof node === 'number')
		          return node;
		        if (typeof node !== 'object')
		          throw new Error("invalid huffman sequence");
		      }
		      return null;
		    }
		    function receive(length) {
		      var n = 0;
		      while (length > 0) {
		        var bit = readBit();
		        if (bit === null) return;
		        n = (n << 1) | bit;
		        length--;
		      }
		      return n;
		    }
		    function receiveAndExtend(length) {
		      var n = receive(length);
		      if (n >= 1 << (length - 1))
		        return n;
		      return n + (-1 << length) + 1;
		    }
		    function decodeBaseline(component, zz) {
		      var t = decodeHuffman(component.huffmanTableDC);
		      var diff = t === 0 ? 0 : receiveAndExtend(t);
		      zz[0]= (component.pred += diff);
		      var k = 1;
		      while (k < 64) {
		        var rs = decodeHuffman(component.huffmanTableAC);
		        var s = rs & 15, r = rs >> 4;
		        if (s === 0) {
		          if (r < 15)
		            break;
		          k += 16;
		          continue;
		        }
		        k += r;
		        var z = dctZigZag[k];
		        zz[z] = receiveAndExtend(s);
		        k++;
		      }
		    }
		    function decodeDCFirst(component, zz) {
		      var t = decodeHuffman(component.huffmanTableDC);
		      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
		      zz[0] = (component.pred += diff);
		    }
		    function decodeDCSuccessive(component, zz) {
		      zz[0] |= readBit() << successive;
		    }
		    var eobrun = 0;
		    function decodeACFirst(component, zz) {
		      if (eobrun > 0) {
		        eobrun--;
		        return;
		      }
		      var k = spectralStart, e = spectralEnd;
		      while (k <= e) {
		        var rs = decodeHuffman(component.huffmanTableAC);
		        var s = rs & 15, r = rs >> 4;
		        if (s === 0) {
		          if (r < 15) {
		            eobrun = receive(r) + (1 << r) - 1;
		            break;
		          }
		          k += 16;
		          continue;
		        }
		        k += r;
		        var z = dctZigZag[k];
		        zz[z] = receiveAndExtend(s) * (1 << successive);
		        k++;
		      }
		    }
		    var successiveACState = 0, successiveACNextValue;
		    function decodeACSuccessive(component, zz) {
		      var k = spectralStart, e = spectralEnd, r = 0;
		      while (k <= e) {
		        var z = dctZigZag[k];
		        var direction = zz[z] < 0 ? -1 : 1;
		        switch (successiveACState) {
		        case 0: // initial state
		          var rs = decodeHuffman(component.huffmanTableAC);
		          var s = rs & 15, r = rs >> 4;
		          if (s === 0) {
		            if (r < 15) {
		              eobrun = receive(r) + (1 << r);
		              successiveACState = 4;
		            } else {
		              r = 16;
		              successiveACState = 1;
		            }
		          } else {
		            if (s !== 1)
		              throw new Error("invalid ACn encoding");
		            successiveACNextValue = receiveAndExtend(s);
		            successiveACState = r ? 2 : 3;
		          }
		          continue;
		        case 1: // skipping r zero items
		        case 2:
		          if (zz[z])
		            zz[z] += (readBit() << successive) * direction;
		          else {
		            r--;
		            if (r === 0)
		              successiveACState = successiveACState == 2 ? 3 : 0;
		          }
		          break;
		        case 3: // set value for a zero item
		          if (zz[z])
		            zz[z] += (readBit() << successive) * direction;
		          else {
		            zz[z] = successiveACNextValue << successive;
		            successiveACState = 0;
		          }
		          break;
		        case 4: // eob
		          if (zz[z])
		            zz[z] += (readBit() << successive) * direction;
		          break;
		        }
		        k++;
		      }
		      if (successiveACState === 4) {
		        eobrun--;
		        if (eobrun === 0)
		          successiveACState = 0;
		      }
		    }
		    function decodeMcu(component, decode, mcu, row, col) {
		      var mcuRow = (mcu / mcusPerLine) | 0;
		      var mcuCol = mcu % mcusPerLine;
		      var blockRow = mcuRow * component.v + row;
		      var blockCol = mcuCol * component.h + col;
		      // If the block is missing and we're in tolerant mode, just skip it.
		      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
		        return;
		      decode(component, component.blocks[blockRow][blockCol]);
		    }
		    function decodeBlock(component, decode, mcu) {
		      var blockRow = (mcu / component.blocksPerLine) | 0;
		      var blockCol = mcu % component.blocksPerLine;
		      // If the block is missing and we're in tolerant mode, just skip it.
		      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
		        return;
		      decode(component, component.blocks[blockRow][blockCol]);
		    }

		    var componentsLength = components.length;
		    var component, i, j, k, n;
		    var decodeFn;
		    if (progressive) {
		      if (spectralStart === 0)
		        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
		      else
		        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
		    } else {
		      decodeFn = decodeBaseline;
		    }

		    var mcu = 0, marker;
		    var mcuExpected;
		    if (componentsLength == 1) {
		      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
		    } else {
		      mcuExpected = mcusPerLine * frame.mcusPerColumn;
		    }
		    if (!resetInterval) resetInterval = mcuExpected;

		    var h, v;
		    while (mcu < mcuExpected) {
		      // reset interval stuff
		      for (i = 0; i < componentsLength; i++)
		        components[i].pred = 0;
		      eobrun = 0;

		      if (componentsLength == 1) {
		        component = components[0];
		        for (n = 0; n < resetInterval; n++) {
		          decodeBlock(component, decodeFn, mcu);
		          mcu++;
		        }
		      } else {
		        for (n = 0; n < resetInterval; n++) {
		          for (i = 0; i < componentsLength; i++) {
		            component = components[i];
		            h = component.h;
		            v = component.v;
		            for (j = 0; j < v; j++) {
		              for (k = 0; k < h; k++) {
		                decodeMcu(component, decodeFn, mcu, j, k);
		              }
		            }
		          }
		          mcu++;

		          // If we've reached our expected MCU's, stop decoding
		          if (mcu === mcuExpected) break;
		        }
		      }

		      if (mcu === mcuExpected) {
		        // Skip trailing bytes at the end of the scan - until we reach the next marker
		        do {
		          if (data[offset] === 0xFF) {
		            if (data[offset + 1] !== 0x00) {
		              break;
		            }
		          }
		          offset += 1;
		        } while (offset < data.length - 2);
		      }

		      // find marker
		      bitsCount = 0;
		      marker = (data[offset] << 8) | data[offset + 1];
		      if (marker < 0xFF00) {
		        throw new Error("marker was not found");
		      }

		      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
		        offset += 2;
		      }
		      else
		        break;
		    }

		    return offset - startOffset;
		  }

		  function buildComponentData(frame, component) {
		    var lines = [];
		    var blocksPerLine = component.blocksPerLine;
		    var blocksPerColumn = component.blocksPerColumn;
		    var samplesPerLine = blocksPerLine << 3;
		    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.
		    var R = new Int32Array(64), r = new Uint8Array(64);

		    // A port of poppler's IDCT method which in turn is taken from:
		    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
		    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
		    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
		    //   988-991.
		    function quantizeAndInverse(zz, dataOut, dataIn) {
		      var qt = component.quantizationTable;
		      var v0, v1, v2, v3, v4, v5, v6, v7, t;
		      var p = dataIn;
		      var i;

		      // dequant
		      for (i = 0; i < 64; i++)
		        p[i] = zz[i] * qt[i];

		      // inverse DCT on rows
		      for (i = 0; i < 8; ++i) {
		        var row = 8 * i;

		        // check for all-zero AC coefficients
		        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
		            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
		            p[7 + row] == 0) {
		          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
		          p[0 + row] = t;
		          p[1 + row] = t;
		          p[2 + row] = t;
		          p[3 + row] = t;
		          p[4 + row] = t;
		          p[5 + row] = t;
		          p[6 + row] = t;
		          p[7 + row] = t;
		          continue;
		        }

		        // stage 4
		        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
		        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
		        v2 = p[2 + row];
		        v3 = p[6 + row];
		        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
		        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
		        v5 = p[3 + row] << 4;
		        v6 = p[5 + row] << 4;

		        // stage 3
		        t = (v0 - v1+ 1) >> 1;
		        v0 = (v0 + v1 + 1) >> 1;
		        v1 = t;
		        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
		        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
		        v3 = t;
		        t = (v4 - v6 + 1) >> 1;
		        v4 = (v4 + v6 + 1) >> 1;
		        v6 = t;
		        t = (v7 + v5 + 1) >> 1;
		        v5 = (v7 - v5 + 1) >> 1;
		        v7 = t;

		        // stage 2
		        t = (v0 - v3 + 1) >> 1;
		        v0 = (v0 + v3 + 1) >> 1;
		        v3 = t;
		        t = (v1 - v2 + 1) >> 1;
		        v1 = (v1 + v2 + 1) >> 1;
		        v2 = t;
		        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
		        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
		        v7 = t;
		        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
		        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
		        v6 = t;

		        // stage 1
		        p[0 + row] = v0 + v7;
		        p[7 + row] = v0 - v7;
		        p[1 + row] = v1 + v6;
		        p[6 + row] = v1 - v6;
		        p[2 + row] = v2 + v5;
		        p[5 + row] = v2 - v5;
		        p[3 + row] = v3 + v4;
		        p[4 + row] = v3 - v4;
		      }

		      // inverse DCT on columns
		      for (i = 0; i < 8; ++i) {
		        var col = i;

		        // check for all-zero AC coefficients
		        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
		            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
		            p[7*8 + col] == 0) {
		          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
		          p[0*8 + col] = t;
		          p[1*8 + col] = t;
		          p[2*8 + col] = t;
		          p[3*8 + col] = t;
		          p[4*8 + col] = t;
		          p[5*8 + col] = t;
		          p[6*8 + col] = t;
		          p[7*8 + col] = t;
		          continue;
		        }

		        // stage 4
		        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
		        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
		        v2 = p[2*8 + col];
		        v3 = p[6*8 + col];
		        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
		        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
		        v5 = p[3*8 + col];
		        v6 = p[5*8 + col];

		        // stage 3
		        t = (v0 - v1 + 1) >> 1;
		        v0 = (v0 + v1 + 1) >> 1;
		        v1 = t;
		        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
		        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
		        v3 = t;
		        t = (v4 - v6 + 1) >> 1;
		        v4 = (v4 + v6 + 1) >> 1;
		        v6 = t;
		        t = (v7 + v5 + 1) >> 1;
		        v5 = (v7 - v5 + 1) >> 1;
		        v7 = t;

		        // stage 2
		        t = (v0 - v3 + 1) >> 1;
		        v0 = (v0 + v3 + 1) >> 1;
		        v3 = t;
		        t = (v1 - v2 + 1) >> 1;
		        v1 = (v1 + v2 + 1) >> 1;
		        v2 = t;
		        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
		        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
		        v7 = t;
		        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
		        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
		        v6 = t;

		        // stage 1
		        p[0*8 + col] = v0 + v7;
		        p[7*8 + col] = v0 - v7;
		        p[1*8 + col] = v1 + v6;
		        p[6*8 + col] = v1 - v6;
		        p[2*8 + col] = v2 + v5;
		        p[5*8 + col] = v2 - v5;
		        p[3*8 + col] = v3 + v4;
		        p[4*8 + col] = v3 - v4;
		      }

		      // convert to 8-bit integers
		      for (i = 0; i < 64; ++i) {
		        var sample = 128 + ((p[i] + 8) >> 4);
		        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
		      }
		    }

		    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);

		    var i, j;
		    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
		      var scanLine = blockRow << 3;
		      for (i = 0; i < 8; i++)
		        lines.push(new Uint8Array(samplesPerLine));
		      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
		        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

		        var offset = 0, sample = blockCol << 3;
		        for (j = 0; j < 8; j++) {
		          var line = lines[scanLine + j];
		          for (i = 0; i < 8; i++)
		            line[sample + i] = r[offset++];
		        }
		      }
		    }
		    return lines;
		  }

		  function clampTo8bit(a) {
		    return a < 0 ? 0 : a > 255 ? 255 : a;
		  }

		  constructor.prototype = {
		    load: function load(path) {
		      var xhr = new XMLHttpRequest();
		      xhr.open("GET", path, true);
		      xhr.responseType = "arraybuffer";
		      xhr.onload = (function() {
		        // TODO catch parse error
		        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
		        this.parse(data);
		        if (this.onload)
		          this.onload();
		      }).bind(this);
		      xhr.send(null);
		    },
		    parse: function parse(data) {
		      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
		      var offset = 0; data.length;
		      function readUint16() {
		        var value = (data[offset] << 8) | data[offset + 1];
		        offset += 2;
		        return value;
		      }
		      function readDataBlock() {
		        var length = readUint16();
		        var array = data.subarray(offset, offset + length - 2);
		        offset += array.length;
		        return array;
		      }
		      function prepareComponents(frame) {
		        // According to the JPEG standard, the sampling factor must be between 1 and 4
		        // See https://github.com/libjpeg-turbo/libjpeg-turbo/blob/9abeff46d87bd201a952e276f3e4339556a403a3/libjpeg.txt#L1138-L1146
		        var maxH = 1, maxV = 1;
		        var component, componentId;
		        for (componentId in frame.components) {
		          if (frame.components.hasOwnProperty(componentId)) {
		            component = frame.components[componentId];
		            if (maxH < component.h) maxH = component.h;
		            if (maxV < component.v) maxV = component.v;
		          }
		        }
		        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
		        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
		        for (componentId in frame.components) {
		          if (frame.components.hasOwnProperty(componentId)) {
		            component = frame.components[componentId];
		            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
		            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
		            var blocksPerLineForMcu = mcusPerLine * component.h;
		            var blocksPerColumnForMcu = mcusPerColumn * component.v;
		            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
		            var blocks = [];

		            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)
		            requestMemoryAllocation(blocksToAllocate * 256);

		            for (var i = 0; i < blocksPerColumnForMcu; i++) {
		              var row = [];
		              for (var j = 0; j < blocksPerLineForMcu; j++)
		                row.push(new Int32Array(64));
		              blocks.push(row);
		            }
		            component.blocksPerLine = blocksPerLine;
		            component.blocksPerColumn = blocksPerColumn;
		            component.blocks = blocks;
		          }
		        }
		        frame.maxH = maxH;
		        frame.maxV = maxV;
		        frame.mcusPerLine = mcusPerLine;
		        frame.mcusPerColumn = mcusPerColumn;
		      }
		      var jfif = null;
		      var adobe = null;
		      var frame, resetInterval;
		      var quantizationTables = [], frames = [];
		      var huffmanTablesAC = [], huffmanTablesDC = [];
		      var fileMarker = readUint16();
		      var malformedDataOffset = -1;
		      this.comments = [];
		      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
		        throw new Error("SOI not found");
		      }

		      fileMarker = readUint16();
		      while (fileMarker != 0xFFD9) { // EOI (End of image)
		        var i, j;
		        switch(fileMarker) {
		          case 0xFF00: break;
		          case 0xFFE0: // APP0 (Application Specific)
		          case 0xFFE1: // APP1
		          case 0xFFE2: // APP2
		          case 0xFFE3: // APP3
		          case 0xFFE4: // APP4
		          case 0xFFE5: // APP5
		          case 0xFFE6: // APP6
		          case 0xFFE7: // APP7
		          case 0xFFE8: // APP8
		          case 0xFFE9: // APP9
		          case 0xFFEA: // APP10
		          case 0xFFEB: // APP11
		          case 0xFFEC: // APP12
		          case 0xFFED: // APP13
		          case 0xFFEE: // APP14
		          case 0xFFEF: // APP15
		          case 0xFFFE: // COM (Comment)
		            var appData = readDataBlock();

		            if (fileMarker === 0xFFFE) {
		              var comment = String.fromCharCode.apply(null, appData);
		              this.comments.push(comment);
		            }

		            if (fileMarker === 0xFFE0) {
		              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
		                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
		                jfif = {
		                  version: { major: appData[5], minor: appData[6] },
		                  densityUnits: appData[7],
		                  xDensity: (appData[8] << 8) | appData[9],
		                  yDensity: (appData[10] << 8) | appData[11],
		                  thumbWidth: appData[12],
		                  thumbHeight: appData[13],
		                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
		                };
		              }
		            }
		            // TODO APP1 - Exif
		            if (fileMarker === 0xFFE1) {
		              if (appData[0] === 0x45 &&
		                appData[1] === 0x78 &&
		                appData[2] === 0x69 &&
		                appData[3] === 0x66 &&
		                appData[4] === 0) { // 'EXIF\x00'
		                this.exifBuffer = appData.subarray(5, appData.length);
		              }
		            }

		            if (fileMarker === 0xFFEE) {
		              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
		                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
		                adobe = {
		                  version: appData[6],
		                  flags0: (appData[7] << 8) | appData[8],
		                  flags1: (appData[9] << 8) | appData[10],
		                  transformCode: appData[11]
		                };
		              }
		            }
		            break;

		          case 0xFFDB: // DQT (Define Quantization Tables)
		            var quantizationTablesLength = readUint16();
		            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
		            while (offset < quantizationTablesEnd) {
		              var quantizationTableSpec = data[offset++];
		              requestMemoryAllocation(64 * 4);
		              var tableData = new Int32Array(64);
		              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
		                for (j = 0; j < 64; j++) {
		                  var z = dctZigZag[j];
		                  tableData[z] = data[offset++];
		                }
		              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
		                for (j = 0; j < 64; j++) {
		                  var z = dctZigZag[j];
		                  tableData[z] = readUint16();
		                }
		              } else
		                throw new Error("DQT: invalid table spec");
		              quantizationTables[quantizationTableSpec & 15] = tableData;
		            }
		            break;

		          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
		          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
		          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
		            readUint16(); // skip data length
		            frame = {};
		            frame.extended = (fileMarker === 0xFFC1);
		            frame.progressive = (fileMarker === 0xFFC2);
		            frame.precision = data[offset++];
		            frame.scanLines = readUint16();
		            frame.samplesPerLine = readUint16();
		            frame.components = {};
		            frame.componentsOrder = [];

		            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
		            if (pixelsInFrame > maxResolutionInPixels) {
		              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
		              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
		            }

		            var componentsCount = data[offset++], componentId;
		            for (i = 0; i < componentsCount; i++) {
		              componentId = data[offset];
		              var h = data[offset + 1] >> 4;
		              var v = data[offset + 1] & 15;
		              var qId = data[offset + 2];

		              if ( h <= 0 || v <= 0 ) {
		                throw new Error('Invalid sampling factor, expected values above 0');
		              }

		              frame.componentsOrder.push(componentId);
		              frame.components[componentId] = {
		                h: h,
		                v: v,
		                quantizationIdx: qId
		              };
		              offset += 3;
		            }
		            prepareComponents(frame);
		            frames.push(frame);
		            break;

		          case 0xFFC4: // DHT (Define Huffman Tables)
		            var huffmanLength = readUint16();
		            for (i = 2; i < huffmanLength;) {
		              var huffmanTableSpec = data[offset++];
		              var codeLengths = new Uint8Array(16);
		              var codeLengthSum = 0;
		              for (j = 0; j < 16; j++, offset++) {
		                codeLengthSum += (codeLengths[j] = data[offset]);
		              }
		              requestMemoryAllocation(16 + codeLengthSum);
		              var huffmanValues = new Uint8Array(codeLengthSum);
		              for (j = 0; j < codeLengthSum; j++, offset++)
		                huffmanValues[j] = data[offset];
		              i += 17 + codeLengthSum;

		              ((huffmanTableSpec >> 4) === 0 ?
		                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
		                buildHuffmanTable(codeLengths, huffmanValues);
		            }
		            break;

		          case 0xFFDD: // DRI (Define Restart Interval)
		            readUint16(); // skip data length
		            resetInterval = readUint16();
		            break;

		          case 0xFFDC: // Number of Lines marker
		            readUint16(); // skip data length
		            readUint16(); // Ignore this data since it represents the image height
		            break;
		            
		          case 0xFFDA: // SOS (Start of Scan)
		            readUint16();
		            var selectorsCount = data[offset++];
		            var components = [], component;
		            for (i = 0; i < selectorsCount; i++) {
		              component = frame.components[data[offset++]];
		              var tableSpec = data[offset++];
		              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
		              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
		              components.push(component);
		            }
		            var spectralStart = data[offset++];
		            var spectralEnd = data[offset++];
		            var successiveApproximation = data[offset++];
		            var processed = decodeScan(data, offset,
		              frame, components, resetInterval,
		              spectralStart, spectralEnd,
		              successiveApproximation >> 4, successiveApproximation & 15, this.opts);
		            offset += processed;
		            break;

		          case 0xFFFF: // Fill bytes
		            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
		              offset--;
		            }
		            break;
		          default:
		            if (data[offset - 3] == 0xFF &&
		                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
		              // could be incorrect encoding -- last 0xFF byte of the previous
		              // block was eaten by the encoder
		              offset -= 3;
		              break;
		            }
		            else if (fileMarker === 0xE0 || fileMarker == 0xE1) {
		              // Recover from malformed APP1 markers popular in some phone models.
		              // See https://github.com/eugeneware/jpeg-js/issues/82
		              if (malformedDataOffset !== -1) {
		                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
		              }
		              malformedDataOffset = offset - 1;
		              const nextOffset = readUint16();
		              if (data[offset + nextOffset - 2] === 0xFF) {
		                offset += nextOffset - 2;
		                break;
		              }
		            }
		            throw new Error("unknown JPEG marker " + fileMarker.toString(16));
		        }
		        fileMarker = readUint16();
		      }
		      if (frames.length != 1)
		        throw new Error("only single frame JPEGs supported");

		      // set each frame's components quantization table
		      for (var i = 0; i < frames.length; i++) {
		        var cp = frames[i].components;
		        for (var j in cp) {
		          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
		          delete cp[j].quantizationIdx;
		        }
		      }

		      this.width = frame.samplesPerLine;
		      this.height = frame.scanLines;
		      this.jfif = jfif;
		      this.adobe = adobe;
		      this.components = [];
		      for (var i = 0; i < frame.componentsOrder.length; i++) {
		        var component = frame.components[frame.componentsOrder[i]];
		        this.components.push({
		          lines: buildComponentData(frame, component),
		          scaleX: component.h / frame.maxH,
		          scaleY: component.v / frame.maxV
		        });
		      }
		    },
		    getData: function getData(width, height) {
		      var scaleX = this.width / width, scaleY = this.height / height;

		      var component1, component2, component3, component4;
		      var component1Line, component2Line, component3Line, component4Line;
		      var x, y;
		      var offset = 0;
		      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
		      var colorTransform;
		      var dataLength = width * height * this.components.length;
		      requestMemoryAllocation(dataLength);
		      var data = new Uint8Array(dataLength);
		      switch (this.components.length) {
		        case 1:
		          component1 = this.components[0];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

		              data[offset++] = Y;
		            }
		          }
		          break;
		        case 2:
		          // PDF might compress two component data in custom colorspace
		          component1 = this.components[0];
		          component2 = this.components[1];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
		              data[offset++] = Y;
		              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
		              data[offset++] = Y;
		            }
		          }
		          break;
		        case 3:
		          // The default transform for three components is true
		          colorTransform = true;
		          // The adobe transform marker overrides any previous setting
		          if (this.adobe && this.adobe.transformCode)
		            colorTransform = true;
		          else if (typeof this.opts.colorTransform !== 'undefined')
		            colorTransform = !!this.opts.colorTransform;

		          component1 = this.components[0];
		          component2 = this.components[1];
		          component3 = this.components[2];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
		            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              if (!colorTransform) {
		                R = component1Line[0 | (x * component1.scaleX * scaleX)];
		                G = component2Line[0 | (x * component2.scaleX * scaleX)];
		                B = component3Line[0 | (x * component3.scaleX * scaleX)];
		              } else {
		                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
		                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
		                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

		                R = clampTo8bit(Y + 1.402 * (Cr - 128));
		                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
		                B = clampTo8bit(Y + 1.772 * (Cb - 128));
		              }

		              data[offset++] = R;
		              data[offset++] = G;
		              data[offset++] = B;
		            }
		          }
		          break;
		        case 4:
		          if (!this.adobe)
		            throw new Error('Unsupported color mode (4 components)');
		          // The default transform for four components is false
		          colorTransform = false;
		          // The adobe transform marker overrides any previous setting
		          if (this.adobe && this.adobe.transformCode)
		            colorTransform = true;
		          else if (typeof this.opts.colorTransform !== 'undefined')
		            colorTransform = !!this.opts.colorTransform;

		          component1 = this.components[0];
		          component2 = this.components[1];
		          component3 = this.components[2];
		          component4 = this.components[3];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
		            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
		            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              if (!colorTransform) {
		                C = component1Line[0 | (x * component1.scaleX * scaleX)];
		                M = component2Line[0 | (x * component2.scaleX * scaleX)];
		                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
		                K = component4Line[0 | (x * component4.scaleX * scaleX)];
		              } else {
		                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
		                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
		                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
		                K = component4Line[0 | (x * component4.scaleX * scaleX)];

		                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
		                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
		                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
		              }
		              data[offset++] = 255-C;
		              data[offset++] = 255-M;
		              data[offset++] = 255-Ye;
		              data[offset++] = 255-K;
		            }
		          }
		          break;
		        default:
		          throw new Error('Unsupported color mode');
		      }
		      return data;
		    },
		    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
		      var width = imageData.width, height = imageData.height;
		      var imageDataArray = imageData.data;
		      var data = this.getData(width, height);
		      var i = 0, j = 0, x, y;
		      var Y, K, C, M, R, G, B;
		      switch (this.components.length) {
		        case 1:
		          for (y = 0; y < height; y++) {
		            for (x = 0; x < width; x++) {
		              Y = data[i++];

		              imageDataArray[j++] = Y;
		              imageDataArray[j++] = Y;
		              imageDataArray[j++] = Y;
		              if (formatAsRGBA) {
		                imageDataArray[j++] = 255;
		              }
		            }
		          }
		          break;
		        case 3:
		          for (y = 0; y < height; y++) {
		            for (x = 0; x < width; x++) {
		              R = data[i++];
		              G = data[i++];
		              B = data[i++];

		              imageDataArray[j++] = R;
		              imageDataArray[j++] = G;
		              imageDataArray[j++] = B;
		              if (formatAsRGBA) {
		                imageDataArray[j++] = 255;
		              }
		            }
		          }
		          break;
		        case 4:
		          for (y = 0; y < height; y++) {
		            for (x = 0; x < width; x++) {
		              C = data[i++];
		              M = data[i++];
		              Y = data[i++];
		              K = data[i++];

		              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
		              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
		              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

		              imageDataArray[j++] = R;
		              imageDataArray[j++] = G;
		              imageDataArray[j++] = B;
		              if (formatAsRGBA) {
		                imageDataArray[j++] = 255;
		              }
		            }
		          }
		          break;
		        default:
		          throw new Error('Unsupported color mode');
		      }
		    }
		  };


		  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.
		  var totalBytesAllocated = 0;
		  var maxMemoryUsageBytes = 0;
		  function requestMemoryAllocation(increaseAmount = 0) {
		    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
		    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
		      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
		      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
		    }

		    totalBytesAllocated = totalMemoryImpactBytes;
		  }

		  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {
		    totalBytesAllocated = 0;
		    maxMemoryUsageBytes = maxMemoryUsageBytes_;
		  };

		  constructor.getBytesAllocated = function () {
		    return totalBytesAllocated;
		  };

		  constructor.requestMemoryAllocation = requestMemoryAllocation;

		  return constructor;
		})();

		{
			module.exports = decode;
		}

		function decode(jpegData, userOpts = {}) {
		  var defaultOpts = {
		    // "undefined" means "Choose whether to transform colors based on the imageâ€™s color model."
		    colorTransform: undefined,
		    useTArray: false,
		    formatAsRGBA: true,
		    tolerantDecoding: true,
		    maxResolutionInMP: 100, // Don't decode more than 100 megapixels
		    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB
		  };

		  var opts = {...defaultOpts, ...userOpts};
		  var arr = new Uint8Array(jpegData);
		  var decoder = new JpegImage();
		  decoder.opts = opts;
		  // If this constructor ever supports async decoding this will need to be done differently.
		  // Until then, treating as singleton limit is fine.
		  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
		  decoder.parse(arr);

		  var channels = (opts.formatAsRGBA) ? 4 : 3;
		  var bytesNeeded = decoder.width * decoder.height * channels;
		  try {
		    JpegImage.requestMemoryAllocation(bytesNeeded);
		    var image = {
		      width: decoder.width,
		      height: decoder.height,
		      exifBuffer: decoder.exifBuffer,
		      data: opts.useTArray ?
		        new Uint8Array(bytesNeeded) :
		        Buffer.alloc(bytesNeeded)
		    };
		    if(decoder.comments.length > 0) {
		      image["comments"] = decoder.comments;
		    }
		  } catch (err) {
		    if (err instanceof RangeError) {
		      throw new Error("Could not allocate enough memory for the image. " +
		                      "Required: " + bytesNeeded);
		    } 
		    
		    if (err instanceof ReferenceError) {
		      if (err.message === "Buffer is not defined") {
		        throw new Error("Buffer is not globally defined in this environment. " +
		                        "Consider setting useTArray to true");
		      }
		    }
		    throw err;
		  }

		  decoder.copyToImageData(image, opts.formatAsRGBA);

		  return image;
		} 
	} (decoder));
	return decoder.exports;
}

var jpegJs;
var hasRequiredJpegJs;

function requireJpegJs () {
	if (hasRequiredJpegJs) return jpegJs;
	hasRequiredJpegJs = 1;
	var encode = requireEncoder(),
	    decode = requireDecoder();

	jpegJs = {
	  encode: encode,
	  decode: decode
	};
	return jpegJs;
}

var jpegJsExports = requireJpegJs();
const JPEG = /*@__PURE__*/getDefaultExportFromCjs(jpegJsExports);

function jpeg$1() {
    return {
        mime: "image/jpeg",
        encode: (bitmap, { quality = 100 } = {}) => JPEG.encode(bitmap, quality).data,
        decode: (data, options) => JPEG.decode(data, options),
    };
}

var png$1 = {};

var parserAsync = {exports: {}};

var chunkstream = {exports: {}};

var hasRequiredChunkstream;

function requireChunkstream () {
	if (hasRequiredChunkstream) return chunkstream.exports;
	hasRequiredChunkstream = 1;

	let util = require$$0;
	let Stream = require$$1;

	let ChunkStream = (chunkstream.exports = function () {
	  Stream.call(this);

	  this._buffers = [];
	  this._buffered = 0;

	  this._reads = [];
	  this._paused = false;

	  this._encoding = "utf8";
	  this.writable = true;
	});
	util.inherits(ChunkStream, Stream);

	ChunkStream.prototype.read = function (length, callback) {
	  this._reads.push({
	    length: Math.abs(length), // if length < 0 then at most this length
	    allowLess: length < 0,
	    func: callback,
	  });

	  process.nextTick(
	    function () {
	      this._process();

	      // its paused and there is not enought data then ask for more
	      if (this._paused && this._reads && this._reads.length > 0) {
	        this._paused = false;

	        this.emit("drain");
	      }
	    }.bind(this)
	  );
	};

	ChunkStream.prototype.write = function (data, encoding) {
	  if (!this.writable) {
	    this.emit("error", new Error("Stream not writable"));
	    return false;
	  }

	  let dataBuffer;
	  if (Buffer.isBuffer(data)) {
	    dataBuffer = data;
	  } else {
	    dataBuffer = Buffer.from(data, encoding || this._encoding);
	  }

	  this._buffers.push(dataBuffer);
	  this._buffered += dataBuffer.length;

	  this._process();

	  // ok if there are no more read requests
	  if (this._reads && this._reads.length === 0) {
	    this._paused = true;
	  }

	  return this.writable && !this._paused;
	};

	ChunkStream.prototype.end = function (data, encoding) {
	  if (data) {
	    this.write(data, encoding);
	  }

	  this.writable = false;

	  // already destroyed
	  if (!this._buffers) {
	    return;
	  }

	  // enqueue or handle end
	  if (this._buffers.length === 0) {
	    this._end();
	  } else {
	    this._buffers.push(null);
	    this._process();
	  }
	};

	ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;

	ChunkStream.prototype._end = function () {
	  if (this._reads.length > 0) {
	    this.emit("error", new Error("Unexpected end of input"));
	  }

	  this.destroy();
	};

	ChunkStream.prototype.destroy = function () {
	  if (!this._buffers) {
	    return;
	  }

	  this.writable = false;
	  this._reads = null;
	  this._buffers = null;

	  this.emit("close");
	};

	ChunkStream.prototype._processReadAllowingLess = function (read) {
	  // ok there is any data so that we can satisfy this request
	  this._reads.shift(); // == read

	  // first we need to peek into first buffer
	  let smallerBuf = this._buffers[0];

	  // ok there is more data than we need
	  if (smallerBuf.length > read.length) {
	    this._buffered -= read.length;
	    this._buffers[0] = smallerBuf.slice(read.length);

	    read.func.call(this, smallerBuf.slice(0, read.length));
	  } else {
	    // ok this is less than maximum length so use it all
	    this._buffered -= smallerBuf.length;
	    this._buffers.shift(); // == smallerBuf

	    read.func.call(this, smallerBuf);
	  }
	};

	ChunkStream.prototype._processRead = function (read) {
	  this._reads.shift(); // == read

	  let pos = 0;
	  let count = 0;
	  let data = Buffer.alloc(read.length);

	  // create buffer for all data
	  while (pos < read.length) {
	    let buf = this._buffers[count++];
	    let len = Math.min(buf.length, read.length - pos);

	    buf.copy(data, pos, 0, len);
	    pos += len;

	    // last buffer wasn't used all so just slice it and leave
	    if (len !== buf.length) {
	      this._buffers[--count] = buf.slice(len);
	    }
	  }

	  // remove all used buffers
	  if (count > 0) {
	    this._buffers.splice(0, count);
	  }

	  this._buffered -= read.length;

	  read.func.call(this, data);
	};

	ChunkStream.prototype._process = function () {
	  try {
	    // as long as there is any data and read requests
	    while (this._buffered > 0 && this._reads && this._reads.length > 0) {
	      let read = this._reads[0];

	      // read any data (but no more than length)
	      if (read.allowLess) {
	        this._processReadAllowingLess(read);
	      } else if (this._buffered >= read.length) {
	        // ok we can meet some expectations

	        this._processRead(read);
	      } else {
	        // not enought data to satisfy first request in queue
	        // so we need to wait for more
	        break;
	      }
	    }

	    if (this._buffers && !this.writable) {
	      this._end();
	    }
	  } catch (ex) {
	    this.emit("error", ex);
	  }
	};
	return chunkstream.exports;
}

var filterParseAsync = {exports: {}};

var filterParse = {exports: {}};

var interlace = {};

var hasRequiredInterlace;

function requireInterlace () {
	if (hasRequiredInterlace) return interlace;
	hasRequiredInterlace = 1;

	// Adam 7
	//   0 1 2 3 4 5 6 7
	// 0 x 6 4 6 x 6 4 6
	// 1 7 7 7 7 7 7 7 7
	// 2 5 6 5 6 5 6 5 6
	// 3 7 7 7 7 7 7 7 7
	// 4 3 6 4 6 3 6 4 6
	// 5 7 7 7 7 7 7 7 7
	// 6 5 6 5 6 5 6 5 6
	// 7 7 7 7 7 7 7 7 7

	let imagePasses = [
	  {
	    // pass 1 - 1px
	    x: [0],
	    y: [0],
	  },
	  {
	    // pass 2 - 1px
	    x: [4],
	    y: [0],
	  },
	  {
	    // pass 3 - 2px
	    x: [0, 4],
	    y: [4],
	  },
	  {
	    // pass 4 - 4px
	    x: [2, 6],
	    y: [0, 4],
	  },
	  {
	    // pass 5 - 8px
	    x: [0, 2, 4, 6],
	    y: [2, 6],
	  },
	  {
	    // pass 6 - 16px
	    x: [1, 3, 5, 7],
	    y: [0, 2, 4, 6],
	  },
	  {
	    // pass 7 - 32px
	    x: [0, 1, 2, 3, 4, 5, 6, 7],
	    y: [1, 3, 5, 7],
	  },
	];

	interlace.getImagePasses = function (width, height) {
	  let images = [];
	  let xLeftOver = width % 8;
	  let yLeftOver = height % 8;
	  let xRepeats = (width - xLeftOver) / 8;
	  let yRepeats = (height - yLeftOver) / 8;
	  for (let i = 0; i < imagePasses.length; i++) {
	    let pass = imagePasses[i];
	    let passWidth = xRepeats * pass.x.length;
	    let passHeight = yRepeats * pass.y.length;
	    for (let j = 0; j < pass.x.length; j++) {
	      if (pass.x[j] < xLeftOver) {
	        passWidth++;
	      } else {
	        break;
	      }
	    }
	    for (let j = 0; j < pass.y.length; j++) {
	      if (pass.y[j] < yLeftOver) {
	        passHeight++;
	      } else {
	        break;
	      }
	    }
	    if (passWidth > 0 && passHeight > 0) {
	      images.push({ width: passWidth, height: passHeight, index: i });
	    }
	  }
	  return images;
	};

	interlace.getInterlaceIterator = function (width) {
	  return function (x, y, pass) {
	    let outerXLeftOver = x % imagePasses[pass].x.length;
	    let outerX =
	      ((x - outerXLeftOver) / imagePasses[pass].x.length) * 8 +
	      imagePasses[pass].x[outerXLeftOver];
	    let outerYLeftOver = y % imagePasses[pass].y.length;
	    let outerY =
	      ((y - outerYLeftOver) / imagePasses[pass].y.length) * 8 +
	      imagePasses[pass].y[outerYLeftOver];
	    return outerX * 4 + outerY * width * 4;
	  };
	};
	return interlace;
}

var paethPredictor;
var hasRequiredPaethPredictor;

function requirePaethPredictor () {
	if (hasRequiredPaethPredictor) return paethPredictor;
	hasRequiredPaethPredictor = 1;

	paethPredictor = function paethPredictor(left, above, upLeft) {
	  let paeth = left + above - upLeft;
	  let pLeft = Math.abs(paeth - left);
	  let pAbove = Math.abs(paeth - above);
	  let pUpLeft = Math.abs(paeth - upLeft);

	  if (pLeft <= pAbove && pLeft <= pUpLeft) {
	    return left;
	  }
	  if (pAbove <= pUpLeft) {
	    return above;
	  }
	  return upLeft;
	};
	return paethPredictor;
}

var hasRequiredFilterParse;

function requireFilterParse () {
	if (hasRequiredFilterParse) return filterParse.exports;
	hasRequiredFilterParse = 1;

	let interlaceUtils = requireInterlace();
	let paethPredictor = requirePaethPredictor();

	function getByteWidth(width, bpp, depth) {
	  let byteWidth = width * bpp;
	  if (depth !== 8) {
	    byteWidth = Math.ceil(byteWidth / (8 / depth));
	  }
	  return byteWidth;
	}

	let Filter = (filterParse.exports = function (bitmapInfo, dependencies) {
	  let width = bitmapInfo.width;
	  let height = bitmapInfo.height;
	  let interlace = bitmapInfo.interlace;
	  let bpp = bitmapInfo.bpp;
	  let depth = bitmapInfo.depth;

	  this.read = dependencies.read;
	  this.write = dependencies.write;
	  this.complete = dependencies.complete;

	  this._imageIndex = 0;
	  this._images = [];
	  if (interlace) {
	    let passes = interlaceUtils.getImagePasses(width, height);
	    for (let i = 0; i < passes.length; i++) {
	      this._images.push({
	        byteWidth: getByteWidth(passes[i].width, bpp, depth),
	        height: passes[i].height,
	        lineIndex: 0,
	      });
	    }
	  } else {
	    this._images.push({
	      byteWidth: getByteWidth(width, bpp, depth),
	      height: height,
	      lineIndex: 0,
	    });
	  }

	  // when filtering the line we look at the pixel to the left
	  // the spec also says it is done on a byte level regardless of the number of pixels
	  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back
	  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.
	  if (depth === 8) {
	    this._xComparison = bpp;
	  } else if (depth === 16) {
	    this._xComparison = bpp * 2;
	  } else {
	    this._xComparison = 1;
	  }
	});

	Filter.prototype.start = function () {
	  this.read(
	    this._images[this._imageIndex].byteWidth + 1,
	    this._reverseFilterLine.bind(this)
	  );
	};

	Filter.prototype._unFilterType1 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let xComparison = this._xComparison;
	  let xBiggerThan = xComparison - 1;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
	    unfilteredLine[x] = rawByte + f1Left;
	  }
	};

	Filter.prototype._unFilterType2 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let lastLine = this._lastLine;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f2Up = lastLine ? lastLine[x] : 0;
	    unfilteredLine[x] = rawByte + f2Up;
	  }
	};

	Filter.prototype._unFilterType3 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let xComparison = this._xComparison;
	  let xBiggerThan = xComparison - 1;
	  let lastLine = this._lastLine;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f3Up = lastLine ? lastLine[x] : 0;
	    let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
	    let f3Add = Math.floor((f3Left + f3Up) / 2);
	    unfilteredLine[x] = rawByte + f3Add;
	  }
	};

	Filter.prototype._unFilterType4 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let xComparison = this._xComparison;
	  let xBiggerThan = xComparison - 1;
	  let lastLine = this._lastLine;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f4Up = lastLine ? lastLine[x] : 0;
	    let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
	    let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
	    let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
	    unfilteredLine[x] = rawByte + f4Add;
	  }
	};

	Filter.prototype._reverseFilterLine = function (rawData) {
	  let filter = rawData[0];
	  let unfilteredLine;
	  let currentImage = this._images[this._imageIndex];
	  let byteWidth = currentImage.byteWidth;

	  if (filter === 0) {
	    unfilteredLine = rawData.slice(1, byteWidth + 1);
	  } else {
	    unfilteredLine = Buffer.alloc(byteWidth);

	    switch (filter) {
	      case 1:
	        this._unFilterType1(rawData, unfilteredLine, byteWidth);
	        break;
	      case 2:
	        this._unFilterType2(rawData, unfilteredLine, byteWidth);
	        break;
	      case 3:
	        this._unFilterType3(rawData, unfilteredLine, byteWidth);
	        break;
	      case 4:
	        this._unFilterType4(rawData, unfilteredLine, byteWidth);
	        break;
	      default:
	        throw new Error("Unrecognised filter type - " + filter);
	    }
	  }

	  this.write(unfilteredLine);

	  currentImage.lineIndex++;
	  if (currentImage.lineIndex >= currentImage.height) {
	    this._lastLine = null;
	    this._imageIndex++;
	    currentImage = this._images[this._imageIndex];
	  } else {
	    this._lastLine = unfilteredLine;
	  }

	  if (currentImage) {
	    // read, using the byte width that may be from the new current image
	    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
	  } else {
	    this._lastLine = null;
	    this.complete();
	  }
	};
	return filterParse.exports;
}

var hasRequiredFilterParseAsync;

function requireFilterParseAsync () {
	if (hasRequiredFilterParseAsync) return filterParseAsync.exports;
	hasRequiredFilterParseAsync = 1;

	let util = require$$0;
	let ChunkStream = requireChunkstream();
	let Filter = requireFilterParse();

	let FilterAsync = (filterParseAsync.exports = function (bitmapInfo) {
	  ChunkStream.call(this);

	  let buffers = [];
	  let that = this;
	  this._filter = new Filter(bitmapInfo, {
	    read: this.read.bind(this),
	    write: function (buffer) {
	      buffers.push(buffer);
	    },
	    complete: function () {
	      that.emit("complete", Buffer.concat(buffers));
	    },
	  });

	  this._filter.start();
	});
	util.inherits(FilterAsync, ChunkStream);
	return filterParseAsync.exports;
}

var parser$1 = {exports: {}};

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;

	constants$1 = {
	  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],

	  TYPE_IHDR: 0x49484452,
	  TYPE_IEND: 0x49454e44,
	  TYPE_IDAT: 0x49444154,
	  TYPE_PLTE: 0x504c5445,
	  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase
	  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase

	  // color-type bits
	  COLORTYPE_GRAYSCALE: 0,
	  COLORTYPE_PALETTE: 1,
	  COLORTYPE_COLOR: 2,
	  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha

	  // color-type combinations
	  COLORTYPE_PALETTE_COLOR: 3,
	  COLORTYPE_COLOR_ALPHA: 6,

	  COLORTYPE_TO_BPP_MAP: {
	    0: 1,
	    2: 3,
	    3: 1,
	    4: 2,
	    6: 4,
	  },

	  GAMMA_DIVISION: 100000,
	};
	return constants$1;
}

var crc = {exports: {}};

var hasRequiredCrc;

function requireCrc () {
	if (hasRequiredCrc) return crc.exports;
	hasRequiredCrc = 1;

	let crcTable = [];

	(function () {
	  for (let i = 0; i < 256; i++) {
	    let currentCrc = i;
	    for (let j = 0; j < 8; j++) {
	      if (currentCrc & 1) {
	        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);
	      } else {
	        currentCrc = currentCrc >>> 1;
	      }
	    }
	    crcTable[i] = currentCrc;
	  }
	})();

	let CrcCalculator = (crc.exports = function () {
	  this._crc = -1;
	});

	CrcCalculator.prototype.write = function (data) {
	  for (let i = 0; i < data.length; i++) {
	    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
	  }
	  return true;
	};

	CrcCalculator.prototype.crc32 = function () {
	  return this._crc ^ -1;
	};

	CrcCalculator.crc32 = function (buf) {
	  let crc = -1;
	  for (let i = 0; i < buf.length; i++) {
	    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
	  }
	  return crc ^ -1;
	};
	return crc.exports;
}

var hasRequiredParser$1;

function requireParser$1 () {
	if (hasRequiredParser$1) return parser$1.exports;
	hasRequiredParser$1 = 1;

	let constants = requireConstants$1();
	let CrcCalculator = requireCrc();

	let Parser = (parser$1.exports = function (options, dependencies) {
	  this._options = options;
	  options.checkCRC = options.checkCRC !== false;

	  this._hasIHDR = false;
	  this._hasIEND = false;
	  this._emittedHeadersFinished = false;

	  // input flags/metadata
	  this._palette = [];
	  this._colorType = 0;

	  this._chunks = {};
	  this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
	  this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
	  this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
	  this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
	  this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
	  this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);

	  this.read = dependencies.read;
	  this.error = dependencies.error;
	  this.metadata = dependencies.metadata;
	  this.gamma = dependencies.gamma;
	  this.transColor = dependencies.transColor;
	  this.palette = dependencies.palette;
	  this.parsed = dependencies.parsed;
	  this.inflateData = dependencies.inflateData;
	  this.finished = dependencies.finished;
	  this.simpleTransparency = dependencies.simpleTransparency;
	  this.headersFinished = dependencies.headersFinished || function () {};
	});

	Parser.prototype.start = function () {
	  this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
	};

	Parser.prototype._parseSignature = function (data) {
	  let signature = constants.PNG_SIGNATURE;

	  for (let i = 0; i < signature.length; i++) {
	    if (data[i] !== signature[i]) {
	      this.error(new Error("Invalid file signature"));
	      return;
	    }
	  }
	  this.read(8, this._parseChunkBegin.bind(this));
	};

	Parser.prototype._parseChunkBegin = function (data) {
	  // chunk content length
	  let length = data.readUInt32BE(0);

	  // chunk type
	  let type = data.readUInt32BE(4);
	  let name = "";
	  for (let i = 4; i < 8; i++) {
	    name += String.fromCharCode(data[i]);
	  }

	  //console.log('chunk ', name, length);

	  // chunk flags
	  let ancillary = Boolean(data[4] & 0x20); // or critical
	  //    priv = Boolean(data[5] & 0x20), // or public
	  //    safeToCopy = Boolean(data[7] & 0x20); // or unsafe

	  if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
	    this.error(new Error("Expected IHDR on beggining"));
	    return;
	  }

	  this._crc = new CrcCalculator();
	  this._crc.write(Buffer.from(name));

	  if (this._chunks[type]) {
	    return this._chunks[type](length);
	  }

	  if (!ancillary) {
	    this.error(new Error("Unsupported critical chunk type " + name));
	    return;
	  }

	  this.read(length + 4, this._skipChunk.bind(this));
	};

	Parser.prototype._skipChunk = function (/*data*/) {
	  this.read(8, this._parseChunkBegin.bind(this));
	};

	Parser.prototype._handleChunkEnd = function () {
	  this.read(4, this._parseChunkEnd.bind(this));
	};

	Parser.prototype._parseChunkEnd = function (data) {
	  let fileCrc = data.readInt32BE(0);
	  let calcCrc = this._crc.crc32();

	  // check CRC
	  if (this._options.checkCRC && calcCrc !== fileCrc) {
	    this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
	    return;
	  }

	  if (!this._hasIEND) {
	    this.read(8, this._parseChunkBegin.bind(this));
	  }
	};

	Parser.prototype._handleIHDR = function (length) {
	  this.read(length, this._parseIHDR.bind(this));
	};
	Parser.prototype._parseIHDR = function (data) {
	  this._crc.write(data);

	  let width = data.readUInt32BE(0);
	  let height = data.readUInt32BE(4);
	  let depth = data[8];
	  let colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
	  let compr = data[10];
	  let filter = data[11];
	  let interlace = data[12];

	  // console.log('    width', width, 'height', height,
	  //     'depth', depth, 'colorType', colorType,
	  //     'compr', compr, 'filter', filter, 'interlace', interlace
	  // );

	  if (
	    depth !== 8 &&
	    depth !== 4 &&
	    depth !== 2 &&
	    depth !== 1 &&
	    depth !== 16
	  ) {
	    this.error(new Error("Unsupported bit depth " + depth));
	    return;
	  }
	  if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
	    this.error(new Error("Unsupported color type"));
	    return;
	  }
	  if (compr !== 0) {
	    this.error(new Error("Unsupported compression method"));
	    return;
	  }
	  if (filter !== 0) {
	    this.error(new Error("Unsupported filter method"));
	    return;
	  }
	  if (interlace !== 0 && interlace !== 1) {
	    this.error(new Error("Unsupported interlace method"));
	    return;
	  }

	  this._colorType = colorType;

	  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];

	  this._hasIHDR = true;

	  this.metadata({
	    width: width,
	    height: height,
	    depth: depth,
	    interlace: Boolean(interlace),
	    palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
	    color: Boolean(colorType & constants.COLORTYPE_COLOR),
	    alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
	    bpp: bpp,
	    colorType: colorType,
	  });

	  this._handleChunkEnd();
	};

	Parser.prototype._handlePLTE = function (length) {
	  this.read(length, this._parsePLTE.bind(this));
	};
	Parser.prototype._parsePLTE = function (data) {
	  this._crc.write(data);

	  let entries = Math.floor(data.length / 3);
	  // console.log('Palette:', entries);

	  for (let i = 0; i < entries; i++) {
	    this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 0xff]);
	  }

	  this.palette(this._palette);

	  this._handleChunkEnd();
	};

	Parser.prototype._handleTRNS = function (length) {
	  this.simpleTransparency();
	  this.read(length, this._parseTRNS.bind(this));
	};
	Parser.prototype._parseTRNS = function (data) {
	  this._crc.write(data);

	  // palette
	  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
	    if (this._palette.length === 0) {
	      this.error(new Error("Transparency chunk must be after palette"));
	      return;
	    }
	    if (data.length > this._palette.length) {
	      this.error(new Error("More transparent colors than palette size"));
	      return;
	    }
	    for (let i = 0; i < data.length; i++) {
	      this._palette[i][3] = data[i];
	    }
	    this.palette(this._palette);
	  }

	  // for colorType 0 (grayscale) and 2 (rgb)
	  // there might be one gray/color defined as transparent
	  if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
	    // grey, 2 bytes
	    this.transColor([data.readUInt16BE(0)]);
	  }
	  if (this._colorType === constants.COLORTYPE_COLOR) {
	    this.transColor([
	      data.readUInt16BE(0),
	      data.readUInt16BE(2),
	      data.readUInt16BE(4),
	    ]);
	  }

	  this._handleChunkEnd();
	};

	Parser.prototype._handleGAMA = function (length) {
	  this.read(length, this._parseGAMA.bind(this));
	};
	Parser.prototype._parseGAMA = function (data) {
	  this._crc.write(data);
	  this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);

	  this._handleChunkEnd();
	};

	Parser.prototype._handleIDAT = function (length) {
	  if (!this._emittedHeadersFinished) {
	    this._emittedHeadersFinished = true;
	    this.headersFinished();
	  }
	  this.read(-length, this._parseIDAT.bind(this, length));
	};
	Parser.prototype._parseIDAT = function (length, data) {
	  this._crc.write(data);

	  if (
	    this._colorType === constants.COLORTYPE_PALETTE_COLOR &&
	    this._palette.length === 0
	  ) {
	    throw new Error("Expected palette not found");
	  }

	  this.inflateData(data);
	  let leftOverLength = length - data.length;

	  if (leftOverLength > 0) {
	    this._handleIDAT(leftOverLength);
	  } else {
	    this._handleChunkEnd();
	  }
	};

	Parser.prototype._handleIEND = function (length) {
	  this.read(length, this._parseIEND.bind(this));
	};
	Parser.prototype._parseIEND = function (data) {
	  this._crc.write(data);

	  this._hasIEND = true;
	  this._handleChunkEnd();

	  if (this.finished) {
	    this.finished();
	  }
	};
	return parser$1.exports;
}

var bitmapper = {};

var hasRequiredBitmapper;

function requireBitmapper () {
	if (hasRequiredBitmapper) return bitmapper;
	hasRequiredBitmapper = 1;

	let interlaceUtils = requireInterlace();

	let pixelBppMapper = [
	  // 0 - dummy entry
	  function () {},

	  // 1 - L
	  // 0: 0, 1: 0, 2: 0, 3: 0xff
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos === data.length) {
	      throw new Error("Ran out of data");
	    }

	    let pixel = data[rawPos];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = 0xff;
	  },

	  // 2 - LA
	  // 0: 0, 1: 0, 2: 0, 3: 1
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos + 1 >= data.length) {
	      throw new Error("Ran out of data");
	    }

	    let pixel = data[rawPos];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = data[rawPos + 1];
	  },

	  // 3 - RGB
	  // 0: 0, 1: 1, 2: 2, 3: 0xff
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos + 2 >= data.length) {
	      throw new Error("Ran out of data");
	    }

	    pxData[pxPos] = data[rawPos];
	    pxData[pxPos + 1] = data[rawPos + 1];
	    pxData[pxPos + 2] = data[rawPos + 2];
	    pxData[pxPos + 3] = 0xff;
	  },

	  // 4 - RGBA
	  // 0: 0, 1: 1, 2: 2, 3: 3
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos + 3 >= data.length) {
	      throw new Error("Ran out of data");
	    }

	    pxData[pxPos] = data[rawPos];
	    pxData[pxPos + 1] = data[rawPos + 1];
	    pxData[pxPos + 2] = data[rawPos + 2];
	    pxData[pxPos + 3] = data[rawPos + 3];
	  },
	];

	let pixelBppCustomMapper = [
	  // 0 - dummy entry
	  function () {},

	  // 1 - L
	  // 0: 0, 1: 0, 2: 0, 3: 0xff
	  function (pxData, pixelData, pxPos, maxBit) {
	    let pixel = pixelData[0];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = maxBit;
	  },

	  // 2 - LA
	  // 0: 0, 1: 0, 2: 0, 3: 1
	  function (pxData, pixelData, pxPos) {
	    let pixel = pixelData[0];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = pixelData[1];
	  },

	  // 3 - RGB
	  // 0: 0, 1: 1, 2: 2, 3: 0xff
	  function (pxData, pixelData, pxPos, maxBit) {
	    pxData[pxPos] = pixelData[0];
	    pxData[pxPos + 1] = pixelData[1];
	    pxData[pxPos + 2] = pixelData[2];
	    pxData[pxPos + 3] = maxBit;
	  },

	  // 4 - RGBA
	  // 0: 0, 1: 1, 2: 2, 3: 3
	  function (pxData, pixelData, pxPos) {
	    pxData[pxPos] = pixelData[0];
	    pxData[pxPos + 1] = pixelData[1];
	    pxData[pxPos + 2] = pixelData[2];
	    pxData[pxPos + 3] = pixelData[3];
	  },
	];

	function bitRetriever(data, depth) {
	  let leftOver = [];
	  let i = 0;

	  function split() {
	    if (i === data.length) {
	      throw new Error("Ran out of data");
	    }
	    let byte = data[i];
	    i++;
	    let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
	    switch (depth) {
	      default:
	        throw new Error("unrecognised depth");
	      case 16:
	        byte2 = data[i];
	        i++;
	        leftOver.push((byte << 8) + byte2);
	        break;
	      case 4:
	        byte2 = byte & 0x0f;
	        byte1 = byte >> 4;
	        leftOver.push(byte1, byte2);
	        break;
	      case 2:
	        byte4 = byte & 3;
	        byte3 = (byte >> 2) & 3;
	        byte2 = (byte >> 4) & 3;
	        byte1 = (byte >> 6) & 3;
	        leftOver.push(byte1, byte2, byte3, byte4);
	        break;
	      case 1:
	        byte8 = byte & 1;
	        byte7 = (byte >> 1) & 1;
	        byte6 = (byte >> 2) & 1;
	        byte5 = (byte >> 3) & 1;
	        byte4 = (byte >> 4) & 1;
	        byte3 = (byte >> 5) & 1;
	        byte2 = (byte >> 6) & 1;
	        byte1 = (byte >> 7) & 1;
	        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
	        break;
	    }
	  }

	  return {
	    get: function (count) {
	      while (leftOver.length < count) {
	        split();
	      }
	      let returner = leftOver.slice(0, count);
	      leftOver = leftOver.slice(count);
	      return returner;
	    },
	    resetAfterLine: function () {
	      leftOver.length = 0;
	    },
	    end: function () {
	      if (i !== data.length) {
	        throw new Error("extra data found");
	      }
	    },
	  };
	}

	function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
	  // eslint-disable-line max-params
	  let imageWidth = image.width;
	  let imageHeight = image.height;
	  let imagePass = image.index;
	  for (let y = 0; y < imageHeight; y++) {
	    for (let x = 0; x < imageWidth; x++) {
	      let pxPos = getPxPos(x, y, imagePass);
	      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
	      rawPos += bpp; //eslint-disable-line no-param-reassign
	    }
	  }
	  return rawPos;
	}

	function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
	  // eslint-disable-line max-params
	  let imageWidth = image.width;
	  let imageHeight = image.height;
	  let imagePass = image.index;
	  for (let y = 0; y < imageHeight; y++) {
	    for (let x = 0; x < imageWidth; x++) {
	      let pixelData = bits.get(bpp);
	      let pxPos = getPxPos(x, y, imagePass);
	      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
	    }
	    bits.resetAfterLine();
	  }
	}

	bitmapper.dataToBitMap = function (data, bitmapInfo) {
	  let width = bitmapInfo.width;
	  let height = bitmapInfo.height;
	  let depth = bitmapInfo.depth;
	  let bpp = bitmapInfo.bpp;
	  let interlace = bitmapInfo.interlace;
	  let bits;

	  if (depth !== 8) {
	    bits = bitRetriever(data, depth);
	  }
	  let pxData;
	  if (depth <= 8) {
	    pxData = Buffer.alloc(width * height * 4);
	  } else {
	    pxData = new Uint16Array(width * height * 4);
	  }
	  let maxBit = Math.pow(2, depth) - 1;
	  let rawPos = 0;
	  let images;
	  let getPxPos;

	  if (interlace) {
	    images = interlaceUtils.getImagePasses(width, height);
	    getPxPos = interlaceUtils.getInterlaceIterator(width, height);
	  } else {
	    let nonInterlacedPxPos = 0;
	    getPxPos = function () {
	      let returner = nonInterlacedPxPos;
	      nonInterlacedPxPos += 4;
	      return returner;
	    };
	    images = [{ width: width, height: height }];
	  }

	  for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
	    if (depth === 8) {
	      rawPos = mapImage8Bit(
	        images[imageIndex],
	        pxData,
	        getPxPos,
	        bpp,
	        data,
	        rawPos
	      );
	    } else {
	      mapImageCustomBit(
	        images[imageIndex],
	        pxData,
	        getPxPos,
	        bpp,
	        bits,
	        maxBit
	      );
	    }
	  }
	  if (depth === 8) {
	    if (rawPos !== data.length) {
	      throw new Error("extra data found");
	    }
	  } else {
	    bits.end();
	  }

	  return pxData;
	};
	return bitmapper;
}

var formatNormaliser;
var hasRequiredFormatNormaliser;

function requireFormatNormaliser () {
	if (hasRequiredFormatNormaliser) return formatNormaliser;
	hasRequiredFormatNormaliser = 1;

	function dePalette(indata, outdata, width, height, palette) {
	  let pxPos = 0;
	  // use values from palette
	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      let color = palette[indata[pxPos]];

	      if (!color) {
	        throw new Error("index " + indata[pxPos] + " not in palette");
	      }

	      for (let i = 0; i < 4; i++) {
	        outdata[pxPos + i] = color[i];
	      }
	      pxPos += 4;
	    }
	  }
	}

	function replaceTransparentColor(indata, outdata, width, height, transColor) {
	  let pxPos = 0;
	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      let makeTrans = false;

	      if (transColor.length === 1) {
	        if (transColor[0] === indata[pxPos]) {
	          makeTrans = true;
	        }
	      } else if (
	        transColor[0] === indata[pxPos] &&
	        transColor[1] === indata[pxPos + 1] &&
	        transColor[2] === indata[pxPos + 2]
	      ) {
	        makeTrans = true;
	      }
	      if (makeTrans) {
	        for (let i = 0; i < 4; i++) {
	          outdata[pxPos + i] = 0;
	        }
	      }
	      pxPos += 4;
	    }
	  }
	}

	function scaleDepth(indata, outdata, width, height, depth) {
	  let maxOutSample = 255;
	  let maxInSample = Math.pow(2, depth) - 1;
	  let pxPos = 0;

	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      for (let i = 0; i < 4; i++) {
	        outdata[pxPos + i] = Math.floor(
	          (indata[pxPos + i] * maxOutSample) / maxInSample + 0.5
	        );
	      }
	      pxPos += 4;
	    }
	  }
	}

	formatNormaliser = function (indata, imageData, skipRescale = false) {
	  let depth = imageData.depth;
	  let width = imageData.width;
	  let height = imageData.height;
	  let colorType = imageData.colorType;
	  let transColor = imageData.transColor;
	  let palette = imageData.palette;

	  let outdata = indata; // only different for 16 bits

	  if (colorType === 3) {
	    // paletted
	    dePalette(indata, outdata, width, height, palette);
	  } else {
	    if (transColor) {
	      replaceTransparentColor(indata, outdata, width, height, transColor);
	    }
	    // if it needs scaling
	    if (depth !== 8 && !skipRescale) {
	      // if we need to change the buffer size
	      if (depth === 16) {
	        outdata = Buffer.alloc(width * height * 4);
	      }
	      scaleDepth(indata, outdata, width, height, depth);
	    }
	  }
	  return outdata;
	};
	return formatNormaliser;
}

var hasRequiredParserAsync;

function requireParserAsync () {
	if (hasRequiredParserAsync) return parserAsync.exports;
	hasRequiredParserAsync = 1;

	let util = require$$0;
	let zlib = require$$1$1;
	let ChunkStream = requireChunkstream();
	let FilterAsync = requireFilterParseAsync();
	let Parser = requireParser$1();
	let bitmapper = requireBitmapper();
	let formatNormaliser = requireFormatNormaliser();

	let ParserAsync = (parserAsync.exports = function (options) {
	  ChunkStream.call(this);

	  this._parser = new Parser(options, {
	    read: this.read.bind(this),
	    error: this._handleError.bind(this),
	    metadata: this._handleMetaData.bind(this),
	    gamma: this.emit.bind(this, "gamma"),
	    palette: this._handlePalette.bind(this),
	    transColor: this._handleTransColor.bind(this),
	    finished: this._finished.bind(this),
	    inflateData: this._inflateData.bind(this),
	    simpleTransparency: this._simpleTransparency.bind(this),
	    headersFinished: this._headersFinished.bind(this),
	  });
	  this._options = options;
	  this.writable = true;

	  this._parser.start();
	});
	util.inherits(ParserAsync, ChunkStream);

	ParserAsync.prototype._handleError = function (err) {
	  this.emit("error", err);

	  this.writable = false;

	  this.destroy();

	  if (this._inflate && this._inflate.destroy) {
	    this._inflate.destroy();
	  }

	  if (this._filter) {
	    this._filter.destroy();
	    // For backward compatibility with Node 7 and below.
	    // Suppress errors due to _inflate calling write() even after
	    // it's destroy()'ed.
	    this._filter.on("error", function () {});
	  }

	  this.errord = true;
	};

	ParserAsync.prototype._inflateData = function (data) {
	  if (!this._inflate) {
	    if (this._bitmapInfo.interlace) {
	      this._inflate = zlib.createInflate();

	      this._inflate.on("error", this.emit.bind(this, "error"));
	      this._filter.on("complete", this._complete.bind(this));

	      this._inflate.pipe(this._filter);
	    } else {
	      let rowSize =
	        ((this._bitmapInfo.width *
	          this._bitmapInfo.bpp *
	          this._bitmapInfo.depth +
	          7) >>
	          3) +
	        1;
	      let imageSize = rowSize * this._bitmapInfo.height;
	      let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);

	      this._inflate = zlib.createInflate({ chunkSize: chunkSize });
	      let leftToInflate = imageSize;

	      let emitError = this.emit.bind(this, "error");
	      this._inflate.on("error", function (err) {
	        if (!leftToInflate) {
	          return;
	        }

	        emitError(err);
	      });
	      this._filter.on("complete", this._complete.bind(this));

	      let filterWrite = this._filter.write.bind(this._filter);
	      this._inflate.on("data", function (chunk) {
	        if (!leftToInflate) {
	          return;
	        }

	        if (chunk.length > leftToInflate) {
	          chunk = chunk.slice(0, leftToInflate);
	        }

	        leftToInflate -= chunk.length;

	        filterWrite(chunk);
	      });

	      this._inflate.on("end", this._filter.end.bind(this._filter));
	    }
	  }
	  this._inflate.write(data);
	};

	ParserAsync.prototype._handleMetaData = function (metaData) {
	  this._metaData = metaData;
	  this._bitmapInfo = Object.create(metaData);

	  this._filter = new FilterAsync(this._bitmapInfo);
	};

	ParserAsync.prototype._handleTransColor = function (transColor) {
	  this._bitmapInfo.transColor = transColor;
	};

	ParserAsync.prototype._handlePalette = function (palette) {
	  this._bitmapInfo.palette = palette;
	};

	ParserAsync.prototype._simpleTransparency = function () {
	  this._metaData.alpha = true;
	};

	ParserAsync.prototype._headersFinished = function () {
	  // Up until this point, we don't know if we have a tRNS chunk (alpha)
	  // so we can't emit metadata any earlier
	  this.emit("metadata", this._metaData);
	};

	ParserAsync.prototype._finished = function () {
	  if (this.errord) {
	    return;
	  }

	  if (!this._inflate) {
	    this.emit("error", "No Inflate block");
	  } else {
	    // no more data to inflate
	    this._inflate.end();
	  }
	};

	ParserAsync.prototype._complete = function (filteredData) {
	  if (this.errord) {
	    return;
	  }

	  let normalisedBitmapData;

	  try {
	    let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);

	    normalisedBitmapData = formatNormaliser(
	      bitmapData,
	      this._bitmapInfo,
	      this._options.skipRescale
	    );
	    bitmapData = null;
	  } catch (ex) {
	    this._handleError(ex);
	    return;
	  }

	  this.emit("parsed", normalisedBitmapData);
	};
	return parserAsync.exports;
}

var packerAsync = {exports: {}};

var packer = {exports: {}};

var bitpacker;
var hasRequiredBitpacker;

function requireBitpacker () {
	if (hasRequiredBitpacker) return bitpacker;
	hasRequiredBitpacker = 1;

	let constants = requireConstants$1();

	bitpacker = function (dataIn, width, height, options) {
	  let outHasAlpha =
	    [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(
	      options.colorType
	    ) !== -1;
	  if (options.colorType === options.inputColorType) {
	    let bigEndian = (function () {
	      let buffer = new ArrayBuffer(2);
	      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
	      // Int16Array uses the platform's endianness.
	      return new Int16Array(buffer)[0] !== 256;
	    })();
	    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route
	    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {
	      return dataIn;
	    }
	  }

	  // map to a UInt16 array if data is 16bit, fix endianness below
	  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);

	  let maxValue = 255;
	  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
	  if (inBpp === 4 && !options.inputHasAlpha) {
	    inBpp = 3;
	  }
	  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
	  if (options.bitDepth === 16) {
	    maxValue = 65535;
	    outBpp *= 2;
	  }
	  let outData = Buffer.alloc(width * height * outBpp);

	  let inIndex = 0;
	  let outIndex = 0;

	  let bgColor = options.bgColor || {};
	  if (bgColor.red === undefined) {
	    bgColor.red = maxValue;
	  }
	  if (bgColor.green === undefined) {
	    bgColor.green = maxValue;
	  }
	  if (bgColor.blue === undefined) {
	    bgColor.blue = maxValue;
	  }

	  function getRGBA() {
	    let red;
	    let green;
	    let blue;
	    let alpha = maxValue;
	    switch (options.inputColorType) {
	      case constants.COLORTYPE_COLOR_ALPHA:
	        alpha = data[inIndex + 3];
	        red = data[inIndex];
	        green = data[inIndex + 1];
	        blue = data[inIndex + 2];
	        break;
	      case constants.COLORTYPE_COLOR:
	        red = data[inIndex];
	        green = data[inIndex + 1];
	        blue = data[inIndex + 2];
	        break;
	      case constants.COLORTYPE_ALPHA:
	        alpha = data[inIndex + 1];
	        red = data[inIndex];
	        green = red;
	        blue = red;
	        break;
	      case constants.COLORTYPE_GRAYSCALE:
	        red = data[inIndex];
	        green = red;
	        blue = red;
	        break;
	      default:
	        throw new Error(
	          "input color type:" +
	            options.inputColorType +
	            " is not supported at present"
	        );
	    }

	    if (options.inputHasAlpha) {
	      if (!outHasAlpha) {
	        alpha /= maxValue;
	        red = Math.min(
	          Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
	          maxValue
	        );
	        green = Math.min(
	          Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
	          maxValue
	        );
	        blue = Math.min(
	          Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
	          maxValue
	        );
	      }
	    }
	    return { red: red, green: green, blue: blue, alpha: alpha };
	  }

	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      let rgba = getRGBA();

	      switch (options.colorType) {
	        case constants.COLORTYPE_COLOR_ALPHA:
	        case constants.COLORTYPE_COLOR:
	          if (options.bitDepth === 8) {
	            outData[outIndex] = rgba.red;
	            outData[outIndex + 1] = rgba.green;
	            outData[outIndex + 2] = rgba.blue;
	            if (outHasAlpha) {
	              outData[outIndex + 3] = rgba.alpha;
	            }
	          } else {
	            outData.writeUInt16BE(rgba.red, outIndex);
	            outData.writeUInt16BE(rgba.green, outIndex + 2);
	            outData.writeUInt16BE(rgba.blue, outIndex + 4);
	            if (outHasAlpha) {
	              outData.writeUInt16BE(rgba.alpha, outIndex + 6);
	            }
	          }
	          break;
	        case constants.COLORTYPE_ALPHA:
	        case constants.COLORTYPE_GRAYSCALE: {
	          // Convert to grayscale and alpha
	          let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
	          if (options.bitDepth === 8) {
	            outData[outIndex] = grayscale;
	            if (outHasAlpha) {
	              outData[outIndex + 1] = rgba.alpha;
	            }
	          } else {
	            outData.writeUInt16BE(grayscale, outIndex);
	            if (outHasAlpha) {
	              outData.writeUInt16BE(rgba.alpha, outIndex + 2);
	            }
	          }
	          break;
	        }
	        default:
	          throw new Error("unrecognised color Type " + options.colorType);
	      }

	      inIndex += inBpp;
	      outIndex += outBpp;
	    }
	  }

	  return outData;
	};
	return bitpacker;
}

var filterPack;
var hasRequiredFilterPack;

function requireFilterPack () {
	if (hasRequiredFilterPack) return filterPack;
	hasRequiredFilterPack = 1;

	let paethPredictor = requirePaethPredictor();

	function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
	  for (let x = 0; x < byteWidth; x++) {
	    rawData[rawPos + x] = pxData[pxPos + x];
	  }
	}

	function filterSumNone(pxData, pxPos, byteWidth) {
	  let sum = 0;
	  let length = pxPos + byteWidth;

	  for (let i = pxPos; i < length; i++) {
	    sum += Math.abs(pxData[i]);
	  }
	  return sum;
	}

	function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let val = pxData[pxPos + x] - left;

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumSub(pxData, pxPos, byteWidth, bpp) {
	  let sum = 0;
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let val = pxData[pxPos + x] - left;

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
	  for (let x = 0; x < byteWidth; x++) {
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let val = pxData[pxPos + x] - up;

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumUp(pxData, pxPos, byteWidth) {
	  let sum = 0;
	  let length = pxPos + byteWidth;
	  for (let x = pxPos; x < length; x++) {
	    let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
	    let val = pxData[x] - up;

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let val = pxData[pxPos + x] - ((left + up) >> 1);

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
	  let sum = 0;
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let val = pxData[pxPos + x] - ((left + up) >> 1);

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let upleft =
	      pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
	    let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
	  let sum = 0;
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let upleft =
	      pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
	    let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	let filters = {
	  0: filterNone,
	  1: filterSub,
	  2: filterUp,
	  3: filterAvg,
	  4: filterPaeth,
	};

	let filterSums = {
	  0: filterSumNone,
	  1: filterSumSub,
	  2: filterSumUp,
	  3: filterSumAvg,
	  4: filterSumPaeth,
	};

	filterPack = function (pxData, width, height, options, bpp) {
	  let filterTypes;
	  if (!("filterType" in options) || options.filterType === -1) {
	    filterTypes = [0, 1, 2, 3, 4];
	  } else if (typeof options.filterType === "number") {
	    filterTypes = [options.filterType];
	  } else {
	    throw new Error("unrecognised filter types");
	  }

	  if (options.bitDepth === 16) {
	    bpp *= 2;
	  }
	  let byteWidth = width * bpp;
	  let rawPos = 0;
	  let pxPos = 0;
	  let rawData = Buffer.alloc((byteWidth + 1) * height);

	  let sel = filterTypes[0];

	  for (let y = 0; y < height; y++) {
	    if (filterTypes.length > 1) {
	      // find best filter for this line (with lowest sum of values)
	      let min = Infinity;

	      for (let i = 0; i < filterTypes.length; i++) {
	        let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
	        if (sum < min) {
	          sel = filterTypes[i];
	          min = sum;
	        }
	      }
	    }

	    rawData[rawPos] = sel;
	    rawPos++;
	    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
	    rawPos += byteWidth;
	    pxPos += byteWidth;
	  }
	  return rawData;
	};
	return filterPack;
}

var hasRequiredPacker;

function requirePacker () {
	if (hasRequiredPacker) return packer.exports;
	hasRequiredPacker = 1;

	let constants = requireConstants$1();
	let CrcStream = requireCrc();
	let bitPacker = requireBitpacker();
	let filter = requireFilterPack();
	let zlib = require$$1$1;

	let Packer = (packer.exports = function (options) {
	  this._options = options;

	  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
	  options.deflateLevel =
	    options.deflateLevel != null ? options.deflateLevel : 9;
	  options.deflateStrategy =
	    options.deflateStrategy != null ? options.deflateStrategy : 3;
	  options.inputHasAlpha =
	    options.inputHasAlpha != null ? options.inputHasAlpha : true;
	  options.deflateFactory = options.deflateFactory || zlib.createDeflate;
	  options.bitDepth = options.bitDepth || 8;
	  // This is outputColorType
	  options.colorType =
	    typeof options.colorType === "number"
	      ? options.colorType
	      : constants.COLORTYPE_COLOR_ALPHA;
	  options.inputColorType =
	    typeof options.inputColorType === "number"
	      ? options.inputColorType
	      : constants.COLORTYPE_COLOR_ALPHA;

	  if (
	    [
	      constants.COLORTYPE_GRAYSCALE,
	      constants.COLORTYPE_COLOR,
	      constants.COLORTYPE_COLOR_ALPHA,
	      constants.COLORTYPE_ALPHA,
	    ].indexOf(options.colorType) === -1
	  ) {
	    throw new Error(
	      "option color type:" + options.colorType + " is not supported at present"
	    );
	  }
	  if (
	    [
	      constants.COLORTYPE_GRAYSCALE,
	      constants.COLORTYPE_COLOR,
	      constants.COLORTYPE_COLOR_ALPHA,
	      constants.COLORTYPE_ALPHA,
	    ].indexOf(options.inputColorType) === -1
	  ) {
	    throw new Error(
	      "option input color type:" +
	        options.inputColorType +
	        " is not supported at present"
	    );
	  }
	  if (options.bitDepth !== 8 && options.bitDepth !== 16) {
	    throw new Error(
	      "option bit depth:" + options.bitDepth + " is not supported at present"
	    );
	  }
	});

	Packer.prototype.getDeflateOptions = function () {
	  return {
	    chunkSize: this._options.deflateChunkSize,
	    level: this._options.deflateLevel,
	    strategy: this._options.deflateStrategy,
	  };
	};

	Packer.prototype.createDeflate = function () {
	  return this._options.deflateFactory(this.getDeflateOptions());
	};

	Packer.prototype.filterData = function (data, width, height) {
	  // convert to correct format for filtering (e.g. right bpp and bit depth)
	  let packedData = bitPacker(data, width, height, this._options);

	  // filter pixel data
	  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
	  let filteredData = filter(packedData, width, height, this._options, bpp);
	  return filteredData;
	};

	Packer.prototype._packChunk = function (type, data) {
	  let len = data ? data.length : 0;
	  let buf = Buffer.alloc(len + 12);

	  buf.writeUInt32BE(len, 0);
	  buf.writeUInt32BE(type, 4);

	  if (data) {
	    data.copy(buf, 8);
	  }

	  buf.writeInt32BE(
	    CrcStream.crc32(buf.slice(4, buf.length - 4)),
	    buf.length - 4
	  );
	  return buf;
	};

	Packer.prototype.packGAMA = function (gamma) {
	  let buf = Buffer.alloc(4);
	  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
	  return this._packChunk(constants.TYPE_gAMA, buf);
	};

	Packer.prototype.packIHDR = function (width, height) {
	  let buf = Buffer.alloc(13);
	  buf.writeUInt32BE(width, 0);
	  buf.writeUInt32BE(height, 4);
	  buf[8] = this._options.bitDepth; // Bit depth
	  buf[9] = this._options.colorType; // colorType
	  buf[10] = 0; // compression
	  buf[11] = 0; // filter
	  buf[12] = 0; // interlace

	  return this._packChunk(constants.TYPE_IHDR, buf);
	};

	Packer.prototype.packIDAT = function (data) {
	  return this._packChunk(constants.TYPE_IDAT, data);
	};

	Packer.prototype.packIEND = function () {
	  return this._packChunk(constants.TYPE_IEND, null);
	};
	return packer.exports;
}

var hasRequiredPackerAsync;

function requirePackerAsync () {
	if (hasRequiredPackerAsync) return packerAsync.exports;
	hasRequiredPackerAsync = 1;

	let util = require$$0;
	let Stream = require$$1;
	let constants = requireConstants$1();
	let Packer = requirePacker();

	let PackerAsync = (packerAsync.exports = function (opt) {
	  Stream.call(this);

	  let options = opt || {};

	  this._packer = new Packer(options);
	  this._deflate = this._packer.createDeflate();

	  this.readable = true;
	});
	util.inherits(PackerAsync, Stream);

	PackerAsync.prototype.pack = function (data, width, height, gamma) {
	  // Signature
	  this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
	  this.emit("data", this._packer.packIHDR(width, height));

	  if (gamma) {
	    this.emit("data", this._packer.packGAMA(gamma));
	  }

	  let filteredData = this._packer.filterData(data, width, height);

	  // compress it
	  this._deflate.on("error", this.emit.bind(this, "error"));

	  this._deflate.on(
	    "data",
	    function (compressedData) {
	      this.emit("data", this._packer.packIDAT(compressedData));
	    }.bind(this)
	  );

	  this._deflate.on(
	    "end",
	    function () {
	      this.emit("data", this._packer.packIEND());
	      this.emit("end");
	    }.bind(this)
	  );

	  this._deflate.end(filteredData);
	};
	return packerAsync.exports;
}

var pngSync = {};

var syncInflate = {exports: {}};

var hasRequiredSyncInflate;

function requireSyncInflate () {
	if (hasRequiredSyncInflate) return syncInflate.exports;
	hasRequiredSyncInflate = 1;
	(function (module, exports$1) {

		let assert = require$$0$1.ok;
		let zlib = require$$1$1;
		let util = require$$0;

		let kMaxLength = require$$3.kMaxLength;

		function Inflate(opts) {
		  if (!(this instanceof Inflate)) {
		    return new Inflate(opts);
		  }

		  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
		    opts.chunkSize = zlib.Z_MIN_CHUNK;
		  }

		  zlib.Inflate.call(this, opts);

		  // Node 8 --> 9 compatibility check
		  this._offset = this._offset === undefined ? this._outOffset : this._offset;
		  this._buffer = this._buffer || this._outBuffer;

		  if (opts && opts.maxLength != null) {
		    this._maxLength = opts.maxLength;
		  }
		}

		function createInflate(opts) {
		  return new Inflate(opts);
		}

		function _close(engine, callback) {

		  // Caller may invoke .close after a zlib error (which will null _handle).
		  if (!engine._handle) {
		    return;
		  }

		  engine._handle.close();
		  engine._handle = null;
		}

		Inflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {
		  if (typeof asyncCb === "function") {
		    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
		  }

		  let self = this;

		  let availInBefore = chunk && chunk.length;
		  let availOutBefore = this._chunkSize - this._offset;
		  let leftToInflate = this._maxLength;
		  let inOff = 0;

		  let buffers = [];
		  let nread = 0;

		  let error;
		  this.on("error", function (err) {
		    error = err;
		  });

		  function handleChunk(availInAfter, availOutAfter) {
		    if (self._hadError) {
		      return;
		    }

		    let have = availOutBefore - availOutAfter;
		    assert(have >= 0, "have should not go down");

		    if (have > 0) {
		      let out = self._buffer.slice(self._offset, self._offset + have);
		      self._offset += have;

		      if (out.length > leftToInflate) {
		        out = out.slice(0, leftToInflate);
		      }

		      buffers.push(out);
		      nread += out.length;
		      leftToInflate -= out.length;

		      if (leftToInflate === 0) {
		        return false;
		      }
		    }

		    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
		      availOutBefore = self._chunkSize;
		      self._offset = 0;
		      self._buffer = Buffer.allocUnsafe(self._chunkSize);
		    }

		    if (availOutAfter === 0) {
		      inOff += availInBefore - availInAfter;
		      availInBefore = availInAfter;

		      return true;
		    }

		    return false;
		  }

		  assert(this._handle, "zlib binding closed");
		  let res;
		  do {
		    res = this._handle.writeSync(
		      flushFlag,
		      chunk, // in
		      inOff, // in_off
		      availInBefore, // in_len
		      this._buffer, // out
		      this._offset, //out_off
		      availOutBefore
		    ); // out_len
		    // Node 8 --> 9 compatibility check
		    res = res || this._writeState;
		  } while (!this._hadError && handleChunk(res[0], res[1]));

		  if (this._hadError) {
		    throw error;
		  }

		  if (nread >= kMaxLength) {
		    _close(this);
		    throw new RangeError(
		      "Cannot create final Buffer. It would be larger than 0x" +
		        kMaxLength.toString(16) +
		        " bytes"
		    );
		  }

		  let buf = Buffer.concat(buffers, nread);
		  _close(this);

		  return buf;
		};

		util.inherits(Inflate, zlib.Inflate);

		function zlibBufferSync(engine, buffer) {
		  if (typeof buffer === "string") {
		    buffer = Buffer.from(buffer);
		  }
		  if (!(buffer instanceof Buffer)) {
		    throw new TypeError("Not a string or buffer");
		  }

		  let flushFlag = engine._finishFlushFlag;
		  if (flushFlag == null) {
		    flushFlag = zlib.Z_FINISH;
		  }

		  return engine._processChunk(buffer, flushFlag);
		}

		function inflateSync(buffer, opts) {
		  return zlibBufferSync(new Inflate(opts), buffer);
		}

		module.exports = exports$1 = inflateSync;
		exports$1.Inflate = Inflate;
		exports$1.createInflate = createInflate;
		exports$1.inflateSync = inflateSync; 
	} (syncInflate, syncInflate.exports));
	return syncInflate.exports;
}

var syncReader = {exports: {}};

var hasRequiredSyncReader;

function requireSyncReader () {
	if (hasRequiredSyncReader) return syncReader.exports;
	hasRequiredSyncReader = 1;

	let SyncReader = (syncReader.exports = function (buffer) {
	  this._buffer = buffer;
	  this._reads = [];
	});

	SyncReader.prototype.read = function (length, callback) {
	  this._reads.push({
	    length: Math.abs(length), // if length < 0 then at most this length
	    allowLess: length < 0,
	    func: callback,
	  });
	};

	SyncReader.prototype.process = function () {
	  // as long as there is any data and read requests
	  while (this._reads.length > 0 && this._buffer.length) {
	    let read = this._reads[0];

	    if (
	      this._buffer.length &&
	      (this._buffer.length >= read.length || read.allowLess)
	    ) {
	      // ok there is any data so that we can satisfy this request
	      this._reads.shift(); // == read

	      let buf = this._buffer;

	      this._buffer = buf.slice(read.length);

	      read.func.call(this, buf.slice(0, read.length));
	    } else {
	      break;
	    }
	  }

	  if (this._reads.length > 0) {
	    throw new Error("There are some read requests waitng on finished stream");
	  }

	  if (this._buffer.length > 0) {
	    throw new Error("unrecognised content at end of stream");
	  }
	};
	return syncReader.exports;
}

var filterParseSync = {};

var hasRequiredFilterParseSync;

function requireFilterParseSync () {
	if (hasRequiredFilterParseSync) return filterParseSync;
	hasRequiredFilterParseSync = 1;

	let SyncReader = requireSyncReader();
	let Filter = requireFilterParse();

	filterParseSync.process = function (inBuffer, bitmapInfo) {
	  let outBuffers = [];
	  let reader = new SyncReader(inBuffer);
	  let filter = new Filter(bitmapInfo, {
	    read: reader.read.bind(reader),
	    write: function (bufferPart) {
	      outBuffers.push(bufferPart);
	    },
	    complete: function () {},
	  });

	  filter.start();
	  reader.process();

	  return Buffer.concat(outBuffers);
	};
	return filterParseSync;
}

var parserSync;
var hasRequiredParserSync;

function requireParserSync () {
	if (hasRequiredParserSync) return parserSync;
	hasRequiredParserSync = 1;

	let hasSyncZlib = true;
	let zlib = require$$1$1;
	let inflateSync = requireSyncInflate();
	if (!zlib.deflateSync) {
	  hasSyncZlib = false;
	}
	let SyncReader = requireSyncReader();
	let FilterSync = requireFilterParseSync();
	let Parser = requireParser$1();
	let bitmapper = requireBitmapper();
	let formatNormaliser = requireFormatNormaliser();

	parserSync = function (buffer, options) {
	  if (!hasSyncZlib) {
	    throw new Error(
	      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
	    );
	  }

	  let err;
	  function handleError(_err_) {
	    err = _err_;
	  }

	  let metaData;
	  function handleMetaData(_metaData_) {
	    metaData = _metaData_;
	  }

	  function handleTransColor(transColor) {
	    metaData.transColor = transColor;
	  }

	  function handlePalette(palette) {
	    metaData.palette = palette;
	  }

	  function handleSimpleTransparency() {
	    metaData.alpha = true;
	  }

	  let gamma;
	  function handleGamma(_gamma_) {
	    gamma = _gamma_;
	  }

	  let inflateDataList = [];
	  function handleInflateData(inflatedData) {
	    inflateDataList.push(inflatedData);
	  }

	  let reader = new SyncReader(buffer);

	  let parser = new Parser(options, {
	    read: reader.read.bind(reader),
	    error: handleError,
	    metadata: handleMetaData,
	    gamma: handleGamma,
	    palette: handlePalette,
	    transColor: handleTransColor,
	    inflateData: handleInflateData,
	    simpleTransparency: handleSimpleTransparency,
	  });

	  parser.start();
	  reader.process();

	  if (err) {
	    throw err;
	  }

	  //join together the inflate datas
	  let inflateData = Buffer.concat(inflateDataList);
	  inflateDataList.length = 0;

	  let inflatedData;
	  if (metaData.interlace) {
	    inflatedData = zlib.inflateSync(inflateData);
	  } else {
	    let rowSize =
	      ((metaData.width * metaData.bpp * metaData.depth + 7) >> 3) + 1;
	    let imageSize = rowSize * metaData.height;
	    inflatedData = inflateSync(inflateData, {
	      chunkSize: imageSize,
	      maxLength: imageSize,
	    });
	  }
	  inflateData = null;

	  if (!inflatedData || !inflatedData.length) {
	    throw new Error("bad png - invalid inflate data response");
	  }

	  let unfilteredData = FilterSync.process(inflatedData, metaData);
	  inflateData = null;

	  let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
	  unfilteredData = null;

	  let normalisedBitmapData = formatNormaliser(
	    bitmapData,
	    metaData,
	    options.skipRescale
	  );

	  metaData.data = normalisedBitmapData;
	  metaData.gamma = gamma || 0;

	  return metaData;
	};
	return parserSync;
}

var packerSync;
var hasRequiredPackerSync;

function requirePackerSync () {
	if (hasRequiredPackerSync) return packerSync;
	hasRequiredPackerSync = 1;

	let hasSyncZlib = true;
	let zlib = require$$1$1;
	if (!zlib.deflateSync) {
	  hasSyncZlib = false;
	}
	let constants = requireConstants$1();
	let Packer = requirePacker();

	packerSync = function (metaData, opt) {
	  if (!hasSyncZlib) {
	    throw new Error(
	      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
	    );
	  }

	  let options = opt || {};

	  let packer = new Packer(options);

	  let chunks = [];

	  // Signature
	  chunks.push(Buffer.from(constants.PNG_SIGNATURE));

	  // Header
	  chunks.push(packer.packIHDR(metaData.width, metaData.height));

	  if (metaData.gamma) {
	    chunks.push(packer.packGAMA(metaData.gamma));
	  }

	  let filteredData = packer.filterData(
	    metaData.data,
	    metaData.width,
	    metaData.height
	  );

	  // compress it
	  let compressedData = zlib.deflateSync(
	    filteredData,
	    packer.getDeflateOptions()
	  );
	  filteredData = null;

	  if (!compressedData || !compressedData.length) {
	    throw new Error("bad png - invalid compressed data response");
	  }
	  chunks.push(packer.packIDAT(compressedData));

	  // End
	  chunks.push(packer.packIEND());

	  return Buffer.concat(chunks);
	};
	return packerSync;
}

var hasRequiredPngSync;

function requirePngSync () {
	if (hasRequiredPngSync) return pngSync;
	hasRequiredPngSync = 1;

	let parse = requireParserSync();
	let pack = requirePackerSync();

	pngSync.read = function (buffer, options) {
	  return parse(buffer, options || {});
	};

	pngSync.write = function (png, options) {
	  return pack(png, options);
	};
	return pngSync;
}

var hasRequiredPng;

function requirePng () {
	if (hasRequiredPng) return png$1;
	hasRequiredPng = 1;

	let util = require$$0;
	let Stream = require$$1;
	let Parser = requireParserAsync();
	let Packer = requirePackerAsync();
	let PNGSync = requirePngSync();

	let PNG = (png$1.PNG = function (options) {
	  Stream.call(this);

	  options = options || {}; // eslint-disable-line no-param-reassign

	  // coerce pixel dimensions to integers (also coerces undefined -> 0):
	  this.width = options.width | 0;
	  this.height = options.height | 0;

	  this.data =
	    this.width > 0 && this.height > 0
	      ? Buffer.alloc(4 * this.width * this.height)
	      : null;

	  if (options.fill && this.data) {
	    this.data.fill(0);
	  }

	  this.gamma = 0;
	  this.readable = this.writable = true;

	  this._parser = new Parser(options);

	  this._parser.on("error", this.emit.bind(this, "error"));
	  this._parser.on("close", this._handleClose.bind(this));
	  this._parser.on("metadata", this._metadata.bind(this));
	  this._parser.on("gamma", this._gamma.bind(this));
	  this._parser.on(
	    "parsed",
	    function (data) {
	      this.data = data;
	      this.emit("parsed", data);
	    }.bind(this)
	  );

	  this._packer = new Packer(options);
	  this._packer.on("data", this.emit.bind(this, "data"));
	  this._packer.on("end", this.emit.bind(this, "end"));
	  this._parser.on("close", this._handleClose.bind(this));
	  this._packer.on("error", this.emit.bind(this, "error"));
	});
	util.inherits(PNG, Stream);

	PNG.sync = PNGSync;

	PNG.prototype.pack = function () {
	  if (!this.data || !this.data.length) {
	    this.emit("error", "No data provided");
	    return this;
	  }

	  process.nextTick(
	    function () {
	      this._packer.pack(this.data, this.width, this.height, this.gamma);
	    }.bind(this)
	  );

	  return this;
	};

	PNG.prototype.parse = function (data, callback) {
	  if (callback) {
	    let onParsed, onError;

	    onParsed = function (parsedData) {
	      this.removeListener("error", onError);

	      this.data = parsedData;
	      callback(null, this);
	    }.bind(this);

	    onError = function (err) {
	      this.removeListener("parsed", onParsed);

	      callback(err, null);
	    }.bind(this);

	    this.once("parsed", onParsed);
	    this.once("error", onError);
	  }

	  this.end(data);
	  return this;
	};

	PNG.prototype.write = function (data) {
	  this._parser.write(data);
	  return true;
	};

	PNG.prototype.end = function (data) {
	  this._parser.end(data);
	};

	PNG.prototype._metadata = function (metadata) {
	  this.width = metadata.width;
	  this.height = metadata.height;

	  this.emit("metadata", metadata);
	};

	PNG.prototype._gamma = function (gamma) {
	  this.gamma = gamma;
	};

	PNG.prototype._handleClose = function () {
	  if (!this._parser.writable && !this._packer.readable) {
	    this.emit("close");
	  }
	};

	PNG.bitblt = function (src, dst, srcX, srcY, width, height, deltaX, deltaY) {
	  // eslint-disable-line max-params
	  // coerce pixel dimensions to integers (also coerces undefined -> 0):
	  /* eslint-disable no-param-reassign */
	  srcX |= 0;
	  srcY |= 0;
	  width |= 0;
	  height |= 0;
	  deltaX |= 0;
	  deltaY |= 0;
	  /* eslint-enable no-param-reassign */

	  if (
	    srcX > src.width ||
	    srcY > src.height ||
	    srcX + width > src.width ||
	    srcY + height > src.height
	  ) {
	    throw new Error("bitblt reading outside image");
	  }

	  if (
	    deltaX > dst.width ||
	    deltaY > dst.height ||
	    deltaX + width > dst.width ||
	    deltaY + height > dst.height
	  ) {
	    throw new Error("bitblt writing outside image");
	  }

	  for (let y = 0; y < height; y++) {
	    src.data.copy(
	      dst.data,
	      ((deltaY + y) * dst.width + deltaX) << 2,
	      ((srcY + y) * src.width + srcX) << 2,
	      ((srcY + y) * src.width + srcX + width) << 2
	    );
	  }
	};

	PNG.prototype.bitblt = function (
	  dst,
	  srcX,
	  srcY,
	  width,
	  height,
	  deltaX,
	  deltaY
	) {
	  // eslint-disable-line max-params

	  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
	  return this;
	};

	PNG.adjustGamma = function (src) {
	  if (src.gamma) {
	    for (let y = 0; y < src.height; y++) {
	      for (let x = 0; x < src.width; x++) {
	        let idx = (src.width * y + x) << 2;

	        for (let i = 0; i < 3; i++) {
	          let sample = src.data[idx + i] / 255;
	          sample = Math.pow(sample, 1 / 2.2 / src.gamma);
	          src.data[idx + i] = Math.round(sample * 255);
	        }
	      }
	    }
	    src.gamma = 0;
	  }
	};

	PNG.prototype.adjustGamma = function () {
	  PNG.adjustGamma(this);
	};
	return png$1;
}

var pngExports = requirePng();

/**
 * Filter method is a single-byte integer that indicates the preprocessing method applied to the image data before compression.
 */
var PNGFilterType;
(function (PNGFilterType) {
    PNGFilterType[PNGFilterType["AUTO"] = -1] = "AUTO";
    /** scanline is transmitted unmodified */
    PNGFilterType[PNGFilterType["NONE"] = 0] = "NONE";
    /** filter transmits the difference between each byte and the value of the corresponding byte of the prior pixel */
    PNGFilterType[PNGFilterType["SUB"] = 1] = "SUB";
    /** The Up() filter is just like the Sub() filter except that the pixel immediately above the current pixel, rather than just to its left, is used as the predictor. */
    PNGFilterType[PNGFilterType["UP"] = 2] = "UP";
    /** uses the average of the two neighboring pixels (left and above) to predict the value of a pixel */
    PNGFilterType[PNGFilterType["AVERAGE"] = 3] = "AVERAGE";
    /** computes a simple linear function of the three neighboring pixels (left, above, upper left), then chooses as predictor the neighboring pixel closest to the computed value. */
    PNGFilterType[PNGFilterType["PATH"] = 4] = "PATH";
})(PNGFilterType || (PNGFilterType = {}));
/**
 * Color type is a single-byte integer that describes the interpretation of the image data.
 * Color type codes represent sums of the following values:
 *
 * 1 (palette used), 2 (color used), and 4 (alpha channel used).
 */
var PNGColorType;
(function (PNGColorType) {
    PNGColorType[PNGColorType["GRAYSCALE"] = 0] = "GRAYSCALE";
    PNGColorType[PNGColorType["COLOR"] = 2] = "COLOR";
    PNGColorType[PNGColorType["GRAYSCALE_ALPHA"] = 4] = "GRAYSCALE_ALPHA";
    PNGColorType[PNGColorType["COLOR_ALPHA"] = 6] = "COLOR_ALPHA";
})(PNGColorType || (PNGColorType = {}));

function png() {
    return {
        mime: "image/png",
        hasAlpha: true,
        encode: (bitmap, { deflateLevel = 9, deflateStrategy = 3, filterType = PNGFilterType.AUTO, colorType, inputHasAlpha = true, ...options } = {}) => {
            const png = new pngExports.PNG({
                width: bitmap.width,
                height: bitmap.height,
            });
            png.data = bitmap.data;
            return pngExports.PNG.sync.write(png, {
                ...options,
                deflateLevel,
                deflateStrategy,
                filterType,
                colorType: typeof colorType !== "undefined"
                    ? colorType
                    : inputHasAlpha
                        ? PNGColorType.COLOR_ALPHA
                        : PNGColorType.COLOR,
                inputHasAlpha,
            });
        },
        decode: (data, options) => {
            const result = pngExports.PNG.sync.read(data, options);
            return {
                data: result.data,
                width: result.width,
                height: result.height,
            };
        },
    };
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var UTIF = {exports: {}};

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports$1) {


		var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
		                (typeof Uint16Array !== 'undefined') &&
		                (typeof Int32Array !== 'undefined');

		function _has(obj, key) {
		  return Object.prototype.hasOwnProperty.call(obj, key);
		}

		exports$1.assign = function (obj /*from1, from2, from3, ...*/) {
		  var sources = Array.prototype.slice.call(arguments, 1);
		  while (sources.length) {
		    var source = sources.shift();
		    if (!source) { continue; }

		    if (typeof source !== 'object') {
		      throw new TypeError(source + 'must be non-object');
		    }

		    for (var p in source) {
		      if (_has(source, p)) {
		        obj[p] = source[p];
		      }
		    }
		  }

		  return obj;
		};


		// reduce buffer size, avoiding mem copy
		exports$1.shrinkBuf = function (buf, size) {
		  if (buf.length === size) { return buf; }
		  if (buf.subarray) { return buf.subarray(0, size); }
		  buf.length = size;
		  return buf;
		};


		var fnTyped = {
		  arraySet: function (dest, src, src_offs, len, dest_offs) {
		    if (src.subarray && dest.subarray) {
		      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
		      return;
		    }
		    // Fallback to ordinary array
		    for (var i = 0; i < len; i++) {
		      dest[dest_offs + i] = src[src_offs + i];
		    }
		  },
		  // Join array of chunks to single array.
		  flattenChunks: function (chunks) {
		    var i, l, len, pos, chunk, result;

		    // calculate data length
		    len = 0;
		    for (i = 0, l = chunks.length; i < l; i++) {
		      len += chunks[i].length;
		    }

		    // join chunks
		    result = new Uint8Array(len);
		    pos = 0;
		    for (i = 0, l = chunks.length; i < l; i++) {
		      chunk = chunks[i];
		      result.set(chunk, pos);
		      pos += chunk.length;
		    }

		    return result;
		  }
		};

		var fnUntyped = {
		  arraySet: function (dest, src, src_offs, len, dest_offs) {
		    for (var i = 0; i < len; i++) {
		      dest[dest_offs + i] = src[src_offs + i];
		    }
		  },
		  // Join array of chunks to single array.
		  flattenChunks: function (chunks) {
		    return [].concat.apply([], chunks);
		  }
		};


		// Enable/Disable typed arrays use, for testing
		//
		exports$1.setTyped = function (on) {
		  if (on) {
		    exports$1.Buf8  = Uint8Array;
		    exports$1.Buf16 = Uint16Array;
		    exports$1.Buf32 = Int32Array;
		    exports$1.assign(exports$1, fnTyped);
		  } else {
		    exports$1.Buf8  = Array;
		    exports$1.Buf16 = Array;
		    exports$1.Buf32 = Array;
		    exports$1.assign(exports$1, fnUntyped);
		  }
		};

		exports$1.setTyped(TYPED_OK); 
	} (common));
	return common;
}

var deflate$1 = {};

var deflate = {};

var trees = {};

var hasRequiredTrees;

function requireTrees () {
	if (hasRequiredTrees) return trees;
	hasRequiredTrees = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	/* eslint-disable space-unary-ops */

	var utils = requireCommon();

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;

	/*============================================================================*/


	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */

	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS      = 256;
	/* number of literal bytes 0..255 */

	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES       = 30;
	/* number of distance codes */

	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */

	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */


	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK   = 256;
	/* end of block literal code */

	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* eslint-enable comma-spacing,array-bracket-spacing */

	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */


	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	}


	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;


	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	}



	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}


	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}


	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}


	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
	}


	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}


	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;

	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}


	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) { continue; } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
	        tree[m * 2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}


	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n * 2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}


	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1 << extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1 << extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }

	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1]/*.Len*/ = 5;
	    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

	  //static_init_done = true;
	}


	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

	  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}


	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */

	  {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}


	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;

	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");

	    } while (lx < s.last_lit);
	  }

	  send_code(s, END_BLOCK, ltree);
	}


	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;

	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;

	    } else {
	      tree[n * 2 + 1]/*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;

	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/

	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);

	  } while (s.heap_len >= 2);

	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}


	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;

	    } else if (curlen !== 0) {

	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

	    } else {
	      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;

	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);

	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);

	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}


	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1,   5);
	  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}


	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}


	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{

	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }

	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}


	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len); /* with header */
	}


	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}


	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {

	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
	    static_lenb = (s.static_len + 3 + 7) >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);

	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);

	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);

	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;

	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }

	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility

	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif

	  return (s.last_lit === s.lit_bufsize - 1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	trees._tr_init  = _tr_init;
	trees._tr_stored_block = _tr_stored_block;
	trees._tr_flush_block  = _tr_flush_block;
	trees._tr_tally = _tr_tally;
	trees._tr_align = _tr_align;
	return trees;
}

var adler32_1;
var hasRequiredAdler32;

function requireAdler32 () {
	if (hasRequiredAdler32) return adler32_1;
	hasRequiredAdler32 = 1;

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It isn't worth it to make additional optimizations as in original.
	// Small size is preferable.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	adler32_1 = adler32;
	return adler32_1;
}

var crc32_1;
var hasRequiredCrc32;

function requireCrc32 () {
	if (hasRequiredCrc32) return crc32_1;
	hasRequiredCrc32 = 1;

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc ^= -1;

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	crc32_1 = crc32;
	return crc32_1;
}

var messages;
var hasRequiredMessages;

function requireMessages () {
	if (hasRequiredMessages) return messages;
	hasRequiredMessages = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	messages = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};
	return messages;
}

var hasRequiredDeflate$1;

function requireDeflate$1 () {
	if (hasRequiredDeflate$1) return deflate;
	hasRequiredDeflate$1 = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils   = requireCommon();
	var trees   = requireTrees();
	var adler32 = requireAdler32();
	var crc32   = requireCrc32();
	var msg     = requireMessages();

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;


	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;


	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;


	/* The deflate compression method */
	var Z_DEFLATED  = 8;

	/*============================================================================*/


	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;


	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

	var PRESET_DICT = 0x20;

	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;

	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}

	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}

	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }

	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}


	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}


	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}


	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}


	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;

	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }

	  strm.avail_in -= len;

	  // zmemcpy(buf, strm->next_in, len);
	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }

	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }

	  strm.next_in += len;
	  strm.total_in += len;

	  return len;
	}


	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev  = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;

	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}


	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}


	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);

	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);

	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */

	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;

	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {

	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }

	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;

	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/


	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;

	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }

	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;

	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */

	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;

	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }

	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}


	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */

	  var _win = s.window;

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}

	var configuration_table;

	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];


	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;

	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}


	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */

	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null;   /* Heads of the hash chains or NIL. */

	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	              /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);

	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
	  zero(this.heap);

	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0;          /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0;      /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */


	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}


	function deflateResetKeep(strm) {
	  var s;

	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;

	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;

	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}


	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}


	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}


	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;

	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }

	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }

	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }


	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }


	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();

	  strm.state = s;
	  s.strm = strm;

	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;

	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;

	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);

	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;

	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;

	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;

	  return deflateReset(strm);
	}

	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}


	function deflate$1(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }

	  s = strm.state;

	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }

	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {

	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	        );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;

	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);

	      s.status = BUSY_STATE;
	      putShortMSB(s, header);

	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }

	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */

	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));

	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }

	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}

	function deflateEnd(strm) {
	  var status;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.state = null;

	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}


	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  s = strm.state;
	  wrap = s.wrap;

	  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
	    return Z_STREAM_ERROR;
	  }

	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
	  }

	  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {            /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new utils.Buf8(s.w_size);
	    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	      s.prev[str & s.w_mask] = s.head[s.ins_h];

	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK;
	}


	deflate.deflateInit = deflateInit;
	deflate.deflateInit2 = deflateInit2;
	deflate.deflateReset = deflateReset;
	deflate.deflateResetKeep = deflateResetKeep;
	deflate.deflateSetHeader = deflateSetHeader;
	deflate.deflate = deflate$1;
	deflate.deflateEnd = deflateEnd;
	deflate.deflateSetDictionary = deflateSetDictionary;
	deflate.deflateInfo = 'pako deflate (from Nodeca project)';

	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/
	return deflate;
}

var strings = {};

var hasRequiredStrings;

function requireStrings () {
	if (hasRequiredStrings) return strings;
	hasRequiredStrings = 1;


	var utils = requireCommon();


	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safari
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;

	try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new utils.Buf8(256);
	for (var q = 0; q < 256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


	// convert string to array (typed, when possible)
	strings.string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }

	  // allocate buffer
	  buf = new utils.Buf8(buf_len);

	  // convert
	  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }

	  return buf;
	};

	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // On Chrome, the arguments in a function call that are allowed is `65534`.
	  // If the length of the buffer is smaller than that, we can use this optimization,
	  // otherwise we will take a slower path.
	  if (len < 65534) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	    }
	  }

	  var result = '';
	  for (var i = 0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}


	// Convert byte array to binary string
	strings.buf2binstring = function (buf) {
	  return buf2binstring(buf, buf.length);
	};


	// Convert binary string (typed, when possible)
	strings.binstring2buf = function (str) {
	  var buf = new utils.Buf8(str.length);
	  for (var i = 0, len = buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};


	// convert array to string
	strings.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;

	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len * 2);

	  for (out = 0, i = 0; i < len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }

	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }

	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }

	  return buf2binstring(utf16buf, out);
	};


	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	strings.utf8border = function (buf, max) {
	  var pos;

	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }

	  // go back from last position, until start of sequence found
	  pos = max - 1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

	  // Very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }

	  // If we came to start of buffer - that means buffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }

	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};
	return strings;
}

var zstream;
var hasRequiredZstream;

function requireZstream () {
	if (hasRequiredZstream) return zstream;
	hasRequiredZstream = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	zstream = ZStream;
	return zstream;
}

var hasRequiredDeflate;

function requireDeflate () {
	if (hasRequiredDeflate) return deflate$1;
	hasRequiredDeflate = 1;


	var zlib_deflate = requireDeflate$1();
	var utils        = requireCommon();
	var strings      = requireStrings();
	var msg          = requireMessages();
	var ZStream      = requireZstream();

	var toString = Object.prototype.toString;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	var Z_NO_FLUSH      = 0;
	var Z_FINISH        = 4;

	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_SYNC_FLUSH    = 2;

	var Z_DEFAULT_COMPRESSION = -1;

	var Z_DEFAULT_STRATEGY    = 0;

	var Z_DEFLATED  = 8;

	/* ===========================================================================*/


	/**
	 * class Deflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[deflate]],
	 * [[deflateRaw]] and [[gzip]].
	 **/

	/* internal
	 * Deflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Deflate#onData]] not overridden.
	 **/

	/**
	 * Deflate.result -> Uint8Array|Array
	 *
	 * Compressed result, generated by default [[Deflate#onData]]
	 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
	 * push a chunk with explicit flush (call [[Deflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Deflate.err -> Number
	 *
	 * Error code after deflate finished. 0 (Z_OK) on success.
	 * You will not need it in real life, because deflate errors
	 * are possible only on wrong options or bad `onData` / `onEnd`
	 * custom handlers.
	 **/

	/**
	 * Deflate.msg -> String
	 *
	 * Error message, if [[Deflate.err]] != 0
	 **/


	/**
	 * new Deflate(options)
	 * - options (Object): zlib deflate options.
	 *
	 * Creates new deflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `level`
	 * - `windowBits`
	 * - `memLevel`
	 * - `strategy`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw deflate
	 * - `gzip` (Boolean) - create gzip wrapper
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 * - `header` (Object) - custom header for gzip
	 *   - `text` (Boolean) - true if compressed data believed to be text
	 *   - `time` (Number) - modification time, unix timestamp
	 *   - `os` (Number) - operation system code
	 *   - `extra` (Array) - array of bytes with extra data (max 65536)
	 *   - `name` (String) - file name (binary string)
	 *   - `comment` (String) - comment (binary string)
	 *   - `hcrc` (Boolean) - true if header crc should be added
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var deflate = new pako.Deflate({ level: 3});
	 *
	 * deflate.push(chunk1, false);
	 * deflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (deflate.err) { throw new Error(deflate.err); }
	 *
	 * console.log(deflate.result);
	 * ```
	 **/
	function Deflate(options) {
	  if (!(this instanceof Deflate)) return new Deflate(options);

	  this.options = utils.assign({
	    level: Z_DEFAULT_COMPRESSION,
	    method: Z_DEFLATED,
	    chunkSize: 16384,
	    windowBits: 15,
	    memLevel: 8,
	    strategy: Z_DEFAULT_STRATEGY,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  if (opt.raw && (opt.windowBits > 0)) {
	    opt.windowBits = -opt.windowBits;
	  }

	  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
	    opt.windowBits += 16;
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm = new ZStream();
	  this.strm.avail_out = 0;

	  var status = zlib_deflate.deflateInit2(
	    this.strm,
	    opt.level,
	    opt.method,
	    opt.windowBits,
	    opt.memLevel,
	    opt.strategy
	  );

	  if (status !== Z_OK) {
	    throw new Error(msg[status]);
	  }

	  if (opt.header) {
	    zlib_deflate.deflateSetHeader(this.strm, opt.header);
	  }

	  if (opt.dictionary) {
	    var dict;
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      // If we need to compress text, change encoding to utf8.
	      dict = strings.string2buf(opt.dictionary);
	    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
	      dict = new Uint8Array(opt.dictionary);
	    } else {
	      dict = opt.dictionary;
	    }

	    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

	    if (status !== Z_OK) {
	      throw new Error(msg[status]);
	    }

	    this._dict_set = true;
	  }
	}

	/**
	 * Deflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
	 *   converted to utf8 byte sequence.
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
	 * new compressed chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the compression context.
	 *
	 * On fail call [[Deflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * array format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Deflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var status, _mode;

	  if (this.ended) { return false; }

	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // If we need to compress text, change encoding to utf8.
	    strm.input = strings.string2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

	    if (status !== Z_STREAM_END && status !== Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
	      if (this.options.to === 'string') {
	        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
	      } else {
	        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	      }
	    }
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

	  // Finalize on the last chunk.
	  if (_mode === Z_FINISH) {
	    status = zlib_deflate.deflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === Z_SYNC_FLUSH) {
	    this.onEnd(Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Deflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Deflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Deflate#onEnd(status) -> Void
	 * - status (Number): deflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called once after you tell deflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Deflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === Z_OK) {
	    if (this.options.to === 'string') {
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * deflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * Compress `data` with deflate algorithm and `options`.
	 *
	 * Supported options are:
	 *
	 * - level
	 * - windowBits
	 * - memLevel
	 * - strategy
	 * - dictionary
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
	 *
	 * console.log(pako.deflate(data));
	 * ```
	 **/
	function deflate(input, options) {
	  var deflator = new Deflate(options);

	  deflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

	  return deflator.result;
	}


	/**
	 * deflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function deflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return deflate(input, options);
	}


	/**
	 * gzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but create gzip wrapper instead of
	 * deflate one.
	 **/
	function gzip(input, options) {
	  options = options || {};
	  options.gzip = true;
	  return deflate(input, options);
	}


	deflate$1.Deflate = Deflate;
	deflate$1.deflate = deflate;
	deflate$1.deflateRaw = deflateRaw;
	deflate$1.gzip = gzip;
	return deflate$1;
}

var inflate$1 = {};

var inflate = {};

var inffast;
var hasRequiredInffast;

function requireInffast () {
	if (hasRequiredInffast) return inffast;
	hasRequiredInffast = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	inffast = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};
	return inffast;
}

var inftrees;
var hasRequiredInftrees;

function requireInftrees () {
	if (hasRequiredInftrees) return inftrees;
	hasRequiredInftrees = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils = requireCommon();

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  /* process all codes and make table entries */
	  for (;;) {
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};
	return inftrees;
}

var hasRequiredInflate$1;

function requireInflate$1 () {
	if (hasRequiredInflate$1) return inflate;
	hasRequiredInflate$1 = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils         = requireCommon();
	var adler32       = requireAdler32();
	var crc32         = requireCrc32();
	var inflate_fast  = requireInffast();
	var inflate_table = requireInftrees();

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;


	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate$1(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	      case HEAD:
	        if (state.wrap === 0) {
	          state.mode = TYPEDO;
	          break;
	        }
	        //=== NEEDBITS(16);
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//

	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          state.mode = FLAGS;
	          break;
	        }
	        state.flags = 0;           /* expect zlib header */
	        if (state.head) {
	          state.head.done = false;
	        }
	        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	          strm.msg = 'incorrect header check';
	          state.mode = BAD;
	          break;
	        }
	        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        len = (hold & 0x0f)/*BITS(4)*/ + 8;
	        if (state.wbits === 0) {
	          state.wbits = len;
	        }
	        else if (len > state.wbits) {
	          strm.msg = 'invalid window size';
	          state.mode = BAD;
	          break;
	        }
	        state.dmax = 1 << len;
	        //Tracev((stderr, "inflate:   zlib header ok\n"));
	        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	        state.mode = hold & 0x200 ? DICTID : TYPE;
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        break;
	      case FLAGS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.flags = hold;
	        if ((state.flags & 0xff) !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        if (state.flags & 0xe000) {
	          strm.msg = 'unknown header flags set';
	          state.mode = BAD;
	          break;
	        }
	        if (state.head) {
	          state.head.text = ((hold >> 8) & 1);
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = TIME;
	        /* falls through */
	      case TIME:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.time = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC4(state.check, hold)
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          hbuf[2] = (hold >>> 16) & 0xff;
	          hbuf[3] = (hold >>> 24) & 0xff;
	          state.check = crc32(state.check, hbuf, 4, 0);
	          //===
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = OS;
	        /* falls through */
	      case OS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.xflags = (hold & 0xff);
	          state.head.os = (hold >> 8);
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = EXLEN;
	        /* falls through */
	      case EXLEN:
	        if (state.flags & 0x0400) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length = hold;
	          if (state.head) {
	            state.head.extra_len = hold;
	          }
	          if (state.flags & 0x0200) {
	            //=== CRC2(state.check, hold);
	            hbuf[0] = hold & 0xff;
	            hbuf[1] = (hold >>> 8) & 0xff;
	            state.check = crc32(state.check, hbuf, 2, 0);
	            //===//
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        else if (state.head) {
	          state.head.extra = null/*Z_NULL*/;
	        }
	        state.mode = EXTRA;
	        /* falls through */
	      case EXTRA:
	        if (state.flags & 0x0400) {
	          copy = state.length;
	          if (copy > have) { copy = have; }
	          if (copy) {
	            if (state.head) {
	              len = state.head.extra_len - state.length;
	              if (!state.head.extra) {
	                // Use untyped array for more convenient processing later
	                state.head.extra = new Array(state.head.extra_len);
	              }
	              utils.arraySet(
	                state.head.extra,
	                input,
	                next,
	                // extra field is limited to 65536 bytes
	                // - no need for additional size check
	                copy,
	                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	                len
	              );
	              //zmemcpy(state.head.extra + len, next,
	              //        len + copy > state.head.extra_max ?
	              //        state.head.extra_max - len : copy);
	            }
	            if (state.flags & 0x0200) {
	              state.check = crc32(state.check, input, copy, next);
	            }
	            have -= copy;
	            next += copy;
	            state.length -= copy;
	          }
	          if (state.length) { break inf_leave; }
	        }
	        state.length = 0;
	        state.mode = NAME;
	        /* falls through */
	      case NAME:
	        if (state.flags & 0x0800) {
	          if (have === 0) { break inf_leave; }
	          copy = 0;
	          do {
	            // TODO: 2 or 1 bytes?
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len &&
	                (state.length < 65536 /*state.head.name_max*/)) {
	              state.head.name += String.fromCharCode(len);
	            }
	          } while (len && copy < have);

	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) { break inf_leave; }
	        }
	        else if (state.head) {
	          state.head.name = null;
	        }
	        state.length = 0;
	        state.mode = COMMENT;
	        /* falls through */
	      case COMMENT:
	        if (state.flags & 0x1000) {
	          if (have === 0) { break inf_leave; }
	          copy = 0;
	          do {
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len &&
	                (state.length < 65536 /*state.head.comm_max*/)) {
	              state.head.comment += String.fromCharCode(len);
	            }
	          } while (len && copy < have);
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) { break inf_leave; }
	        }
	        else if (state.head) {
	          state.head.comment = null;
	        }
	        state.mode = HCRC;
	        /* falls through */
	      case HCRC:
	        if (state.flags & 0x0200) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.check & 0xffff)) {
	            strm.msg = 'header crc mismatch';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        if (state.head) {
	          state.head.hcrc = ((state.flags >> 9) & 1);
	          state.head.done = true;
	        }
	        strm.adler = state.check = 0;
	        state.mode = TYPE;
	        break;
	      case DICTID:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        strm.adler = state.check = zswap32(hold);
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = DICT;
	        /* falls through */
	      case DICT:
	        if (state.havedict === 0) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          return Z_NEED_DICT;
	        }
	        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	        state.mode = TYPE;
	        /* falls through */
	      case TYPE:
	        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case TYPEDO:
	        if (state.last) {
	          //--- BYTEBITS() ---//
	          hold >>>= bits & 7;
	          bits -= bits & 7;
	          //---//
	          state.mode = CHECK;
	          break;
	        }
	        //=== NEEDBITS(3); */
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.last = (hold & 0x01)/*BITS(1)*/;
	        //--- DROPBITS(1) ---//
	        hold >>>= 1;
	        bits -= 1;
	        //---//

	        switch ((hold & 0x03)/*BITS(2)*/) {
	          case 0:                             /* stored block */
	            //Tracev((stderr, "inflate:     stored block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = STORED;
	            break;
	          case 1:                             /* fixed block */
	            fixedtables(state);
	            //Tracev((stderr, "inflate:     fixed codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = LEN_;             /* decode codes */
	            if (flush === Z_TREES) {
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	              break inf_leave;
	            }
	            break;
	          case 2:                             /* dynamic block */
	            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = TABLE;
	            break;
	          case 3:
	            strm.msg = 'invalid block type';
	            state.mode = BAD;
	        }
	        //--- DROPBITS(2) ---//
	        hold >>>= 2;
	        bits -= 2;
	        //---//
	        break;
	      case STORED:
	        //--- BYTEBITS() ---// /* go to byte boundary */
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	          strm.msg = 'invalid stored block lengths';
	          state.mode = BAD;
	          break;
	        }
	        state.length = hold & 0xffff;
	        //Tracev((stderr, "inflate:       stored length %u\n",
	        //        state.length));
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = COPY_;
	        if (flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case COPY_:
	        state.mode = COPY;
	        /* falls through */
	      case COPY:
	        copy = state.length;
	        if (copy) {
	          if (copy > have) { copy = have; }
	          if (copy > left) { copy = left; }
	          if (copy === 0) { break inf_leave; }
	          //--- zmemcpy(put, next, copy); ---
	          utils.arraySet(output, input, next, copy, put);
	          //---//
	          have -= copy;
	          next += copy;
	          left -= copy;
	          put += copy;
	          state.length -= copy;
	          break;
	        }
	        //Tracev((stderr, "inflate:       stored end\n"));
	        state.mode = TYPE;
	        break;
	      case TABLE:
	        //=== NEEDBITS(14); */
	        while (bits < 14) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	        if (state.nlen > 286 || state.ndist > 30) {
	          strm.msg = 'too many length or distance symbols';
	          state.mode = BAD;
	          break;
	        }
	//#endif
	        //Tracev((stderr, "inflate:       table sizes ok\n"));
	        state.have = 0;
	        state.mode = LENLENS;
	        /* falls through */
	      case LENLENS:
	        while (state.have < state.ncode) {
	          //=== NEEDBITS(3);
	          while (bits < 3) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	          //--- DROPBITS(3) ---//
	          hold >>>= 3;
	          bits -= 3;
	          //---//
	        }
	        while (state.have < 19) {
	          state.lens[order[state.have++]] = 0;
	        }
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        //state.next = state.codes;
	        //state.lencode = state.next;
	        // Switch to use dynamic table
	        state.lencode = state.lendyn;
	        state.lenbits = 7;

	        opts = { bits: state.lenbits };
	        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	        state.lenbits = opts.bits;

	        if (ret) {
	          strm.msg = 'invalid code lengths set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, "inflate:       code lengths ok\n"));
	        state.have = 0;
	        state.mode = CODELENS;
	        /* falls through */
	      case CODELENS:
	        while (state.have < state.nlen + state.ndist) {
	          for (;;) {
	            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          if (here_val < 16) {
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            state.lens[state.have++] = here_val;
	          }
	          else {
	            if (here_val === 16) {
	              //=== NEEDBITS(here.bits + 2);
	              n = here_bits + 2;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              if (state.have === 0) {
	                strm.msg = 'invalid bit length repeat';
	                state.mode = BAD;
	                break;
	              }
	              len = state.lens[state.have - 1];
	              copy = 3 + (hold & 0x03);//BITS(2);
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	            }
	            else if (here_val === 17) {
	              //=== NEEDBITS(here.bits + 3);
	              n = here_bits + 3;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 3 + (hold & 0x07);//BITS(3);
	              //--- DROPBITS(3) ---//
	              hold >>>= 3;
	              bits -= 3;
	              //---//
	            }
	            else {
	              //=== NEEDBITS(here.bits + 7);
	              n = here_bits + 7;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 11 + (hold & 0x7f);//BITS(7);
	              //--- DROPBITS(7) ---//
	              hold >>>= 7;
	              bits -= 7;
	              //---//
	            }
	            if (state.have + copy > state.nlen + state.ndist) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            while (copy--) {
	              state.lens[state.have++] = len;
	            }
	          }
	        }

	        /* handle error breaks in while */
	        if (state.mode === BAD) { break; }

	        /* check for end-of-block code (better have one) */
	        if (state.lens[256] === 0) {
	          strm.msg = 'invalid code -- missing end-of-block';
	          state.mode = BAD;
	          break;
	        }

	        /* build code tables -- note: do not change the lenbits or distbits
	           values here (9 and 6) without reading the comments in inftrees.h
	           concerning the ENOUGH constants, which depend on those values */
	        state.lenbits = 9;

	        opts = { bits: state.lenbits };
	        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.lenbits = opts.bits;
	        // state.lencode = state.next;

	        if (ret) {
	          strm.msg = 'invalid literal/lengths set';
	          state.mode = BAD;
	          break;
	        }

	        state.distbits = 6;
	        //state.distcode.copy(state.codes);
	        // Switch to use dynamic table
	        state.distcode = state.distdyn;
	        opts = { bits: state.distbits };
	        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.distbits = opts.bits;
	        // state.distcode = state.next;

	        if (ret) {
	          strm.msg = 'invalid distances set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, 'inflate:       codes ok\n'));
	        state.mode = LEN_;
	        if (flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case LEN_:
	        state.mode = LEN;
	        /* falls through */
	      case LEN:
	        if (have >= 6 && left >= 258) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          inflate_fast(strm, _out);
	          //--- LOAD() ---
	          put = strm.next_out;
	          output = strm.output;
	          left = strm.avail_out;
	          next = strm.next_in;
	          input = strm.input;
	          have = strm.avail_in;
	          hold = state.hold;
	          bits = state.bits;
	          //---

	          if (state.mode === TYPE) {
	            state.back = -1;
	          }
	          break;
	        }
	        state.back = 0;
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if (here_bits <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_op && (here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.lencode[last_val +
	                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((last_bits + here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        state.length = here_val;
	        if (here_op === 0) {
	          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	          //        "inflate:         literal '%c'\n" :
	          //        "inflate:         literal 0x%02x\n", here.val));
	          state.mode = LIT;
	          break;
	        }
	        if (here_op & 32) {
	          //Tracevv((stderr, "inflate:         end of block\n"));
	          state.back = -1;
	          state.mode = TYPE;
	          break;
	        }
	        if (here_op & 64) {
	          strm.msg = 'invalid literal/length code';
	          state.mode = BAD;
	          break;
	        }
	        state.extra = here_op & 15;
	        state.mode = LENEXT;
	        /* falls through */
	      case LENEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", state.length));
	        state.was = state.length;
	        state.mode = DIST;
	        /* falls through */
	      case DIST:
	        for (;;) {
	          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if ((here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.distcode[last_val +
	                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((last_bits + here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        if (here_op & 64) {
	          strm.msg = 'invalid distance code';
	          state.mode = BAD;
	          break;
	        }
	        state.offset = here_val;
	        state.extra = (here_op) & 15;
	        state.mode = DISTEXT;
	        /* falls through */
	      case DISTEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	//#ifdef INFLATE_STRICT
	        if (state.offset > state.dmax) {
	          strm.msg = 'invalid distance too far back';
	          state.mode = BAD;
	          break;
	        }
	//#endif
	        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	        state.mode = MATCH;
	        /* falls through */
	      case MATCH:
	        if (left === 0) { break inf_leave; }
	        copy = _out - left;
	        if (state.offset > copy) {         /* copy from window */
	          copy = state.offset - copy;
	          if (copy > state.whave) {
	            if (state.sane) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break;
	            }
	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	          }
	          if (copy > state.wnext) {
	            copy -= state.wnext;
	            from = state.wsize - copy;
	          }
	          else {
	            from = state.wnext - copy;
	          }
	          if (copy > state.length) { copy = state.length; }
	          from_source = state.window;
	        }
	        else {                              /* copy from output */
	          from_source = output;
	          from = put - state.offset;
	          copy = state.length;
	        }
	        if (copy > left) { copy = left; }
	        left -= copy;
	        state.length -= copy;
	        do {
	          output[put++] = from_source[from++];
	        } while (--copy);
	        if (state.length === 0) { state.mode = LEN; }
	        break;
	      case LIT:
	        if (left === 0) { break inf_leave; }
	        output[put++] = state.length;
	        left--;
	        state.mode = LEN;
	        break;
	      case CHECK:
	        if (state.wrap) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            // Use '|' instead of '+' to make sure that result is signed
	            hold |= input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          _out -= left;
	          strm.total_out += _out;
	          state.total += _out;
	          if (_out) {
	            strm.adler = state.check =
	                /*UPDATE(state.check, put - _out, _out);*/
	                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

	          }
	          _out = left;
	          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	            strm.msg = 'incorrect data check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   check matches trailer\n"));
	        }
	        state.mode = LENGTH;
	        /* falls through */
	      case LENGTH:
	        if (state.wrap && state.flags) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.total & 0xffffffff)) {
	            strm.msg = 'incorrect length check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   length matches trailer\n"));
	        }
	        state.mode = DONE;
	        /* falls through */
	      case DONE:
	        ret = Z_STREAM_END;
	        break inf_leave;
	      case BAD:
	        ret = Z_DATA_ERROR;
	        break inf_leave;
	      case MEM:
	        return Z_MEM_ERROR;
	      case SYNC:
	        /* falls through */
	      default:
	        return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}

	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var state;
	  var dictid;
	  var ret;

	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }

	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}

	inflate.inflateReset = inflateReset;
	inflate.inflateReset2 = inflateReset2;
	inflate.inflateResetKeep = inflateResetKeep;
	inflate.inflateInit = inflateInit;
	inflate.inflateInit2 = inflateInit2;
	inflate.inflate = inflate$1;
	inflate.inflateEnd = inflateEnd;
	inflate.inflateGetHeader = inflateGetHeader;
	inflate.inflateSetDictionary = inflateSetDictionary;
	inflate.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/
	return inflate;
}

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	constants = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};
	return constants;
}

var gzheader;
var hasRequiredGzheader;

function requireGzheader () {
	if (hasRequiredGzheader) return gzheader;
	hasRequiredGzheader = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function GZheader() {
	  /* true if compressed data believed to be text */
	  this.text       = 0;
	  /* modification time */
	  this.time       = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags     = 0;
	  /* operating system */
	  this.os         = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra      = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len  = 0; // Actually, we don't need it in JS,
	                       // but leave for few code modifications

	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //

	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name       = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment    = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc       = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done       = false;
	}

	gzheader = GZheader;
	return gzheader;
}

var hasRequiredInflate;

function requireInflate () {
	if (hasRequiredInflate) return inflate$1;
	hasRequiredInflate = 1;


	var zlib_inflate = requireInflate$1();
	var utils        = requireCommon();
	var strings      = requireStrings();
	var c            = requireConstants();
	var msg          = requireMessages();
	var ZStream      = requireZstream();
	var GZheader     = requireGzheader();

	var toString = Object.prototype.toString;

	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/

	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overridden.
	 **/

	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/

	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/


	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	function Inflate(options) {
	  if (!(this instanceof Inflate)) return new Inflate(options);

	  this.options = utils.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) { opt.windowBits = -15; }
	  }

	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
	      !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }

	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm   = new ZStream();
	  this.strm.avail_out = 0;

	  var status  = zlib_inflate.inflateInit2(
	    this.strm,
	    opt.windowBits
	  );

	  if (status !== c.Z_OK) {
	    throw new Error(msg[status]);
	  }

	  this.header = new GZheader();

	  zlib_inflate.inflateGetHeader(this.strm, this.header);

	  // Setup dictionary
	  if (opt.dictionary) {
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      opt.dictionary = strings.string2buf(opt.dictionary);
	    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
	      opt.dictionary = new Uint8Array(opt.dictionary);
	    }
	    if (opt.raw) { //In raw mode we need to set the dictionary early
	      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
	      if (status !== c.Z_OK) {
	        throw new Error(msg[status]);
	      }
	    }
	  }
	}

	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var dictionary = this.options.dictionary;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;

	  // Flag to properly process Z_BUF_ERROR on testing inflate call
	  // when we check that all output data was flushed.
	  var allowBufError = false;

	  if (this.ended) { return false; }
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }

	    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

	    if (status === c.Z_NEED_DICT && dictionary) {
	      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
	    }

	    if (status === c.Z_BUF_ERROR && allowBufError === true) {
	      status = c.Z_OK;
	      allowBufError = false;
	    }

	    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }

	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

	        if (this.options.to === 'string') {

	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);

	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

	          this.onData(utf8str);

	        } else {
	          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }

	    // When no more input data, we should check that internal inflate buffers
	    // are flushed. The only way to do it when avail_out = 0 - run one more
	    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
	    // Here we set flag to process this error properly.
	    //
	    // NOTE. Deflate does not return error in this case and does not needs such
	    // logic.
	    if (strm.avail_in === 0 && strm.avail_out === 0) {
	      allowBufError = true;
	    }

	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

	  if (status === c.Z_STREAM_END) {
	    _mode = c.Z_FINISH;
	  }

	  // Finalize on the last chunk.
	  if (_mode === c.Z_FINISH) {
	    status = zlib_inflate.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === c.Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === c.Z_SYNC_FLUSH) {
	    this.onEnd(c.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === c.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 aligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate(input, options) {
	  var inflator = new Inflate(options);

	  inflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

	  return inflator.result;
	}


	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate(input, options);
	}


	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/


	inflate$1.Inflate = Inflate;
	inflate$1.inflate = inflate;
	inflate$1.inflateRaw = inflateRaw;
	inflate$1.ungzip  = inflate;
	return inflate$1;
}

var pako_1;
var hasRequiredPako;

function requirePako () {
	if (hasRequiredPako) return pako_1;
	hasRequiredPako = 1;

	var assign    = requireCommon().assign;

	var deflate   = requireDeflate();
	var inflate   = requireInflate();
	var constants = requireConstants();

	var pako = {};

	assign(pako, deflate, inflate, constants);

	pako_1 = pako;
	return pako_1;
}

var hasRequiredUTIF;

function requireUTIF () {
	if (hasRequiredUTIF) return UTIF.exports;
	hasRequiredUTIF = 1;
	(function (module) {
(function(){
			var UTIF = {};
			
			// Make available for import by `require()`
			{module.exports = UTIF;}
			
			var pako = (typeof commonjsRequire === "function") ? requirePako() : self.pako;
			
			function log() { if (typeof process=="undefined" || process.env.NODE_ENV=="development") console.log.apply(console, arguments);  }
			
			(function(UTIF, pako){
				
			// Following lines add a JPEG decoder  to UTIF.JpegDecoder
			(function(){var W=function a1(){function W(p){this.message="JPEG error: "+p;}W.prototype=new Error;W.prototype.name="JpegError";W.constructor=W;return W}(),ak=function ag(){var p=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),t=4017,ac=799,ah=3406,ao=2276,ar=1567,ai=3784,s=5793,ad=2896;function ak(Q){if(Q==null)Q={};if(Q.w==null)Q.w=-1;this.V=Q.n;this.N=Q.w;}function a5(Q,h){var f=0,G=[],n,E,a=16,F;while(a>0&&!Q[a-1]){a--;}G.push({children:[],index:0});var C=G[0];for(n=0;n<a;n++)
			{for(E=0;E<Q[n];E++){C=G.pop();C.children[C.index]=h[f];while(C.index>0){C=G.pop();}C.index++;G.push(C);while(G.length<=n){G.push(F={children:[],index:0});C.children[C.index]=F.children;C=F;}f++;}if(n+1<a){G.push(F={children:[],index:0});C.children[C.index]=F.children;C=F;}}return G[0].children}function a2(Q,h,f){return 64*((Q.P+1)*h+f)}function a7(Q,h,f,G,n,E,a,C,F,d){if(d==null)d=false;var T=f.m,U=f.Z,z=h,J=0,V=0,r=0,D=0,a8,q=0,X,O,_,N,e,K,x=0,k,g,R,c;function Y(){if(V>0){V--;return J>>V&1}J=Q[h++];if(J===255){var I=Q[h++];if(I){if(I===220&&d){h+=2;var l=Z(Q,h);h+=2;if(l>0&&l!==f.s){throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data",l)}}else if(I===217){if(d){var M=q*8;
			if(M>0&&M<f.s/10){throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, "+"possibly caused by incorrect `scanLines` parameter",M)}}throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data")}throw new W("unexpected marker")}}V=7;return J>>>7}function u(I){var l=I;while(true){l=l[Y()];switch(typeof l){case "number":return l;case "object":continue}throw new W("invalid huffman sequence")}}function m(I){var e=0;while(I>0){e=e<<1|Y();I--;}return e}function j(I){if(I===1){return Y()===1?1:-1}var e=m(I);if(e>=1<<I-1){return e}return e+(-1<<I)+1}function v(X,I){var l=u(X.J),M=l===0?0:j(l),N=1;
			X.D[I]=X.Q+=M;while(N<64){var S=u(X.i),i=S&15,A=S>>4;if(i===0){if(A<15){break}N+=16;continue}N+=A;var o=p[N];X.D[I+o]=j(i);N++;}}function $(X,I){var l=u(X.J),M=l===0?0:j(l)<<F;X.D[I]=X.Q+=M;}function b(X,I){X.D[I]|=Y()<<F;}function P(X,I){if(r>0){r--;return}var N=E,l=a;while(N<=l){var M=u(X.i),S=M&15,i=M>>4;if(S===0){if(i<15){r=m(i)+(1<<i)-1;break}N+=16;continue}N+=i;var A=p[N];X.D[I+A]=j(S)*(1<<F);N++;}}function a4(X,I){var N=E,l=a,M=0,S,i;while(N<=l){var A=I+p[N],o=X.D[A]<0?-1:1;switch(D){case 0:i=u(X.i);S=i&15;M=i>>4;if(S===0){if(M<15){r=m(M)+(1<<M);D=4;}else {M=16;D=1;}}else {if(S!==1){throw new W("invalid ACn encoding")}a8=j(S);D=M?2:3;}continue;case 1:case 2:if(X.D[A]){X.D[A]+=o*(Y()<<F);}else {M--;if(M===0){D=D===2?3:0;}}break;case 3:if(X.D[A]){X.D[A]+=o*(Y()<<F);}else {X.D[A]=a8<<F;
			D=0;}break;case 4:if(X.D[A]){X.D[A]+=o*(Y()<<F);}break}N++;}if(D===4){r--;if(r===0){D=0;}}}function H(X,I,x,l,M){var S=x/T|0,i=x%T;q=S*X.A+l;var A=i*X.h+M,o=a2(X,q,A);I(X,o);}function w(X,I,x){q=x/X.P|0;var l=x%X.P,M=a2(X,q,l);I(X,M);}var y=G.length;if(U){if(E===0){K=C===0?$:b;}else {K=C===0?P:a4;}}else {K=v;}if(y===1){g=G[0].P*G[0].c;}else {g=T*f.R;}while(x<=g){var L=n?Math.min(g-x,n):g;if(L>0){for(O=0;O<y;O++){G[O].Q=0;}r=0;if(y===1){X=G[0];for(e=0;e<L;e++){w(X,K,x);x++;}}else {for(e=0;e<L;
			e++){for(O=0;O<y;O++){X=G[O];R=X.h;c=X.A;for(_=0;_<c;_++){for(N=0;N<R;N++){H(X,K,x,_,N);}}}x++;}}}V=0;k=an(Q,h);if(!k){break}if(k.u){h=k.offset;}if(k.M>=65488&&k.M<=65495){h+=2;}else {break}}return h-z}function al(Q,h,f){var G=Q.$,n=Q.D,E,a,C,F,d,T,U,z,J,V,Y,u,m,j,v,$,b;if(!G){throw new W("missing required Quantization Table.")}for(var r=0;r<64;r+=8){J=n[h+r];V=n[h+r+1];Y=n[h+r+2];u=n[h+r+3];m=n[h+r+4];j=n[h+r+5];v=n[h+r+6];$=n[h+r+7];J*=G[r];if((V|Y|u|m|j|v|$)===0){b=s*J+512>>10;f[r]=b;f[r+1]=b;f[r+2]=b;f[r+3]=b;f[r+4]=b;f[r+5]=b;f[r+6]=b;f[r+7]=b;continue}V*=G[r+1];Y*=G[r+2];u*=G[r+3];m*=G[r+4];j*=G[r+5];v*=G[r+6];$*=G[r+7];E=s*J+128>>8;a=s*m+128>>8;C=Y;F=v;d=ad*(V-$)+128>>8;z=ad*(V+$)+128>>8;
			T=u<<4;U=j<<4;E=E+a+1>>1;a=E-a;b=C*ai+F*ar+128>>8;C=C*ar-F*ai+128>>8;F=b;d=d+U+1>>1;U=d-U;z=z+T+1>>1;T=z-T;E=E+F+1>>1;F=E-F;a=a+C+1>>1;C=a-C;b=d*ao+z*ah+2048>>12;d=d*ah-z*ao+2048>>12;z=b;b=T*ac+U*t+2048>>12;T=T*t-U*ac+2048>>12;U=b;f[r]=E+z;f[r+7]=E-z;f[r+1]=a+U;f[r+6]=a-U;f[r+2]=C+T;f[r+5]=C-T;f[r+3]=F+d;f[r+4]=F-d;}for(var P=0;P<8;++P){J=f[P];V=f[P+8];Y=f[P+16];u=f[P+24];m=f[P+32];j=f[P+40];v=f[P+48];$=f[P+56];if((V|Y|u|m|j|v|$)===0){b=s*J+8192>>14;if(b<-2040){b=0;}else if(b>=2024){b=255;}else {b=b+2056>>4;}n[h+P]=b;n[h+P+8]=b;n[h+P+16]=b;n[h+P+24]=b;n[h+P+32]=b;n[h+P+40]=b;n[h+P+48]=b;n[h+P+56]=b;continue}E=s*J+2048>>12;a=s*m+2048>>12;C=Y;F=v;d=ad*(V-$)+2048>>12;z=ad*(V+$)+2048>>12;T=u;U=j;E=(E+a+1>>1)+4112;a=E-a;b=C*ai+F*ar+2048>>12;C=C*ar-F*ai+2048>>12;F=b;d=d+U+1>>1;U=d-U;z=z+T+1>>1;T=z-T;E=E+F+1>>1;F=E-F;a=a+C+1>>1;C=a-C;b=d*ao+z*ah+2048>>12;d=d*ah-z*ao+2048>>12;z=b;
			b=T*ac+U*t+2048>>12;T=T*t-U*ac+2048>>12;U=b;J=E+z;$=E-z;V=a+U;v=a-U;Y=C+T;j=C-T;u=F+d;m=F-d;if(J<16){J=0;}else if(J>=4080){J=255;}else {J>>=4;}if(V<16){V=0;}else if(V>=4080){V=255;}else {V>>=4;}if(Y<16){Y=0;}else if(Y>=4080){Y=255;}else {Y>>=4;}if(u<16){u=0;}else if(u>=4080){u=255;}else {u>>=4;}if(m<16){m=0;}else if(m>=4080){m=255;}else {m>>=4;}if(j<16){j=0;}else if(j>=4080){j=255;}else {j>>=4;}if(v<16){v=0;}else if(v>=4080){v=255;}else {v>>=4;}if($<16){$=0;}else if($>=4080){$=255;}else {$>>=4;}n[h+P]=J;
			n[h+P+8]=V;n[h+P+16]=Y;n[h+P+24]=u;n[h+P+32]=m;n[h+P+40]=j;n[h+P+48]=v;n[h+P+56]=$;}}function a0(Q,h){var f=h.P,G=h.c,n=new Int16Array(64);for(var E=0;E<G;E++){for(var a=0;a<f;a++){var C=a2(h,E,a);al(h,C,n);}}return h.D}function an(Q,h,f){if(f==null)f=h;var G=Q.length-1,n=f<h?f:h;if(h>=G){return null}var E=Z(Q,h);if(E>=65472&&E<=65534){return {u:null,M:E,offset:h}}var a=Z(Q,n);while(!(a>=65472&&a<=65534)){if(++n>=G){return null}a=Z(Q,n);}return {u:E.toString(16),M:a,offset:n}}ak.prototype={parse(Q,h){if(h==null)h={};
			var f=h.F,E=0,a=null,C=null,F,d,T=0;function G(){var o=Z(Q,E);E+=2;var B=E+o-2,V=an(Q,B,E);if(V&&V.u){B=V.offset;}var ab=Q.subarray(E,B);E+=ab.length;return ab}function n(F){var o=Math.ceil(F.o/8/F.X),B=Math.ceil(F.s/8/F.B);for(var Y=0;Y<F.W.length;Y++){R=F.W[Y];var ab=Math.ceil(Math.ceil(F.o/8)*R.h/F.X),af=Math.ceil(Math.ceil(F.s/8)*R.A/F.B),ap=o*R.h,aq=B*R.A,ae=64*aq*(ap+1);R.D=new Int16Array(ae);R.P=ab;R.c=af;}F.m=o;F.R=B;}var U=[],z=[],J=[],V=Z(Q,E);E+=2;if(V!==65496){throw new W("SOI not found")}V=Z(Q,E);
			E+=2;markerLoop:while(V!==65497){var Y,u,m;switch(V){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var j=G();if(V===65504){if(j[0]===74&&j[1]===70&&j[2]===73&&j[3]===70&&j[4]===0){a={version:{d:j[5],T:j[6]},K:j[7],j:j[8]<<8|j[9],H:j[10]<<8|j[11],S:j[12],I:j[13],C:j.subarray(14,14+3*j[12]*j[13])};}}if(V===65518){if(j[0]===65&&j[1]===100&&j[2]===111&&j[3]===98&&j[4]===101){C={version:j[5]<<8|j[6],k:j[7]<<8|j[8],q:j[9]<<8|j[10],a:j[11]};}}break;
			case 65499:var v=Z(Q,E),b;E+=2;var $=v+E-2;while(E<$){var r=Q[E++],P=new Uint16Array(64);if(r>>4===0){for(u=0;u<64;u++){b=p[u];P[b]=Q[E++];}}else if(r>>4===1){for(u=0;u<64;u++){b=p[u];P[b]=Z(Q,E);E+=2;}}else {throw new W("DQT - invalid table spec")}U[r&15]=P;}break;case 65472:case 65473:case 65474:if(F){throw new W("Only single frame JPEGs supported")}E+=2;F={};F.G=V===65473;F.Z=V===65474;F.precision=Q[E++];var D=Z(Q,E),a4,q=0,H=0;E+=2;F.s=f||D;F.o=Z(Q,E);E+=2;F.W=[];F._={};var a8=Q[E++];for(Y=0;Y<a8;Y++){a4=Q[E];var w=Q[E+1]>>4,y=Q[E+1]&15;if(q<w){q=w;}if(H<y){H=y;}var X=Q[E+2];m=F.W.push({h:w,A:y,L:X,$:null});F._[a4]=m-1;E+=3;}F.X=q;F.B=H;n(F);break;case 65476:var O=Z(Q,E);E+=2;
			for(Y=2;Y<O;){var _=Q[E++],N=new Uint8Array(16),e=0;for(u=0;u<16;u++,E++){e+=N[u]=Q[E];}var K=new Uint8Array(e);for(u=0;u<e;u++,E++){K[u]=Q[E];}Y+=17+e;(_>>4===0?J:z)[_&15]=a5(N,K);}break;case 65501:E+=2;d=Z(Q,E);E+=2;break;case 65498:var x=++T===1&&!f,R;E+=2;var k=Q[E++],g=[];for(Y=0;Y<k;Y++){var c=Q[E++],L=F._[c];R=F.W[L];R.index=c;var a6=Q[E++];R.J=J[a6>>4];R.i=z[a6&15];g.push(R);}var I=Q[E++],l=Q[E++],M=Q[E++];try{var S=a7(Q,E,F,g,d,I,l,M>>4,M&15,x);E+=S;}catch(ex){if(ex instanceof DNLMarkerError){return this.parse(Q,{F:ex.s})}else if(ex instanceof EOIMarkerError){break markerLoop}throw ex}break;case 65500:E+=4;break;case 65535:if(Q[E]!==255){E--;}break;default:var i=an(Q,E-2,E-3);if(i&&i.u){E=i.offset;break}if(E>=Q.length-1){break markerLoop}throw new W("JpegImage.parse - unknown marker: "+V.toString(16))}V=Z(Q,E);E+=2;}this.width=F.o;this.height=F.s;this.g=a;this.b=C;this.W=[];for(Y=0;Y<F.W.length;Y++){R=F.W[Y];
			var A=U[R.L];if(A){R.$=A;}this.W.push({index:R.index,e:a0(F,R),l:R.h/F.X,t:R.A/F.B,P:R.P,c:R.c});}this.p=this.W.length;return undefined},Y(Q,h,f){if(f==null)f=false;var G=this.width/Q,n=this.height/h,E,a,C,F,d,T,U,z,J,V,Y=0,u,m=this.W.length,j=Q*h*m,v=new Uint8ClampedArray(j),$=new Uint32Array(Q),b=4294967288,r;for(U=0;U<m;U++){E=this.W[U];a=E.l*G;C=E.t*n;Y=U;u=E.e;F=E.P+1<<3;if(a!==r){for(d=0;d<Q;d++){z=0|d*a;$[d]=(z&b)<<3|z&7;}r=a;}for(T=0;T<h;T++){z=0|T*C;V=F*(z&b)|(z&7)<<3;for(d=0;d<Q;d++){v[Y]=u[V+$[d]];Y+=m;}}}var P=this.V;if(!f&&m===4&&!P){P=new Int32Array([-256,255,-256,255,-256,255,-256,255]);}if(P){for(U=0;U<j;){for(z=0,J=0;z<m;z++,U++,J+=2){v[U]=(v[U]*P[J]>>8)+P[J+1];}}}return v},get f(){if(this.b){return !!this.b.a}if(this.p===3){if(this.N===0){return  false}else if(this.W[0].index===82&&this.W[1].index===71&&this.W[2].index===66){return  false}return  true}if(this.N===1){return  true}return  false},z:function aj(Q){var h,f,G;
			for(var n=0,E=Q.length;n<E;n+=3){h=Q[n];f=Q[n+1];G=Q[n+2];Q[n]=h-179.456+1.402*G;Q[n+1]=h+135.459-.344*f-.714*G;Q[n+2]=h-226.816+1.772*f;}return Q},O:function aa(Q){var h,f,G,n,E=0;for(var a=0,C=Q.length;a<C;a+=4){h=Q[a];f=Q[a+1];G=Q[a+2];n=Q[a+3];Q[E++]=-122.67195406894+f*(-660635669420364e-19*f+.000437130475926232*G-54080610064599e-18*h+.00048449797120281*n-.154362151871126)+G*(-957964378445773e-18*G+.000817076911346625*h-.00477271405408747*n+1.53380253221734)+h*(.000961250184130688*h-.00266257332283933*n+.48357088451265)+n*(-336197177618394e-18*n+.484791561490776);
			Q[E++]=107.268039397724+f*(219927104525741e-19*f-.000640992018297945*G+.000659397001245577*h+.000426105652938837*n-.176491792462875)+G*(-778269941513683e-18*G+.00130872261408275*h+.000770482631801132*n-.151051492775562)+h*(.00126935368114843*h-.00265090189010898*n+.25802910206845)+n*(-318913117588328e-18*n-.213742400323665);Q[E++]=-20.810012546947+f*(-570115196973677e-18*f-263409051004589e-19*G+.0020741088115012*h-.00288260236853442*n+.814272968359295)+G*(-153496057440975e-19*G-.000132689043961446*h+.000560833691242812*n-.195152027534049)+h*(.00174418132927582*h-.00255243321439347*n+.116935020465145)+n*(-343531996510555e-18*n+.24165260232407);}return Q.subarray(0,E)},r:function a3(Q){var h,f,G;
			for(var n=0,E=Q.length;n<E;n+=4){h=Q[n];f=Q[n+1];G=Q[n+2];Q[n]=434.456-h-1.402*G;Q[n+1]=119.541-h+.344*f+.714*G;Q[n+2]=481.816-h-1.772*f;}return Q},U:function as(Q){var h,f,G,n,E=0;for(var a=0,C=Q.length;a<C;a+=4){h=Q[a];f=Q[a+1];G=Q[a+2];n=Q[a+3];Q[E++]=255+h*(-6747147073602441e-20*h+.0008379262121013727*f+.0002894718188643294*G+.003264231057537806*n-1.1185611867203937)+f*(26374107616089404e-21*f-8626949158638572e-20*G-.0002748769067499491*n-.02155688794978967)+G*(-3878099212869363e-20*G-.0003267808279485286*n+.0686742238595345)-n*(.0003361971776183937*n+.7430659151342254);
			Q[E++]=255+h*(.00013596372813588848*h+.000924537132573585*f+.00010567359618683593*G+.0004791864687436512*n-.3109689587515875)+f*(-23545346108370344e-20*f+.0002702845253534714*G+.0020200308977307156*n-.7488052167015494)+G*(6834815998235662e-20*G+.00015168452363460973*n-.09751927774728933)-n*(.0003189131175883281*n+.7364883807733168);Q[E++]=255+h*(13598650411385308e-21*h+.00012423956175490851*f+.0004751985097583589*G-36729317476630424e-22*n-.05562186980264034)+f*(.00016141380598724676*f+.0009692239130725186*G+.0007782692450036253*n-.44015232367526463)+G*(5.068882914068769e-7*G+.0017778369011375071*n-.7591454649749609)-n*(.0003435319965105553*n+.7063770186160144);}return Q.subarray(0,E)},getData:function(Q){var h=Q.width,f=Q.height,G=Q.forceRGB,n=Q.isSourcePDF;
			if(this.p>4){throw new W("Unsupported color mode")}var E=this.Y(h,f,n);if(this.p===1&&G){var a=E.length,C=new Uint8ClampedArray(a*3),F=0;for(var d=0;d<a;d++){var T=E[d];C[F++]=T;C[F++]=T;C[F++]=T;}return C}else if(this.p===3&&this.f){return this.z(E)}else if(this.p===4){if(this.f){if(G){return this.O(E)}return this.r(E)}else if(G){return this.U(E)}}return E}};return ak}();function Z(p,t){return p[t]<<8|p[t+1]}UTIF.JpegDecoder=ak;}());
			
			//UTIF.JpegDecoder = PDFJS.JpegImage;
			
			
			UTIF.encodeImage = function(rgba, w, h, metadata)
			{
				var idf = { "t256":[w], "t257":[h], "t258":[8,8,8,8], "t259":[1], "t262":[2], "t273":[1000], // strips offset
							"t277":[4], "t278":[h], /* rows per strip */          "t279":[w*h*4], // strip byte counts
							"t282":[[72,1]], "t283":[[72,1]], "t284":[1], "t286":[[0,1]], "t287":[[0,1]], "t296":[1], "t305": ["Photopea (UTIF.js)"], "t338":[1]
					};
				if (metadata) for (var i in metadata) idf[i] = metadata[i];
				
				var prfx = new Uint8Array(UTIF.encode([idf]));
				var img = new Uint8Array(rgba);
				var data = new Uint8Array(1000+w*h*4);
				for(var i=0; i<prfx.length; i++) data[i] = prfx[i];
				for(var i=0; i<img .length; i++) data[1000+i] = img[i];
				return data.buffer;
			};
			
			UTIF.encode = function(ifds)
			{
				var data = new Uint8Array(20000), offset = 4, bin = UTIF._binBE;
				data[0]=data[1]=77;  bin.writeUshort(data,2,42);
			
				var ifdo = 8;
				bin.writeUint(data, offset, ifdo);  offset+=4;
				for(var i=0; i<ifds.length; i++)
				{
					var noffs = UTIF._writeIFD(bin, UTIF._types.basic, data, ifdo, ifds[i]);
					ifdo = noffs[1];
					if(i<ifds.length-1) {
						if((ifdo&3)!=0) ifdo+=(4-(ifdo&3));  // make each IFD start at multiple of 4
						bin.writeUint(data, noffs[0], ifdo);
					}
				}
				return data.slice(0, ifdo).buffer;
			};
			
			UTIF.decode = function(buff, prm)
			{
				if(prm==null) prm = {parseMN:true, debug:false};  // read MakerNote, debug
				var data = new Uint8Array(buff), offset = 0;
			
				var id = UTIF._binBE.readASCII(data, offset, 2);  offset+=2;
				var bin = id=="II" ? UTIF._binLE : UTIF._binBE;
				bin.readUshort(data, offset);  offset+=2;
			
				var ifdo = bin.readUint(data, offset);  offset+=4;
				var ifds = [];
				while(true) {
					var cnt = bin.readUshort(data,ifdo), typ = bin.readUshort(data,ifdo+4);  if(cnt!=0) if(typ<1 || 13<typ) {  log("error in TIFF");  break  }					UTIF._readIFD(bin, data, ifdo, ifds, 0, prm);
					
					ifdo = bin.readUint(data, ifdo+2+cnt*12);
					if(ifdo==0) break;
				}
				return ifds;
			};
			
			UTIF.decodeImage = function(buff, img, ifds)
			{
				if(img.data) return;
				var data = new Uint8Array(buff);
				var id = UTIF._binBE.readASCII(data, 0, 2);
			
				if(img["t256"]==null) return;	// No width => probably not an image
				img.isLE = id=="II";
				img.width  = img["t256"][0];  //delete img["t256"];
				img.height = img["t257"][0];  //delete img["t257"];
			
				var cmpr = img["t259"] ? img["t259"][0] : 1;  //delete img["t259"];
				var fo   = img["t266"] ? img["t266"][0] : 1;  //delete img["t266"];
				if(img["t284"] && img["t284"][0]==2) log("PlanarConfiguration 2 should not be used!");
				if(cmpr==7 && img["t258"] && img["t258"].length>3)  img["t258"]=img["t258"].slice(0,3);
			
				var spp = img["t277"]?img["t277"][0]:1;
				var bps = img["t258"]?img["t258"][0]:1;
				var bipp = bps*spp;  // bits per pixel
				/*
				var bipp;  // bits per pixel
				if(img["t258"]) bipp = Math.min(32,img["t258"][0])*img["t258"].length;
				else            bipp = (img["t277"]?img["t277"][0]:1);  
				*/
				// Some .NEF files have t258==14, even though they use 16 bits per pixel
				if(cmpr==1 && img["t279"]!=null && img["t278"] && img["t262"][0]==32803)  {
					bipp = Math.round((img["t279"][0]*8)/(img.width*img["t278"][0]));
				}
				if(img["t50885"] && img["t50885"][0]==4) bipp = img["t258"][0]*3;  // RAW_CANON_40D_SRAW_V103.CR2
				var bipl = Math.ceil(img.width*bipp/8)*8;
				var soff = img["t273"];  if(soff==null || img["t322"]) soff = img["t324"];
				var bcnt = img["t279"];  if(cmpr==1 && soff.length==1) bcnt = [img.height*(bipl>>>3)];  if(bcnt==null || img["t322"]) bcnt = img["t325"];
				//bcnt[0] = Math.min(bcnt[0], data.length);  // Hasselblad, "RAW_HASSELBLAD_H3D39II.3FR"
				var bytes = new Uint8Array(img.height*(bipl>>>3)), bilen = 0;
			
				if(img["t322"]!=null) // tiled
				{
					var tw = img["t322"][0], th = img["t323"][0];
					var tx = Math.floor((img.width  + tw - 1) / tw);
					var ty = Math.floor((img.height + th - 1) / th);
					var tbuff = new Uint8Array(Math.ceil(tw*th*bipp/8)|0);
					console.log("====", tx,ty);
					for(var y=0; y<ty; y++)
						for(var x=0; x<tx; x++)
						{
							var i = y*tx+x;  tbuff.fill(0);
							UTIF.decode._decompress(img,ifds, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo,tw,th);
							// Might be required for 7 too. Need to check
							if (cmpr==6) bytes = tbuff;
							else UTIF._copyTile(tbuff, Math.ceil(tw*bipp/8)|0, th, bytes, Math.ceil(img.width*bipp/8)|0, img.height, Math.ceil(x*tw*bipp/8)|0, y*th);
						}
					bilen = bytes.length*8;
				}
				else	// stripped
				{
					if(soff==null) return;
					var rps = img["t278"] ? img["t278"][0] : img.height;   rps = Math.min(rps, img.height);
					//console.log("====", img.width, rps);
					for(var i=0; i<soff.length; i++)
					{
						UTIF.decode._decompress(img,ifds, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen/8)|0, fo,img.width,rps);
						bilen += bipl * rps;
					}
					bilen = Math.min(bilen, bytes.length*8);
				}
				img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen/8)|0);
			};
			
			UTIF.decode._decompress = function(img,ifds, data, off, len, cmpr, tgt, toff, fo, w, h)  // fill order
			{
				if(img["t271"] && img["t271"][0]=="Panasonic" && img["t45"] && img["t45"][0]==6) cmpr = 34316;
				//console.log("compression", cmpr);
				//var time = Date.now();
				if(cmpr==1/* || (len==tgt.length && cmpr!=32767)*/) for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
				else if(cmpr==2) UTIF.decode._decodeG2 (data, off, len, tgt, toff, w, fo);
				else if(cmpr==3) UTIF.decode._decodeG3 (data, off, len, tgt, toff, w, fo, img["t292"]?((img["t292"][0]&1)==1):false);
				else if(cmpr==4) UTIF.decode._decodeG4 (data, off, len, tgt, toff, w, fo);
				else if(cmpr==5) UTIF.decode._decodeLZW(data, off, len, tgt, toff,8);
				else if(cmpr==6) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
				else if(cmpr==7 || cmpr==34892) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
				else if(cmpr==8 || cmpr==32946) {  var src = new Uint8Array(data.buffer,off+2,len-6);  var bin = pako["inflateRaw"](src);  if(toff+bin.length<=tgt.length) tgt.set(bin,toff);  }
				else if(cmpr==9) UTIF.decode._decodeVC5(data,off,len,tgt,toff,img["t33422"]);
				else if(cmpr==32767) UTIF.decode._decodeARW(img, data, off, len, tgt, toff);
				else if(cmpr==32773) UTIF.decode._decodePackBits(data, off, len, tgt, toff);
				else if(cmpr==32809) UTIF.decode._decodeThunder (data, off, len, tgt, toff);
				else if(cmpr==34316) UTIF.decode._decodePanasonic(img,data,off, len, tgt, toff);
				else if(cmpr==34713) //for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
					UTIF.decode._decodeNikon   (img,ifds, data, off, len, tgt, toff);
				else if(cmpr==34676) UTIF.decode._decodeLogLuv32(img,data, off, len, tgt, toff);  
				else log("Unknown compression", cmpr);
				
				//console.log(Date.now()-time);
				
				var bps = (img["t258"]?Math.min(32,img["t258"][0]):1);
				var noc = (img["t277"]?img["t277"][0]:1), bpp=(bps*noc)>>>3, bpl = Math.ceil(bps*noc*w/8);
				
				// convert to Little Endian  /*
				if(bps==16 && !img.isLE && img["t33422"]==null)  // not DNG
					for(var y=0; y<h; y++) {
						//console.log("fixing endianity");
						var roff = toff+y*bpl;
						for(var x=1; x<bpl; x+=2) {  var t=tgt[roff+x];  tgt[roff+x]=tgt[roff+x-1];  tgt[roff+x-1]=t;  }
					}  //*/
			
				if(img["t317"] && img["t317"][0]==2)
				{
					for(var y=0; y<h; y++)
					{
						var ntoff = toff+y*bpl;
						if(bps==16) for(var j=bpp; j<bpl; j+=2) {
							var nv = ((tgt[ntoff+j+1]<<8)|tgt[ntoff+j])  +  ((tgt[ntoff+j-bpp+1]<<8)|tgt[ntoff+j-bpp]);
							tgt[ntoff+j] = nv&255;  tgt[ntoff+j+1] = (nv>>>8)&255;  
						}
						else if(noc==3) for(var j=  3; j<bpl; j+=3)
						{
							tgt[ntoff+j  ] = (tgt[ntoff+j  ] + tgt[ntoff+j-3])&255;
							tgt[ntoff+j+1] = (tgt[ntoff+j+1] + tgt[ntoff+j-2])&255;
							tgt[ntoff+j+2] = (tgt[ntoff+j+2] + tgt[ntoff+j-1])&255;
						}
						else for(var j=bpp; j<bpl; j++) tgt[ntoff+j] = (tgt[ntoff+j] + tgt[ntoff+j-bpp])&255;
					}
				}
			};
			
					UTIF.decode._decodePanasonic = function(img, data, off, len, tgt, toff) {
			
							var img_buffer = data.buffer;
				
							var rawWidth = img["t2"][0];
							var rawHeight = img["t3"][0];
							var bitsPerSample = img["t10"][0];
							var RW2_Format =  img["t45"][0];
				
							var bidx = 0;
							var imageIndex = 0;
							var vpos = 0;
							var byte = 0;
							var bytes = (RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16));
							var i, j, sh, pred=[0,0], nonz=[0,0], isOdd, idx = 0, pixel_base;
							var row, col, crow;
							var buffer = new Uint8Array(0x4000);
							var result = new Uint16Array(tgt.buffer);
			
							function getDataRaw(bits){
								if (vpos == 0) {
									var arr_a = new Uint8Array(img_buffer, off+imageIndex + 0x1ff8, 0x4000-0x1ff8);
									var arr_b = new Uint8Array(img_buffer, off+imageIndex, 0x1ff8);
									buffer.set(arr_a);  
									buffer.set(arr_b, arr_a.length);
									imageIndex += 0x4000;
								}
								if(RW2_Format == 5) {
									for (i = 0; i < 16; i++){
										bytes[i] = buffer[vpos++];
										vpos &= 0x3FFF;
									}
								} else {
									vpos = (vpos - bits) & 0x1ffff;
									byte = vpos >> 3 ^ 0x3ff0;
									return (buffer[byte] | buffer[byte + 1] << 8) >> (vpos & 7) & ~((-1) << bits);
								}
							}
							// Raw Format 6
							function getBufferDataRW6(i) {
								return buffer[vpos + 15 - i];
							}
							function readPageRW6() {
								bytes[0] = (getBufferDataRW6(0) << 6) | (getBufferDataRW6(1) >> 2); // 14 bit
								bytes[1] = (((getBufferDataRW6(1) & 0x3) << 12) | (getBufferDataRW6(2) << 4) | (getBufferDataRW6(3) >> 4)) & 0x3fff;
								bytes[2] = (getBufferDataRW6(3) >> 2) & 0x3;
								bytes[3] = ((getBufferDataRW6(3) & 0x3) << 8) | getBufferDataRW6(4);
								bytes[4] = (getBufferDataRW6(5) << 2) | (getBufferDataRW6(6) >> 6);
								bytes[5] = ((getBufferDataRW6(6) & 0x3f) << 4) | (getBufferDataRW6(7) >> 4);
								bytes[6] = (getBufferDataRW6(7) >> 2) & 0x3;
								bytes[7] = ((getBufferDataRW6(7) & 0x3) << 8) | getBufferDataRW6(8);
								bytes[8] = ((getBufferDataRW6(9) << 2) & 0x3fc) | (getBufferDataRW6(10) >> 6);
								bytes[9] = ((getBufferDataRW6(10) << 4) | (getBufferDataRW6(11) >> 4)) & 0x3ff;
								bytes[10] = (getBufferDataRW6(11) >> 2) & 0x3;
								bytes[11] = ((getBufferDataRW6(11) & 0x3) << 8) | getBufferDataRW6(12);
								bytes[12] = (((getBufferDataRW6(13) << 2) & 0x3fc) | getBufferDataRW6(14) >> 6) & 0x3ff;
								bytes[13] = ((getBufferDataRW6(14) << 4) | (getBufferDataRW6(15) >> 4)) & 0x3ff;
								vpos += 16;
								byte = 0;
							}
							function readPageRw6_bps12() {
								bytes[0] = (getBufferDataRW6(0) << 4) | (getBufferDataRW6(1) >> 4);
								bytes[1] = (((getBufferDataRW6(1) & 0xf) << 8) | (getBufferDataRW6(2))) & 0xfff;
								bytes[2] = (getBufferDataRW6(3) >> 6) & 0x3;
								bytes[3] = ((getBufferDataRW6(3) & 0x3f) << 2) | (getBufferDataRW6(4) >> 6);
								bytes[4] = ((getBufferDataRW6(4) & 0x3f) << 2) | (getBufferDataRW6(5) >> 6);
								bytes[5] = ((getBufferDataRW6(5) & 0x3f) << 2) | (getBufferDataRW6(6) >> 6);
								bytes[6] = (getBufferDataRW6(6) >> 4) & 0x3;
								bytes[7] = ((getBufferDataRW6(6) & 0xf) << 4) | (getBufferDataRW6(7) >> 4);
								bytes[8] = ((getBufferDataRW6(7) & 0xf) << 4) | (getBufferDataRW6(8) >> 4);
								bytes[9] = ((getBufferDataRW6(8) & 0xf) << 4) | (getBufferDataRW6(9) >> 4);
								bytes[10] = (getBufferDataRW6(9) >> 2) & 0x3;
								bytes[11] = ((getBufferDataRW6(9) & 0x3) << 6) | (getBufferDataRW6(10) >> 2);
								bytes[12] = ((getBufferDataRW6(10) & 0x3) << 6) | (getBufferDataRW6(11) >> 2);
								bytes[13] = ((getBufferDataRW6(11) & 0x3) << 6) | (getBufferDataRW6(12) >> 2);
								bytes[14] = getBufferDataRW6(12) & 0x3;
								bytes[15] = getBufferDataRW6(13);
								bytes[16] = getBufferDataRW6(14);
								bytes[17] = getBufferDataRW6(15);
			
								vpos += 16;
								byte = 0;                    
							}
							// Main loop
							function resetPredNonzeros(){
								pred[0]=0; pred[1]=0;
								nonz[0]=0; nonz[1]=0;
							}
							if (RW2_Format == 7) {
								throw RW2_Format;
			
								// Skatch of version 7 
								/*
								var pixels_per_block = bitsPerSample == 14 ? 9 : 10;
									rowbytes = 0|(rawWidth / pixels_per_block * 16);
								for (row = 0; row < rawHeight - 15; row += 16) {
									var rowstoread = Math.min(16, rawHeight - row);
									var readlen = rowbytes*rowstoread;
									buffer = new Uint8Array(image.slice(bidx, bidx+readlen));
									vpos = 0;
									bidx += readlen; 
									i = 0;
									for (crow = 0; crow < rowstoread; crow++) {
										idx = (row + crow) * rawWidth;
										for (col = 0; col <= rawWidth - pixels_per_block; col += pixels_per_block) {
											for(j=0; j < pixels_per_block; j++) bytes[j] = buffer[i++];
											if (bitsPerSample == 12) {
												result[idx ] = ((bytes[1] & 0xF) << 8) + bytes[0];
												result[idx + 1] = 16 * bytes[2] + (bytes[1] >> 4);
												result[idx + 2] = ((bytes[4] & 0xF) << 8) + bytes[3];
												result[idx + 3] = 16 * bytes[5] + (bytes[4] >> 4);
												result[idx + 4] = ((bytes[7] & 0xF) << 8) + bytes[6];
												result[idx + 5] = 16 * bytes[8] + (bytes[7] >> 4);
												result[idx + 6] = ((bytes[10] & 0xF) << 8) + bytes[9];
												result[idx + 7] = 16 * bytes[11] + (bytes[10] >> 4);
												result[idx + 8] = ((bytes[13] & 0xF) << 8) + bytes[12];
												result[idx + 9] = 16 * bytes[14] + (bytes[13] >> 4);
											} else if (bitsPerSample == 14) {
												result[idx] = bytes[0] + ((bytes[1] & 0x3F) << 8);
												result[idx + 1] = (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);
												result[idx + 2] = (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);
												result[idx + 3] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);
												result[idx + 4] = bytes[7] + ((bytes[8] & 0x3F) << 8);
												result[idx + 5] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);
												result[idx + 6] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
												result[idx + 7] = ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);
												result[idx + 8] = bytes[14] + ((bytes[15] & 0x3F) << 8);
											}
										}
									}
								}
								*/
							} 
							else if(RW2_Format == 6) {
								var is12bit = bitsPerSample == 12,
									readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6,
									pixelsPerBlock = is12bit ? 14 : 11,
									pixelbase0 = is12bit ? 0x80 : 0x200,
									pixelbase_compare = is12bit ? 0x800 : 0x2000,
									spix_compare = is12bit ? 0x3fff : 0xffff,
									pixel_mask = is12bit ? 0xfff : 0x3fff,
									blocksperrow = rawWidth / pixelsPerBlock, 
									rowbytes = blocksperrow * 16,
									bufferSize = is12bit ? 18 : 14;
			
								for (row = 0; row < rawHeight - 15; row += 16) {
									var rowstoread = Math.min(16, rawHeight - row);
									var readlen = rowbytes*rowstoread;
									buffer = new Uint8Array(img_buffer, off+bidx, readlen);//new Uint8Array(image.slice(bidx, bidx+readlen));
									vpos = 0;
									bidx += readlen; 
									for (crow = 0, col = 0; crow < rowstoread; crow++, col = 0) {
										idx = (row + crow) * rawWidth;
										for (var rblock = 0; rblock < blocksperrow; rblock++) {
											readPageRw6Fn();
											resetPredNonzeros();
											sh=0; pixel_base=0;
											for (i = 0; i < pixelsPerBlock; i++){
												isOdd = i & 1;
												if (i % 3 == 2) {
													var base = byte < bufferSize ? bytes[byte++] : 0;
													if (base == 3) base = 4;
													pixel_base = pixelbase0 << base;
													sh = 1 << base;
												}
												var epixel = byte < bufferSize ? bytes[byte++] : 0;
												if (pred[isOdd]) {
													epixel *= sh;
													if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base)
														epixel += nonz[isOdd] - pixel_base;
													nonz[isOdd] = epixel;
												} else {
													pred[isOdd] = epixel;
													if (epixel)
														nonz[isOdd] = epixel;
													else
														epixel = nonz[isOdd];
												}
												result[idx + col++] = (epixel - 0xf) <= spix_compare ? (epixel - 0xf) & spix_compare : ((epixel + 0x7ffffff1) >> 0x1f) & pixel_mask;
											}
										}
									}
								}
							} 
							else if (RW2_Format == 5) { 
								var blockSize = bitsPerSample == 12 ? 10 : 9;
								for (row = 0; row < rawHeight; row++) {
									for (col = 0; col < rawWidth; col+=blockSize) {
										getDataRaw(0);
										// Tuhle podminku pouziva i RW2_Format 7 
										if (bitsPerSample == 12) {
											result[idx++] = ((bytes[1] & 0xF) << 8) + bytes[0];
											result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);
											result[idx++] = ((bytes[4] & 0xF) << 8) + bytes[3];
											result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);
											result[idx++] = ((bytes[7] & 0xF) << 8) + bytes[6];
											result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);
											result[idx++] = ((bytes[10] & 0xF) << 8) + bytes[9];
											result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);
											result[idx++] = ((bytes[13] & 0xF) << 8) + bytes[12];
											result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);
										} else if (bitsPerSample == 14) {
											result[idx++] = bytes[0] + ((bytes[1] & 0x3F) << 8);
											result[idx++] = (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);
											result[idx++] = (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);
											result[idx++] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);
											result[idx++] = bytes[7] + ((bytes[8] & 0x3F) << 8);
											result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);
											result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
											result[idx++] = ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);
											result[idx++] = bytes[14] + ((bytes[15] & 0x3F) << 8);
										}
									}
								}
								//console.log(result[1000000 - 1])
							} else if(RW2_Format == 4) {
								for (row = 0; row < rawHeight; row++){
									for(col = 0; col < rawWidth; col++){
										i = col % 14;
										isOdd = i & 1;
										if (i==0) resetPredNonzeros();
										if (i%3 == 2) 
											sh = 4 >> (3 - getDataRaw(2));
										if (nonz[isOdd]) {
											j = getDataRaw(8);
											if(j != 0){
												pred[isOdd] -= 0x80 << sh;
												if (pred[isOdd] < 0 || sh == 4) 
													pred[isOdd] &= ~((-1) << sh);
												pred[isOdd] += j << sh;
											}
										} else {
											nonz[isOdd] = getDataRaw(8);
											if(nonz[isOdd] || i > 11)
												pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);
										}
										result[idx++] = pred[col & 1];
									}
								}
							} 
							else throw RW2_Format;
						};
			
			
			UTIF.decode._decodeVC5 = function(){var x=[1,0,1,0,2,2,1,1,3,7,1,2,5,25,1,3,6,48,1,4,6,54,1,5,7,111,1,8,7,99,1,6,7,105,12,0,7,107,1,7,8,209,20,0,8,212,1,9,8,220,1,10,9,393,1,11,9,394,32,0,9,416,1,12,9,427,1,13,10,887,1,18,10,784,1,14,10,790,1,15,10,835,60,0,10,852,1,16,10,885,1,17,11,1571,1,19,11,1668,1,20,11,1669,100,0,11,1707,1,21,11,1772,1,22,12,3547,1,29,12,3164,1,24,12,3166,1,25,12,3140,1,23,12,3413,1,26,12,3537,1,27,12,3539,1,28,13,7093,1,35,13,6283,1,30,13,6331,1,31,13,6335,180,0,13,6824,1,32,13,7072,1,33,13,7077,320,0,13,7076,1,34,14,12565,1,36,14,12661,1,37,14,12669,1,38,14,13651,1,39,14,14184,1,40,15,28295,1,46,15,28371,1,47,15,25320,1,42,15,25336,1,43,15,25128,1,41,15,27300,1,44,15,28293,1,45,16,50259,1,48,16,50643,1,49,16,50675,1,50,16,56740,1,53,16,56584,1,51,16,56588,1,52,17,113483,1,61,17,113482,1,60,17,101285,1,55,17,101349,1,56,17,109205,1,57,17,109207,1,58,17,100516,1,54,17,113171,1,59,18,202568,1,62,18,202696,1,63,18,218408,1,64,18,218412,1,65,18,226340,1,66,18,226356,1,67,18,226358,1,68,19,402068,1,69,19,405138,1,70,19,405394,1,71,19,436818,1,72,19,436826,1,73,19,452714,1,75,19,452718,1,76,19,452682,1,74,20,804138,1,77,20,810279,1,78,20,810790,1,79,20,873638,1,80,20,873654,1,81,20,905366,1,82,20,905430,1,83,20,905438,1,84,21,1608278,1,85,21,1620557,1,86,21,1621582,1,87,21,1621583,1,88,21,1747310,1,89,21,1810734,1,90,21,1810735,1,91,21,1810863,1,92,21,1810879,1,93,22,3621725,1,99,22,3621757,1,100,22,3241112,1,94,22,3494556,1,95,22,3494557,1,96,22,3494622,1,97,22,3494623,1,98,23,6482227,1,102,23,6433117,1,101,23,6989117,1,103,23,6989119,1,105,23,6989118,1,104,23,7243449,1,106,23,7243512,1,107,24,13978233,1,111,24,12964453,1,109,24,12866232,1,108,24,14486897,1,113,24,13978232,1,110,24,14486896,1,112,24,14487026,1,114,24,14487027,1,115,25,25732598,1,225,25,25732597,1,189,25,25732596,1,188,25,25732595,1,203,25,25732594,1,202,25,25732593,1,197,25,25732592,1,207,25,25732591,1,169,25,25732590,1,223,25,25732589,1,159,25,25732522,1,235,25,25732579,1,152,25,25732575,1,192,25,25732489,1,179,25,25732573,1,201,25,25732472,1,172,25,25732576,1,149,25,25732488,1,178,25,25732566,1,120,25,25732571,1,219,25,25732577,1,150,25,25732487,1,127,25,25732506,1,211,25,25732548,1,125,25,25732588,1,158,25,25732486,1,247,25,25732467,1,238,25,25732508,1,163,25,25732552,1,228,25,25732603,1,183,25,25732513,1,217,25,25732587,1,168,25,25732520,1,122,25,25732484,1,128,25,25732562,1,249,25,25732505,1,187,25,25732504,1,186,25,25732483,1,136,25,25928905,1,181,25,25732560,1,255,25,25732500,1,230,25,25732482,1,135,25,25732555,1,233,25,25732568,1,222,25,25732583,1,145,25,25732481,1,134,25,25732586,1,167,25,25732521,1,248,25,25732518,1,209,25,25732480,1,243,25,25732512,1,216,25,25732509,1,164,25,25732547,1,140,25,25732479,1,157,25,25732544,1,239,25,25732574,1,191,25,25732564,1,251,25,25732478,1,156,25,25732546,1,139,25,25732498,1,242,25,25732557,1,133,25,25732477,1,162,25,25732515,1,213,25,25732584,1,165,25,25732514,1,212,25,25732476,1,227,25,25732494,1,198,25,25732531,1,236,25,25732530,1,234,25,25732529,1,117,25,25732528,1,215,25,25732527,1,124,25,25732526,1,123,25,25732525,1,254,25,25732524,1,253,25,25732523,1,148,25,25732570,1,218,25,25732580,1,146,25,25732581,1,147,25,25732569,1,224,25,25732533,1,143,25,25732540,1,184,25,25732541,1,185,25,25732585,1,166,25,25732556,1,132,25,25732485,1,129,25,25732563,1,250,25,25732578,1,151,25,25732501,1,119,25,25732502,1,193,25,25732536,1,176,25,25732496,1,245,25,25732553,1,229,25,25732516,1,206,25,25732582,1,144,25,25732517,1,208,25,25732558,1,137,25,25732543,1,241,25,25732466,1,237,25,25732507,1,190,25,25732542,1,240,25,25732551,1,131,25,25732554,1,232,25,25732565,1,252,25,25732475,1,171,25,25732493,1,205,25,25732492,1,204,25,25732491,1,118,25,25732490,1,214,25,25928904,1,180,25,25732549,1,126,25,25732602,1,182,25,25732539,1,175,25,25732545,1,141,25,25732559,1,138,25,25732537,1,177,25,25732534,1,153,25,25732503,1,194,25,25732606,1,160,25,25732567,1,121,25,25732538,1,174,25,25732497,1,246,25,25732550,1,130,25,25732572,1,200,25,25732474,1,170,25,25732511,1,221,25,25732601,1,196,25,25732532,1,142,25,25732519,1,210,25,25732495,1,199,25,25732605,1,155,25,25732535,1,154,25,25732499,1,244,25,25732510,1,220,25,25732600,1,195,25,25732607,1,161,25,25732604,1,231,25,25732473,1,173,25,25732599,1,226,26,51465122,1,116,26,51465123,0,1],o,C,k,P=[3,3,3,3,2,2,2,1,1,1],V=24576,ar=16384,H=8192,az=ar|H;
			function d(t){var E=t[1],h=t[0][E>>>3]>>>7-(E&7)&1;t[1]++;return h}function ag(t,E){if(o==null){o={};
			for(var h=0;h<x.length;h+=4)o[x[h+1]]=x.slice(h,h+4);}var L=d(t),g=o[L];while(g==null){L=L<<1|d(t);g=o[L];}var n=g[3];
			if(n!=0)n=d(t)==0?n:-n;E[0]=g[2];E[1]=n;}function m(t,E){for(var h=0;h<E;h++){if((t&1)==1)t++;t=t>>>1;}return t}function A(t,E){return t>>E}function O(t,E,h,L,g,n){E[h]=A(A(11*t[g]-4*t[g+n]+t[g+n+n]+4,3)+t[L],1);
			E[h+n]=A(A(5*t[g]+4*t[g+n]-t[g+n+n]+4,3)-t[L],1);}function J(t,E,h,L,g,n){var W=t[g-n]-t[g+n],j=t[g],$=t[L];
			E[h]=A(A(W+4,3)+j+$,1);E[h+n]=A(A(-W+4,3)+j-$,1);}function y(t,E,h,L,g,n){E[h]=A(A(5*t[g]+4*t[g-n]-t[g-n-n]+4,3)+t[L],1);
			E[h+n]=A(A(11*t[g]-4*t[g-n]+t[g-n-n]+4,3)-t[L],1);}function q(t){t=t<0?0:t>4095?4095:t;t=k[t]>>>2;return t}function av(t,E,h,L,g,n){L=new Uint16Array(L.buffer);
			var W=Date.now(),j=UTIF._binBE,$=E+h,r,u,X,I,ax,R,aa,i,T,B;E+=4;var a5=n[0]==1;
			while(E<$){var S=j.readShort(t,E),s=j.readUshort(t,E+2);E+=4;if(S==12)r=s;else if(S==20)u=s;else if(S==21)X=s;
			else if(S==48)I=s;else if(S==53)ax=s;else if(S==35);else if(S==62)R=s;else if(S==101);else if(S==109)aa=s;
			else if(S==84);else if(S==106);else if(S==107);else if(S==108);else if(S==102);else if(S==104)i=s;
			else if(S==105);else {var F=S<0?-S:S,D=F&65280,_=0;if(F&az){if(F&H){_=s&65535;_+=(F&255)<<16;}else {_=s&65535;}}if((F&V)==V){if(T==null){T=[];
			for(var M=0;M<4;M++)T[M]=new Int16Array((u>>>1)*(X>>>1));B=new Int16Array((u>>>1)*(X>>>1));C=new Int16Array(1024);
			for(var M=0;M<1024;M++){var aG=M-512,p=Math.abs(aG),r=Math.floor(768*p*p*p/(255*255*255))+p;C[M]=Math.sign(aG)*r;}k=new Uint16Array(4096);
			var aA=(1<<16)-1;for(var M=0;M<4096;M++){var at=M,a1=aA*(Math.pow(113,at/4095)-1)/112;k[M]=Math.min(a1,aA);}}var w=T[R],v=m(u,1+P[I]),N=m(X,1+P[I]);
			if(I==0){for(var b=0;b<N;b++)for(var G=0;G<v;G++){var c=E+(b*v+G)*2;w[b*(u>>>1)+G]=t[c]<<8|t[c+1];}}else {var a7=[t,E*8],a4=[],ay=0,aw=v*N,f=[0,0],Q=0,s=0;
			while(ay<aw){ag(a7,f);Q=f[0];s=f[1];while(Q>0){a4[ay++]=s;Q--;}}var l=(I-1)%3,aF=l!=1?v:0,a2=l!=0?N:0;
			for(var b=0;b<N;b++){var af=(b+a2)*(u>>>1)+aF,au=b*v;for(var G=0;G<v;G++)w[af+G]=C[a4[au+G]+512]*ax;}if(l==2){var i=u>>>1,an=v*2,a9=N*2;
			for(var b=0;b<N;b++){for(var G=0;G<an;G++){var M=b*2*i+G,a=b*i+G,e=N*i+a;if(b==0)O(w,B,M,e,a,i);else if(b==N-1)y(w,B,M,e,a,i);
			else J(w,B,M,e,a,i);}}var Z=w;w=B;B=Z;for(var b=0;b<a9;b++){for(var G=0;G<v;G++){var M=b*i+2*G,a=b*i+G,e=v+a;
			if(G==0)O(w,B,M,e,a,1);else if(G==v-1)y(w,B,M,e,a,1);else J(w,B,M,e,a,1);}}var Z=w;w=B;B=Z;var aC=[],aB=2-~~((I-1)/3);
			for(var K=0;K<3;K++)aC[K]=aa>>14-K*2&3;var a6=aC[aB];if(a6!=0)for(var b=0;b<a9;b++)for(var G=0;G<an;
			G++){var M=b*i+G;w[M]=w[M]<<a6;}}}if(I==9&&R==3){var a8=T[0],ab=T[1],aq=T[2],as=T[3];for(var b=0;b<X;
			b+=2)for(var G=0;G<u;G+=2){var U=b*u+G,c=(b>>>1)*(u>>>1)+(G>>>1),z=a8[c],ao=ab[c]-2048,ak=aq[c]-2048,ad=as[c]-2048,aj=(ao<<1)+z,a0=(ak<<1)+z,aH=z+ad,am=z-ad;
			if(a5){L[U]=q(aH);L[U+1]=q(a0);L[U+u]=q(aj);L[U+u+1]=q(am);}else {L[U]=q(aj);L[U+1]=q(aH);L[U+u]=q(am);
			L[U+u+1]=q(a0);}}}E+=_*4;}else if(F==16388){E+=_*4;}else if(D==8192||D==8448||D==9216);else throw F.toString(16)}}console.log(Date.now()-W);}return av}();
			
			
			
			UTIF.decode._decodeLogLuv32 = function(img, data, off, len, tgt, toff) {
				var w = img.width, qw=w*4;
				var io = 0, out = new Uint8Array(qw);
				
				while(io<len) {
					var oo=0;
					while(oo<qw) {
						var c = data[off+io]; io++;
						if(c<128) {       for(var j=0; j<c; j++) out[oo+j] = data[off+io+j];  oo+=c;  io+=c;  }
						else {  c=c-126;  for(var j=0; j<c; j++) out[oo+j] = data[off+io  ];  oo+=c;  io++ ;  }
					}
					
					for(var x=0; x<w; x++) {
						tgt[toff+0] = out[x];
						tgt[toff+1] = out[x+w];
						tgt[toff+2] = out[x+w*2];
						tgt[toff+4] = out[x+w*3];
						toff+=6;
					}
				}
			};
			
			UTIF.decode._ljpeg_diff = function(data, prm, huff) {
				var getbithuff   = UTIF.decode._getbithuff;
				var len, diff;
				len  = getbithuff(data, prm, huff[0], huff);
				diff = getbithuff(data, prm, len, 0);
				if ((diff & (1 << (len-1))) == 0)  diff -= (1 << len) - 1;
				return diff;
			};
			UTIF.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
				var raw_width = img["t256"][0], height=img["t257"][0], tiff_bps=img["t258"][0];
				var bin=(img.isLE ? UTIF._binLE : UTIF._binBE);
				//console.log(raw_width, height, tiff_bps, raw_width*height, src_length);
				var arw2 = (raw_width*height == src_length) || (raw_width*height*1.5 == src_length);
				//arw2 = true;
				//console.log("ARW2: ", arw2, raw_width*height, src_length, tgt.length);
				if(!arw2) {  //"sony_arw_load_raw"; // not arw2
					height+=8;
					var prm = [off,0,0,0];
					var huff = new Uint16Array(32770);
					var tab = [ 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,
						0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 ];
					var i, c, n, col, row, sum=0;
					var ljpeg_diff = UTIF.decode._ljpeg_diff;
			
					huff[0] = 15;
					for (n=i=0; i < 18; i++) {
						var lim = 32768 >>> (tab[i] >>> 8);
						for(var c=0; c<lim; c++) huff[++n] = tab[i];
					}
					for (col = raw_width; col--; )
						for (row=0; row < height+1; row+=2) {
							if (row == height) row = 1;
							sum += ljpeg_diff(inp, prm, huff);
							if (row < height) {
								var clr =  (sum)&4095;
								UTIF.decode._putsF(tgt, (row*raw_width+col)*tiff_bps, clr<<(16-tiff_bps));
							}
						}
					return;
				}
				if(raw_width*height*1.5==src_length) {
					//console.log("weird compression");
					for(var i=0; i<src_length; i+=3) {  var b0=inp[off+i+0], b1=inp[off+i+1], b2=inp[off+i+2];  
						tgt[toff+i]=(b1<<4)|(b0>>>4);  tgt[toff+i+1]=(b0<<4)|(b2>>>4);  tgt[toff+i+2]=(b2<<4)|(b1>>>4);  }
					return;
				}
				
				var pix = new Uint16Array(16);
				var row, col, val, max, min, imax, imin, sh, bit, i,    dp;
				
				var data = new Uint8Array(raw_width+1);
				for (row=0; row < height; row++) {
					//fread (data, 1, raw_width, ifp);
					for(var j=0; j<raw_width; j++) data[j]=inp[off++];
					for (dp=0, col=0; col < raw_width-30; dp+=16) {
						max  = 0x7ff & (val = bin.readUint(data,dp));
						min  = 0x7ff & (val >>> 11);
						imax = 0x0f & (val >>> 22);
						imin = 0x0f & (val >>> 26);
						for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);
						for (bit=30, i=0; i < 16; i++)
							if      (i == imax) pix[i] = max;
							else if (i == imin) pix[i] = min;
							else {
								pix[i] = ((bin.readUshort(data, dp+(bit >> 3)) >>> (bit & 7) & 0x7f) << sh) + min;
								if (pix[i] > 0x7ff) pix[i] = 0x7ff;
								bit += 7;
							}
						for (i=0; i < 16; i++, col+=2) {
							//RAW(row,col) = curve[pix[i] << 1] >> 2;
							var clr =  pix[i]<<1;   //clr = 0xffff;
							UTIF.decode._putsF(tgt, (row*raw_width+col)*tiff_bps, clr<<(16-tiff_bps));
						}
						col -= col & 1 ? 1:31;
					}
				}
			};
			
			UTIF.decode._decodeNikon = function(img,imgs, data, off, src_length, tgt, toff)
			{
				var nikon_tree = [
				[ 0, 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy */
				  5,4,3,6,2,7,1,0,8,9,11,10,12 ],
				[ 0, 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy after split */
				  0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 ],
				[ 0, 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */
				  5,4,6,3,7,2,8,1,9,0,10,11,12 ],
				[ 0, 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	/* 14-bit lossy */
				  5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 ],
				[ 0, 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	/* 14-bit lossy after split */
				  8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 ],
				[ 0, 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	/* 14-bit lossless */
				  7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 ] ];
				  
				var raw_width = img["t256"][0], height=img["t257"][0], tiff_bps=img["t258"][0];
				
				var tree = 0, split = 0;
				var make_decoder = UTIF.decode._make_decoder;
				var getbithuff   = UTIF.decode._getbithuff;
				
				var mn = imgs[0].exifIFD.makerNote, md = mn["t150"]?mn["t150"]:mn["t140"], mdo=0;  //console.log(mn,md);
				//console.log(md[0].toString(16), md[1].toString(16), tiff_bps);
				var ver0 = md[mdo++], ver1 = md[mdo++];
				if (ver0 == 0x49 || ver1 == 0x58)  mdo+=2110;
				if (ver0 == 0x46) tree = 2;
				if (tiff_bps == 14) tree += 3;
				
				var vpred = [[0,0],[0,0]], bin=(img.isLE ? UTIF._binLE : UTIF._binBE);
				for(var i=0; i<2; i++) for(var j=0; j<2; j++) {  vpred[i][j] = bin.readShort(md,mdo);  mdo+=2;   }  // not sure here ... [i][j] or [j][i]
				//console.log(vpred);
				
				
				var max = 1 << tiff_bps & 0x7fff, step=0;
				var csize = bin.readShort(md,mdo);  mdo+=2;
				if (csize > 1) step = Math.floor(max / (csize-1));
				if (ver0 == 0x44 && ver1 == 0x20 && step > 0)  split = bin.readShort(md,562);
				
				
				var i;
				var row, col;
				var len, shl, diff;
				var hpred = [0,0];
				var huff = make_decoder(nikon_tree[tree]);
				
				//var g_input_offset=0, bitbuf=0, vbits=0, reset=0;
				var prm = [off,0,0,0];
				//console.log(split);  split = 170;
				
				for (row=0; row < height; row++) {
					if (split && row == split) {
						//free (huff);
						huff = make_decoder (nikon_tree[tree+1]);
						//max_v += (min_v = 16) << 1;
					}
					for (col=0; col < raw_width; col++) {
						i = getbithuff(data,prm,huff[0],huff);
						len = i  & 15;
						shl = i >>> 4;
						diff = (((getbithuff(data,prm,len-shl,0) << 1) + 1) << shl) >>> 1;
						if ((diff & (1 << (len-1))) == 0)
							diff -= (1 << len) - (shl==0?1:0);
						if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
						else         hpred[col & 1] += diff;
						
						var clr = Math.min(Math.max(hpred[col & 1],0),(1<<tiff_bps)-1);
						var bti = (row*raw_width+col)*tiff_bps;  
						UTIF.decode._putsF(tgt, bti, clr<<(16-tiff_bps));
					}
				}
			};
			// put 16 bits
			UTIF.decode._putsF= function(dt, pos, val) {  val = val<<(8-(pos&7));  var o=(pos>>>3);  dt[o]|=val>>>16;  dt[o+1]|=val>>>8;  dt[o+2]|=val;  };
			
			
			UTIF.decode._getbithuff = function(data,prm,nbits, huff) {
				var zero_after_ff = 0;
				UTIF.decode._get_byte;
				var c;
			  
				var off=prm[0], bitbuf=prm[1], vbits=prm[2], reset=prm[3];
			
				//if (nbits > 25) return 0;
				//if (nbits <  0) return bitbuf = vbits = reset = 0;
				if (nbits == 0 || vbits < 0) return 0; 
				while (!reset && vbits < nbits && (c = data[off++]) != -1 &&
					!(reset = zero_after_ff)) {
					//console.log("byte read into c");
					bitbuf = (bitbuf << 8) + c;
					vbits += 8;
				} 
				c = (bitbuf << (32-vbits)) >>> (32-nbits);
				if (huff) {
					vbits -= huff[c+1] >>> 8;  //console.log(c, huff[c]>>8);
					c =  huff[c+1]&255;
				} else
					vbits -= nbits;
				if (vbits < 0) throw "e";
			  
				prm[0]=off;  prm[1]=bitbuf;  prm[2]=vbits;  prm[3]=reset;
			  
				return c;
			};
			
			UTIF.decode._make_decoder = function(source) {
				var max, len, h, i, j;
				var huff = [];
			
				for (max=16; max!=0 && !source[max]; max--);
				var si=17;
				
				huff[0] = max;
				for (h=len=1; len <= max; len++)
					for (i=0; i < source[len]; i++, ++si)
						for (j=0; j < 1 << (max-len); j++)
							if (h <= 1 << max)
								huff[h++] = (len << 8) | source[si];
				return huff;
			};
			
			UTIF.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff)
			{
				len = Math.min(len, data.length-off);
				var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
				
				if (tables) {
					var SOI = 216, EOI = 217, boff = 0;
					for (var i=0; i<(tlen-1); i++)
					{
						// Skip EOI marker from JPEGTables
						if (tables[i]==255 && tables[i+1]==EOI) break;
						buff[boff++] = tables[i];
					}
			
					// Skip SOI marker from data
					var byte1 = data[off], byte2 = data[off + 1];
					if (byte1!=255 || byte2!=SOI)
					{
						buff[boff++] = byte1;
						buff[boff++] = byte2;
					}
					for (var i=2; i<len; i++) buff[boff++] = data[off+i];
				}
				else for (var i=0; i<len; i++) buff[i] = data[off+i];
			
				if(img["t262"][0]==32803 || (img["t259"][0]==7 && img["t262"][0]==34892)) // lossless JPEG (used in DNG files)
				{
					var bps = img["t258"][0];//, dcdr = new LosslessJpegDecoder();
					//var time = Date.now();
					var out = UTIF.LosslessJpegDecode(buff), olen=out.length;  //console.log(olen);
					//var out = ULLJPG(buff), olen=out.length;  //console.log(olen);
					//console.log(Date.now()-time);
					
					if(bps==16) {
						if(img.isLE) for(var i=0; i<olen; i++ ) {  tgt[toff+(i<<1)] = (out[i]&255);  tgt[toff+(i<<1)+1] = (out[i]>>>8);  }
						else         for(var i=0; i<olen; i++ ) {  tgt[toff+(i<<1)] = (out[i]>>>8);  tgt[toff+(i<<1)+1] = (out[i]&255);  }
					}
					else if(bps==14 || bps==12 || bps==10) {  // 4 * 14 == 56 == 7 * 8
						var rst = 16-bps;
						for(var i=0; i<olen; i++) UTIF.decode._putsF(tgt, i*bps, out[i]<<rst);
					}
					else if(bps==8) {
						for(var i=0; i<olen; i++) tgt[toff+i]=out[i];
					}
					else throw new Error("unsupported bit depth "+bps);
				}
				else
				{
					var parser = new UTIF.JpegDecoder();  parser.parse(buff);
					var decoded = parser.getData({"width":parser.width,"height":parser.height,"forceRGB":true,"isSourcePDF":false});
					for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];
				}
			
				// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
				// RGB format, so updating the tag value
				if(img["t262"][0] == 6)  img["t262"][0] = 2;
			};
			
			UTIF.decode._decodeOldJPEGInit = function(img, data, off, len)
			{
				var SOI = 216, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS = 218;
				var joff = 0, soff = 0, tables, sosMarker, isTiled = false, i, j, k;
				var jpgIchgFmt    = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
				var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
				var soffTag       = img["t324"] || img["t273"] || jpgIchgFmt;
				var ycbcrss       = img["t530"], ssx = 0, ssy = 0;
				var spp           = img["t277"]?img["t277"][0]:1;
				var jpgresint     = img["t515"];
			
				if(soffTag)
				{
					soff = soffTag[0];
					isTiled = (soffTag.length > 1);
				}
			
				if(!isTiled)
				{
					if(data[off]==255 && data[off+1]==SOI) return { jpegOffset: off };
					if(jpgIchgFmt!=null)
					{
						if(data[off+jifoff]==255 && data[off+jifoff+1]==SOI) joff = off+jifoff;
						else log("JPEGInterchangeFormat does not point to SOI");
			
						if(jpgIchgFmtLen==null) log("JPEGInterchangeFormatLength field is missing");
						else if(jifoff >= soff || (jifoff+jiflen) <= soff) log("JPEGInterchangeFormatLength field value is invalid");
			
						if(joff != null) return { jpegOffset: joff };
					}
				}
			
				if(ycbcrss!=null) {  ssx = ycbcrss[0];  ssy = ycbcrss[1];  }
			
				if(jpgIchgFmt!=null)
					if(jpgIchgFmtLen!=null)
						if(jiflen >= 2 && (jifoff+jiflen) <= soff)
						{
							if(data[off+jifoff+jiflen-2]==255 && data[off+jifoff+jiflen-1]==SOI) tables = new Uint8Array(jiflen-2);
							else tables = new Uint8Array(jiflen);
			
							for(i=0; i<tables.length; i++) tables[i] = data[off+jifoff+i];
							log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
						}
						else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
			
				if(tables == null)
				{
					var ooff = 0, out = [];
					out[ooff++] = 255; out[ooff++] = SOI;
			
					var qtables = img["t519"];
					if(qtables==null) throw new Error("JPEGQTables tag is missing");
					for(i=0; i<qtables.length; i++)
					{
						out[ooff++] = 255; out[ooff++] = DQT; out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
						for(j=0; j<64; j++) out[ooff++] = data[off+qtables[i]+j];
					}
			
					for(k=0; k<2; k++)
					{
						var htables = img[(k == 0) ? "t520" : "t521"];
						if(htables==null) throw new Error(((k == 0) ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
						for(i=0; i<htables.length; i++)
						{
							out[ooff++] = 255; out[ooff++] = DHT;
							//out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
							var nc = 19;
							for(j=0; j<16; j++) nc += data[off+htables[i]+j];
			
							out[ooff++] = (nc >>> 8); out[ooff++] = nc & 255;
							out[ooff++] = (i | (k << 4));
							for(j=0; j<16; j++) out[ooff++] = data[off+htables[i]+j];
							for(j=0; j<nc; j++) out[ooff++] = data[off+htables[i]+16+j];
						}
					}
			
					out[ooff++] = 255; out[ooff++] = SOF0;
					out[ooff++] = 0;  out[ooff++] = 8 + 3*spp;  out[ooff++] = 8;
					out[ooff++] = (img.height >>> 8) & 255;  out[ooff++] = img.height & 255;
					out[ooff++] = (img.width  >>> 8) & 255;  out[ooff++] = img.width  & 255;
					out[ooff++] = spp;
					if(spp==1) {  out[ooff++] = 1;  out[ooff++] = 17;  out[ooff++] = 0;  }
					else for(i=0; i<3; i++)
					{
						out[ooff++] = i + 1;
						out[ooff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
						out[ooff++] = i;
					}
			
					if(jpgresint!=null && jpgresint[0]!=0)
					{
						out[ooff++] = 255;  out[ooff++] = DRI;  out[ooff++] = 0;  out[ooff++] = 4;
						out[ooff++] = (jpgresint[0] >>> 8) & 255;
						out[ooff++] = jpgresint[0] & 255;
					}
			
					tables = new Uint8Array(out);
				}
			
				var sofpos = -1;
				i = 0;
				while(i < (tables.length - 1)) {
					if(tables[i]==255 && tables[i+1]==SOF0) {  sofpos = i; break;  }
					i++;
				}
			
				if(sofpos == -1)
				{
					var tmptab = new Uint8Array(tables.length + 10 + 3*spp);
					tmptab.set(tables);
					var tmpoff = tables.length;
					sofpos = tables.length;
					tables = tmptab;
			
					tables[tmpoff++] = 255; tables[tmpoff++] = SOF0;
					tables[tmpoff++] = 0;  tables[tmpoff++] = 8 + 3*spp;  tables[tmpoff++] = 8;
					tables[tmpoff++] = (img.height >>> 8) & 255;  tables[tmpoff++] = img.height & 255;
					tables[tmpoff++] = (img.width  >>> 8) & 255;  tables[tmpoff++] = img.width  & 255;
					tables[tmpoff++] = spp;
					if(spp==1) {  tables[tmpoff++] = 1;  tables[tmpoff++] = 17;  tables[tmpoff++] = 0;  }
					else for(i=0; i<3; i++)
					{
						tables[tmpoff++] = i + 1;
						tables[tmpoff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
						tables[tmpoff++] = i;
					}
				}
			
				if(data[soff]==255 && data[soff+1]==SOS)
				{
					var soslen = (data[soff+2]<<8) | data[soff+3];
					sosMarker = new Uint8Array(soslen+2);
					sosMarker[0] = data[soff];  sosMarker[1] = data[soff+1]; sosMarker[2] = data[soff+2];  sosMarker[3] = data[soff+3];
					for(i=0; i<(soslen-2); i++) sosMarker[i+4] = data[soff+i+4];
				}
				else
				{
					sosMarker = new Uint8Array(2 + 6 + 2*spp);
					var sosoff = 0;
					sosMarker[sosoff++] = 255;  sosMarker[sosoff++] = SOS;
					sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 6 + 2*spp;  sosMarker[sosoff++] = spp;
					if(spp==1) {  sosMarker[sosoff++] = 1;  sosMarker[sosoff++] = 0;  }
					else for(i=0; i<3; i++)
					{
						sosMarker[sosoff++] = i+1;  sosMarker[sosoff++] = (i << 4) | i;
					}
					sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 63;  sosMarker[sosoff++] = 0;
				}
			
				return { jpegOffset: off, tables: tables, sosMarker: sosMarker, sofPosition: sofpos };
			};
			
			UTIF.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff)
			{
				var i, dlen, tlen, buff, buffoff;
				var jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);
			
				if(jpegData.jpegOffset!=null)
				{
					dlen = off+len-jpegData.jpegOffset;
					buff = new Uint8Array(dlen);
					for(i=0; i<dlen; i++) buff[i] = data[jpegData.jpegOffset+i];
				}
				else
				{
					tlen = jpegData.tables.length;
					buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
					buff.set(jpegData.tables);
					buffoff = tlen;
			
					buff[jpegData.sofPosition+5] = (img.height >>> 8) & 255;  buff[jpegData.sofPosition+6] = img.height & 255;
					buff[jpegData.sofPosition+7] = (img.width  >>> 8) & 255;  buff[jpegData.sofPosition+8] = img.width  & 255;
			
					if(data[off]!=255 || data[off+1]!=SOS)
					{
						buff.set(jpegData.sosMarker, buffoff);
						buffoff += sosMarker.length;
					}
					for(i=0; i<len; i++) buff[buffoff++] = data[off+i];
					buff[buffoff++] = 255;  buff[buffoff++] = EOI;
				}
			
				var parser = new UTIF.JpegDecoder();  parser.parse(buff);
				var decoded = parser.getData({"width":parser.width,"height":parser.height,"forceRGB":true,"isSourcePDF":false});
				for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];
			
				// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
				// RGB format, so updating the tag value
				if(img["t262"] && img["t262"][0] == 6)  img["t262"][0] = 2;
			};
			
			UTIF.decode._decodePackBits = function(data, off, len, tgt, toff)
			{
				var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off+len;
				while(off<lim)
				{
					var n = sa[off];  off++;
					if(n>=0  && n<128)    for(var i=0; i< n+1; i++) {  ta[toff]=sa[off];  toff++;  off++;   }
					if(n>=-127 && n<0) {  for(var i=0; i<-n+1; i++) {  ta[toff]=sa[off];  toff++;           }  off++;  }
				}
				return toff;
			};
			
			UTIF.decode._decodeThunder = function(data, off, len, tgt, toff)
			{
				var d2 = [ 0, 1, 0, -1 ],  d3 = [ 0, 1, 2, 3, 0, -3, -2, -1 ];
				var lim = off+len, qoff = toff*2, px = 0;
				while(off<lim)
				{
					var b = data[off], msk = (b>>>6), n = (b&63);  off++;
					if(msk==3) { px=(n&15);  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
					if(msk==0) for(var i=0; i<n; i++) {  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
					if(msk==2) for(var i=0; i<2; i++) {  var d=(n>>>(3*(1-i)))&7;  if(d!=4) { px+=d3[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
					if(msk==1) for(var i=0; i<3; i++) {  var d=(n>>>(2*(2-i)))&3;  if(d!=2) { px+=d2[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
				}
			};
			
			UTIF.decode._dmap = { "1":0,"011":1,"000011":2,"0000011":3, "010":-1,"000010":-2,"0000010":-3  };
			UTIF.decode._lens = ( function()
			{
				var addKeys = function(lens, arr, i0, inc) {  for(var i=0; i<arr.length; i++) lens[arr[i]] = i0 + i*inc;  };
			
				var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101," // 15
				+ "101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010," // 31
				+ "00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010," // 47
				+ "00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
			
				var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000," // 15
				+ "0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001," // 31
				+ "000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111," // 47
				+ "000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
			
				var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,"
				+ "011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
			
				var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,"
				+ "0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,"
				+ "0000001011011,0000001100100,0000001100101";
			
				var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
			
				termW = termW.split(",");  termB = termB.split(",");  makeW = makeW.split(",");  makeB = makeB.split(",");  makeA = makeA.split(",");
			
				var lensW = {}, lensB = {};
				addKeys(lensW, termW, 0, 1);  addKeys(lensW, makeW, 64,64);  addKeys(lensW, makeA, 1792,64);
				addKeys(lensB, termB, 0, 1);  addKeys(lensB, makeB, 64,64);  addKeys(lensB, makeA, 1792,64);
				return [lensW, lensB];
			} )();
			
			UTIF.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo)
			{
				var U = UTIF.decode, boff=off<<3, len=0, wrd="";	// previous starts with 1
				var line=[], pline=[];  for(var i=0; i<w; i++) pline.push(0);  pline=U._makeDiff(pline);
				var a0=0, a1=0, b1=0, b2=0, clr=0;
				var y=0, mode="", toRead=0;
				var bipl = Math.ceil(w/8)*8;
			
				while((boff>>>3)<off+slen)
				{
					b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
					var bit =0;
					if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
					if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
					boff++;  wrd+=bit;
					if(mode=="H")
					{
						if(U._lens[clr][wrd]!=null)
						{
							var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
							if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
						}
					}
					else
					{
						if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
						if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
						if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
					}
					if(line.length==w && mode=="")
					{
						U._writeBits(line, tgt, toff*8+y*bipl);
						clr=0;  y++;  a0=0;
						pline=U._makeDiff(line);  line=[];
					}
					//if(wrd.length>150) {  log(wrd);  break;  throw "e";  }
				}
			};
			
			UTIF.decode._findDiff = function(line, x, clr) {  for(var i=0; i<line.length; i+=2) if(line[i]>=x && line[i+1]==clr)  return line[i];  };
			
			UTIF.decode._makeDiff = function(line)
			{
				var out = [];  if(line[0]==1) out.push(0,1);
				for(var i=1; i<line.length; i++) if(line[i-1]!=line[i]) out.push(i, line[i]);
				out.push(line.length,0,line.length,1);  return out;
			};
			
			UTIF.decode._decodeG2 = function(data, off, slen, tgt, toff, w, fo)
			{
				var U = UTIF.decode, boff=off<<3, len=0, wrd="";
				var line=[];
				var clr = 0;
				var y=0;
				var bipl = Math.ceil(w/8)*8;
				
				while((boff>>>3)<off+slen) {
					var bit =0;
					if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
					if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
					boff++;  wrd+=bit;
					
					len = U._lens[clr][wrd];
					if(len!=null) {
						U._addNtimes(line,len,clr);  wrd="";
						if(len<64) clr = 1-clr;  
						if(line.length==w) {  U._writeBits(line, tgt, toff*8+y*bipl);  line=[];  y++;  clr=0;  if((boff&7)!=0) boff+=8-(boff&7);  if(len>=64) boff+=8;   }
					}
				}
			};
			
			UTIF.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo, twoDim)
			{
				var U = UTIF.decode, boff=off<<3, len=0, wrd="";
				var line=[], pline=[];  for(var i=0; i<w; i++) line.push(0);
				var a0=0, a1=0, b1=0, b2=0, clr=0;
				var y=-1, mode="", toRead=0, is1D=true;
				var bipl = Math.ceil(w/8)*8;
				while((boff>>>3)<off+slen)
				{
					b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
					var bit =0;
					if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
					if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
					boff++;  wrd+=bit;
			
					if(is1D)
					{
						if(U._lens[clr][wrd]!=null)
						{
							var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
							if(dl<64) {  U._addNtimes(line,len,clr);  clr=1-clr;  len=0;  }
						}
					}
					else
					{
						if(mode=="H")
						{
							if(U._lens[clr][wrd]!=null)
							{
								var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
								if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
							}
						}
						else
						{
							if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
							if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
							if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
						}
					}
					if(wrd.endsWith("000000000001")) // needed for some files
					{
						if(y>=0) U._writeBits(line, tgt, toff*8+y*bipl);
						if(twoDim) {
							if(fo==1) is1D = ((data[boff>>>3]>>>(7-(boff&7)))&1)==1;
							if(fo==2) is1D = ((data[boff>>>3]>>>(  (boff&7)))&1)==1;
							boff++;
						}
						//log("EOL",y, "next 1D:", is1D);
						wrd="";  clr=0;  y++;  a0=0;
						pline=U._makeDiff(line);  line=[];
					}
				}
				if(line.length==w) U._writeBits(line, tgt, toff*8+y*bipl);
			};
			
			UTIF.decode._addNtimes = function(arr, n, val) {  for(var i=0; i<n; i++) arr.push(val);  };
			
			UTIF.decode._writeBits = function(bits, tgt, boff)
			{
				for(var i=0; i<bits.length; i++) tgt[(boff+i)>>>3] |= (bits[i]<<(7-((boff+i)&7)));
			};
			
			UTIF.decode._decodeLZW=UTIF.decode._decodeLZW=function(){var e,U,Z,u,K=0,V=0,g=0,N=0,O=function(){var S=e>>>3,A=U[S]<<16|U[S+1]<<8|U[S+2],j=A>>>24-(e&7)-V&(1<<V)-1;
			e+=V;return j},h=new Uint32Array(4096*4),w=0,m=function(S){if(S==w)return;w=S;g=1<<S;N=g+1;for(var A=0;
			A<N+1;A++){h[4*A]=h[4*A+3]=A;h[4*A+1]=65535;h[4*A+2]=1;}},i=function(S){V=S+1;K=N+1;},D=function(S){var A=S<<2,j=h[A+2],a=u+j-1;
			while(A!=65535){Z[a--]=h[A];A=h[A+1];}u+=j;},L=function(S,A){var j=K<<2,a=S<<2;h[j]=h[(A<<2)+3];h[j+1]=a;
			h[j+2]=h[a+2]+1;h[j+3]=h[a+3];K++;if(K+1==1<<V&&V!=12)V++;},T=function(S,A,j,a,n,q){e=A<<3;U=S;Z=a;u=n;
			var B=A+j<<3,_=0,t=0;m(q);i(q);while(e<B&&(_=O())!=N){if(_==g){i(q);_=O();if(_==N)break;D(_);}else {if(_<K){D(_);
			L(t,_);}else {L(t,t);D(K-1);}}t=_;}return u};return T}();
			
			UTIF.tags = {};
			//UTIF.ttypes = {  256:3,257:3,258:3,   259:3, 262:3,  273:4,  274:3, 277:3,278:4,279:4, 282:5, 283:5, 284:3, 286:5,287:5, 296:3, 305:2, 306:2, 338:3, 513:4, 514:4, 34665:4  };
			// start at tag 250
			UTIF._types = function() {
				var main = new Array(250);  main.fill(0);
				main = main.concat([0,0,0,0,4,3,3,3,3,3,0,0,3,0,0,0,3,0,0,2,2,2,2,4,3,0,0,3,4,4,3,3,5,5,3,2,5,5,0,0,0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,2,2,3,5,5,3,0,3,3,4,4,4,3,4,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
				var rest = {33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7};
				return {
					basic: {
						main: main,
						rest: rest
					},
					gps: {
						main: [1,2,5,2,5,1,5,5,0,9],
						rest: {18:2,29:2}
					}
				}
			}();
			
			UTIF._readIFD = function(bin, data, offset, ifds, depth, prm)
			{
				var cnt = bin.readUshort(data, offset);  offset+=2;
				var ifd = {};
			
				if(prm.debug) log("   ".repeat(depth),ifds.length-1,">>>----------------");
				for(var i=0; i<cnt; i++)
				{
					var tag  = bin.readUshort(data, offset);    offset+=2;
					var type = bin.readUshort(data, offset);    offset+=2;
					var num  = bin.readUint  (data, offset);    offset+=4;
					var voff = bin.readUint  (data, offset);    offset+=4;
					
					var arr = [];
					//ifd["t"+tag+"-"+UTIF.tags[tag]] = arr;
					if(type== 1 || type==7) {  var no=(num<5 ? offset-4 : voff);  if(no+num>data.buffer.byteLength) num=data.buffer.byteLength-no;  arr = new Uint8Array(data.buffer, no, num);  }
					if(type== 2) {  var o0 = (num<5 ? offset-4 : voff), c=data[o0], len=Math.max(0, Math.min(num-1,data.length-o0));
									if(c<128 || len==0) arr.push( bin.readASCII(data, o0, len) );
									else      arr = new Uint8Array(data.buffer, o0, len);  }
					if(type== 3) {  for(var j=0; j<num; j++) arr.push(bin.readUshort(data, (num<3 ? offset-4 : voff)+2*j));  }
					if(type== 4 
					|| type==13) {  for(var j=0; j<num; j++) arr.push(bin.readUint  (data, (num<2 ? offset-4 : voff)+4*j));  }
					if(type== 5 || type==10) {  
						var ri = type==5 ? bin.readUint : bin.readInt;
						for(var j=0; j<num; j++) arr.push([ri(data, voff+j*8), ri(data,voff+j*8+4)]);  }
					if(type== 8) {  for(var j=0; j<num; j++) arr.push(bin.readShort (data, (num<3 ? offset-4 : voff)+2*j));  }
					if(type== 9) {  for(var j=0; j<num; j++) arr.push(bin.readInt   (data, (num<2 ? offset-4 : voff)+4*j));  }
					if(type==11) {  for(var j=0; j<num; j++) arr.push(bin.readFloat (data, voff+j*4));  }
					if(type==12) {  for(var j=0; j<num; j++) arr.push(bin.readDouble(data, voff+j*8));  }
					
					if(num!=0 && arr.length==0) {  log(tag, "unknown TIFF tag type: ", type, "num:",num);  if(i==0)return;  continue;  }
					if(prm.debug) log("   ".repeat(depth), tag, type, UTIF.tags[tag], arr);
					
					ifd["t"+tag] = arr;
					
					if(tag==330 && ifd["t272"] && ifd["t272"][0]=="DSLR-A100") ; 
					else if(tag==330 || tag==34665 || tag==34853 || (tag==50740 && bin.readUshort(data,bin.readUint(arr,0))<300  ) ||tag==61440) {
						var oarr = tag==50740 ? [bin.readUint(arr,0)] : arr;
						var subfd = [];
						for(var j=0; j<oarr.length; j++) UTIF._readIFD(bin, data, oarr[j], subfd, depth+1, prm);
						if(tag==  330) ifd.subIFD = subfd;
						if(tag==34665) ifd.exifIFD = subfd[0];
						if(tag==34853) ifd.gpsiIFD = subfd[0];  //console.log("gps", subfd[0]);  }
						if(tag==50740) ifd.dngPrvt = subfd[0];
						if(tag==61440) ifd.fujiIFD = subfd[0];
					}
					if(tag==37500 && prm.parseMN) {
						var mn = arr;
						//console.log(bin.readASCII(mn,0,mn.length), mn);
						if(bin.readASCII(mn,0,5)=="Nikon")  ifd.makerNote = UTIF["decode"](mn.slice(10).buffer)[0];
						else if(bin.readASCII(mn,0,5)=="OLYMP" || bin.readASCII(mn,0,9)=="OM SYSTEM") { // ???
							var inds = [8208,8224,8240,8256,8272];
							var subsub = [];  UTIF._readIFD(bin, mn, mn[1]==77 ? 16 : (mn[5]==85 ? 12 : 8), subsub, depth+1, prm);
							var obj = ifd.makerNote = subsub.pop();
							for(var j=0; j<inds.length; j++) {
								var k="t"+inds[j];  if(obj[k]==null) continue;
								UTIF._readIFD(bin, mn, obj[k][0], subsub, depth+1, prm);
								obj[k] = subsub.pop();
							}
							if(obj["t12288"]) {
								UTIF._readIFD(bin, obj["t12288"], 0, subsub, depth+1, prm);
								obj["t12288"]=subsub.pop();
							}
						}
						else if(bin.readUshort(data,voff)<300 && bin.readUshort(data,voff+4)<=12){
							var subsub=[];  UTIF._readIFD(bin, data, voff, subsub, depth+1, prm);
							ifd.makerNote = subsub[0];
						}
					}
				}
				ifds.push(ifd);
				if(prm.debug) log("   ".repeat(depth),"<<<---------------");
				return offset;
			};
			
			UTIF._writeIFD = function(bin, types, data, offset, ifd)
			{
				var keys = Object.keys(ifd), knum=keys.length;  if(ifd["exifIFD"]) knum--;  if(ifd["gpsiIFD"]) knum--;
				bin.writeUshort(data, offset, knum);  offset+=2;
			
				var eoff = offset + knum*12 + 4;
			
				for(var ki=0; ki<keys.length; ki++)
				{
					var key = keys[ki];  if(key=="t34665" || key=="t34853") continue;  
					if(key=="exifIFD") key="t34665";  if(key=="gpsiIFD") key="t34853";
					var tag = parseInt(key.slice(1)), type = types.main[tag];  if(type==null) type=types.rest[tag];		
					if(type==null || type==0) throw new Error("unknown type of tag: "+tag);
					//console.log(offset+":", tag, type, eoff);
					var val = ifd[key];  
					if(tag==34665) {
						var outp = UTIF._writeIFD(bin, types, data, eoff, ifd["exifIFD"]);
						val = [eoff];  eoff = outp[1];
					}
					if(tag==34853) {
						var outp = UTIF._writeIFD(bin, UTIF._types.gps, data, eoff, ifd["gpsiIFD"]);
						val = [eoff];  eoff = outp[1];
					}
					if(type==2) val=val[0]+"\u0000";  var num = val.length;
					bin.writeUshort(data, offset, tag );  offset+=2;
					bin.writeUshort(data, offset, type);  offset+=2;
					bin.writeUint  (data, offset, num );  offset+=4;
			
					var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;  //if(dlen<1) throw "e";
					var toff = offset;
					if(dlen>4) {  bin.writeUint(data, offset, eoff);  toff=eoff;  }
			
					if     (type== 1 || type==7) {  for(var i=0; i<num; i++) data[toff+i] = val[i];  }
					else if(type== 2) {  bin.writeASCII(data, toff, val);   }
					else if(type== 3) {  for(var i=0; i<num; i++) bin.writeUshort(data, toff+2*i, val[i]);    }
					else if(type== 4) {  for(var i=0; i<num; i++) bin.writeUint  (data, toff+4*i, val[i]);    }
					else if(type== 5 || type==10) {  
						var wr = type==5?bin.writeUint:bin.writeInt;
						for(var i=0; i<num; i++) {  
						var v=val[i],nu=v[0],de=v[1];  if(nu==null) throw "e";  wr(data, toff+8*i, nu);  wr(data, toff+8*i+4, de);  }   }
					else if(type== 9) {  for(var i=0; i<num; i++) bin.writeInt   (data, toff+4*i, val[i]);    }
					else if(type==12) {  for(var i=0; i<num; i++) bin.writeDouble(data, toff+8*i, val[i]);    }
					else throw type;
			
					if(dlen>4) {  dlen += (dlen&1);  eoff += dlen;  }
					offset += 4;
				}
				return [offset, eoff];
			};
			
			UTIF.toRGBA8 = function(out, scl)
			{
				function gamma(x) {  return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;  }
				
				
				var w = out.width, h = out.height, area = w*h, data = out.data;
				var img = new Uint8Array(area*4);
				//console.log(out);
				// 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK
				var intp = (out["t262"] ? out["t262"][0]: 2), bps = (out["t258"]?Math.min(32,out["t258"][0]):1);
				if(out["t262"]==null && bps==1) intp=0;
				
				var smpls = out["t277"]?out["t277"][0] : (out["t258"]?out["t258"].length : [1,1,3,1,1,4,3][intp]);
				var sfmt  = out["t339"]?out["t339"][0] : null;  if(intp==1 && bps==32 && sfmt!=3) throw "e";  // sample format
				var bpl = Math.ceil(smpls*bps*w/8);
				
				//log("interpretation: ", intp, "smpls", smpls, "bps", bps, "sample format",sfmt, out);
				
				if(intp==0)
				{
					scl = 1/256; // "Photopeatest.tif"
					for(var y=0; y<h; y++) {
						var off = y*bpl, io = y*w;
						if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))& 1;  img[qi]=img[qi+1]=img[qi+2]=( 1-px)*255;  img[qi+3]=255;    }
						if(bps== 4) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>1)])>>(4-4*(i&1)))&15;  img[qi]=img[qi+1]=img[qi+2]=(15-px)* 17;  img[qi+3]=255;    }
						if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i];  img[qi]=img[qi+1]=img[qi+2]=255-px;  img[qi+3]=255;    }
						if(bps==16) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=off+(2*i), px=(data[o+1]<<8)|data[o];  img[qi]=img[qi+1]=img[qi+2]= Math.min(255,255-(~~(px*scl)));  img[qi+3]=255;    } // ladoga.tif
					}
				}
				else if(intp==1)
				{
					if(scl==null) scl=1/256;
					var f32 = ((data.length&3)==0) ? new Float32Array(data.buffer) : null;
					
					for(var y=0; y<h; y++) {
						var off = y*bpl, io = y*w;
						if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))&1;   img[qi]=img[qi+1]=img[qi+2]=(px)*255;  img[qi+3]=255;    }
						if(bps== 2) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>2)])>>(6-2*(i&3)))&3;   img[qi]=img[qi+1]=img[qi+2]=(px)* 85;  img[qi+3]=255;    }
						if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i*smpls];  img[qi]=img[qi+1]=img[qi+2]=    px;  img[qi+3]=255;    }
						if(bps==16) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=off+(2*i), px=(data[o+1]<<8)|data[o];  img[qi]=img[qi+1]=img[qi+2]= Math.min(255,~~(px*scl));  img[qi+3]=255;    } // ladoga.tif
						if(bps==32) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=(off>>>2)+i, px=f32[o];  img[qi]=img[qi+1]=img[qi+2]= ~~(0.5+255*px);  img[qi+3]=255;    }
					}
				}
				else if(intp==2)
				{
					if(bps== 8) 
					{
						if(smpls==1) for(var i=0; i<area; i++) {  img[4*i]=img[4*i+1]=img[4*i+2]=data[i];  img[4*i+3]=255;  }
						if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3    ;  img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  img[qi+3]=255;    }
						if(smpls>=4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*smpls;  img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  img[qi+3]=data[ti+3];    }
					}
					else if(bps==16){  // 3x 16-bit channel
						if(smpls==4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*8+1;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=data[ti+6];    }
						if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6+1;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=255;           }
					}
					else if(bps==32){
						var ndt = new Float32Array(data.buffer);  // t339 is [3,3,3]
						// check the endianity
						var min = 0;  for(var i=0; i<ndt.length; i++) min = Math.min(min,ndt[i]);
						if(min<0) for(var i=0; i<data.length; i+=4) {  var t=data[i];  data[i]=data[i+3];  data[i+3]=t;  t=data[i+1];  data[i+1]=data[i+2];  data[i+2]=t;  }
						// gamma correction
						var pmap = [];  for(var i=0; i<65536; i++) pmap.push(gamma(i/65535));
						for(var i=0; i<ndt.length; i++) {  var cv = Math.max(0, Math.min(1, ndt[i]));  ndt[i] = pmap[~~(0.5+cv*65535)];  }
						
						if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  
							img[qi]=~~(0.5+ndt[ti]*255);  img[qi+1]=~~(0.5+ndt[ti+1]*255);  img[qi+2]=~~(0.5+ndt[ti+2]*255);  img[qi+3]=255;           }
						else if(smpls==4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*4;  
							img[qi]=~~(0.5+ndt[ti]*255);  img[qi+1]=~~(0.5+ndt[ti+1]*255);  img[qi+2]=~~(0.5+ndt[ti+2]*255);  img[qi+3]=~~(0.5+ndt[ti+3]*255);           }
						else throw smpls;
					}
					else throw bps;
				}
				else if(intp==3)
				{
					var map = out["t320"];
					var cn = 1<<bps;
					
					var nexta = bps==8 && smpls>1 && out["t338"] && out["t338"][0]!=0;
					
					for(var y=0; y<h; y++) 
						for(var x=0; x<w; x++) {  
							var i = y*w+x;
							var qi=i<<2, mi=0;
							var dof = y*bpl;
							if(bps==1) mi=(data[dof+(x>>>3)]>>>(7-  (x&7)))& 1;
							else if(bps==2) mi=(data[dof+(x>>>2)]>>>(6-2*(x&3)))& 3;
							else if(bps==4) mi=(data[dof+(x>>>1)]>>>(4-4*(x&1)))&15;
							else if(bps==8) mi= data[dof+x*smpls]; 
							else throw bps;
							img[qi]=(map[mi]>>8);  img[qi+1]=(map[cn+mi]>>8);  img[qi+2]=(map[cn+cn+mi]>>8);  img[qi+3]=nexta ? data[dof+x*smpls+1] : 255;   
						}
				}
				else if(intp==5) 
				{
					var gotAlpha = smpls>4 ? 1 : 0;
					for(var i=0; i<area; i++) {
						var qi=i<<2, si=i*smpls;  
						
						if(window.UDOC) {
							var C=data[si], M=data[si+1], Y=data[si+2], K=data[si+3];
							var c = UDOC.C.cmykToRgb([C*(1/255), M*(1/255), Y*(1/255), K*(1/255)]);
							img[qi] = ~~(0.5+255*c[0]);  img[qi+1] = ~~(0.5+255*c[1]);  img[qi+2] = ~~(0.5+255*c[2]);
						}
						else {
							var C=255-data[si], M=255-data[si+1], Y=255-data[si+2], K=(255-data[si+3])*(1/255);
							img[qi]=~~(C*K+0.5);  img[qi+1]=~~(M*K+0.5);  img[qi+2]=~~(Y*K+0.5);
						}
						
						img[qi+3]=255*(1-gotAlpha)+data[si+4]*gotAlpha;
					}
				}
				else if(intp==6 && out["t278"]) {  // only for DSC_1538.TIF
					var rps = out["t278"][0];
					for(var y=0; y<h; y+=rps) {
						var i=(y*w), len = rps*w;
						
						for(var j=0; j<len; j++) {
							var qi = 4*(i+j), si = 3*i+4*(j>>>1);
							var Y = data[si+(j&1)], Cb=data[si+2]-128, Cr=data[si+3]-128;
							
							var r = Y + ( (Cr >> 2) + (Cr >> 3) + (Cr >> 5) ) ;
							var g = Y - ( (Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ( (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5)) ;
							var b = Y + ( Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6)) ;
							
							img[qi  ]=Math.max(0,Math.min(255,r));
							img[qi+1]=Math.max(0,Math.min(255,g));
							img[qi+2]=Math.max(0,Math.min(255,b));
							img[qi+3]=255;
						}
					}
				}
				else if(intp==32845) {
					
					for(var y=0; y<h; y++)
						for(var x=0; x<w; x++) {
							var si = (y*w+x)*6, qi=(y*w+x)*4;
							var L =  (data[si+1]<<8) | data[si];
							
							var L = Math.pow(2, (L + 0.5) / 256 - 64);
							var u = (data[si+3] + 0.5) / 410;
							var v = (data[si+5] + 0.5) / 410;
							
							// Luv to xyY
							var sX = (9 * u) / (6 * u - 16 * v + 12);
							var sY = (4 * v) / (6 * u - 16 * v + 12);
							var bY = L;  
							
							// xyY to XYZ
							var X = (sX*bY)/sY, Y = bY, Z = (1-sX-sY)*bY/sY;  
							
							
							var r =  2.690*X -1.276*Y -0.414*Z;
							var g = -1.022*X +1.978*Y +0.044*Z;
							var b =  0.061*X -0.224*Y +1.163*Z;
							
							img[qi  ] = gamma(Math.min(r,1))*255;
							img[qi+1] = gamma(Math.min(g,1))*255;
							img[qi+2] = gamma(Math.min(b,1))*255;
							img[qi+3] = 255;
						}
				}
				else log("Unknown Photometric interpretation: "+intp);
				return img;
			};
			
			UTIF.replaceIMG = function(imgs)
			{
				if(imgs==null) imgs = document.getElementsByTagName("img");
				var sufs = ["tif","tiff","dng","cr2","nef"];
				for (var i=0; i<imgs.length; i++)
				{
					var img=imgs[i], src=img.getAttribute("src");  if(src==null) continue;
					var suff=src.split(".").pop().toLowerCase();
					if(sufs.indexOf(suff)==-1) continue;
					var xhr = new XMLHttpRequest();  UTIF._xhrs.push(xhr);  UTIF._imgs.push(img);
					xhr.open("GET", src);  xhr.responseType = "arraybuffer";
					xhr.onload = UTIF._imgLoaded;   xhr.send();
				}
			};
			
			UTIF._xhrs = [];  UTIF._imgs = [];
			UTIF._imgLoaded = function(e) {
				var ind = UTIF._xhrs.indexOf(e.target), img = UTIF._imgs[ind];
				UTIF._xhrs.splice(ind,1);  UTIF._imgs.splice(ind,1);
				
				img.setAttribute("src",UTIF.bufferToURI(e.target.response));
			};
			
			UTIF.bufferToURI = function(buff) {
				var ifds = UTIF.decode(buff);  //console.log(ifds);
				var vsns = ifds, ma=0, page=vsns[0];  if(ifds[0].subIFD) vsns = vsns.concat(ifds[0].subIFD);
				for(var i=0; i<vsns.length; i++) {
					var img = vsns[i];
					if(img["t258"]==null || img["t258"].length<3) continue;
					var ar = img["t256"]*img["t257"];
					if(ar>ma) {  ma=ar;  page=img;  }
				}
				UTIF.decodeImage(buff, page, ifds);
				var rgba = UTIF.toRGBA8(page), w=page.width, h=page.height;
				
				var cnv = document.createElement("canvas");  cnv.width=w;  cnv.height=h;
				var ctx = cnv.getContext("2d");
				var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer),w,h);
				ctx.putImageData(imgd,0,0);
				return cnv.toDataURL();
			};
			
			
			UTIF._binBE =
			{
				nextZero   : function(data, o) {  while(data[o]!=0) o++;  return o;  },
				readUshort : function(buff, p) {  return (buff[p]<< 8) |  buff[p+1];  },
				readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+1];  a[1]=buff[p+0];							        return UTIF._binBE. i16[0];  },
				readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE. i32[0];  },
				readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE.ui32[0];  },
				readASCII  : function(buff, p, l) {  var s = "";   for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);   return s; },
				readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+3-i];  return UTIF._binBE.fl32[0];  },
				readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+7-i];  return UTIF._binBE.fl64[0];  },
			
				writeUshort: function(buff, p, n) {  buff[p] = (n>> 8)&255;  buff[p+1] =  n&255;  },
				writeInt   : function(buff, p, n) {  var a=UTIF._binBE.ui8;  UTIF._binBE.i32[0]=n;  buff[p+3]=a[0];  buff[p+2]=a[1];  buff[p+1]=a[2];  buff[p+0]=a[3];  },
				writeUint  : function(buff, p, n) {  buff[p] = (n>>24)&255;  buff[p+1] = (n>>16)&255;  buff[p+2] = (n>>8)&255;  buff[p+3] = (n>>0)&255;  },
				writeASCII : function(buff, p, s) {  for(var i = 0; i < s.length; i++)  buff[p+i] = s.charCodeAt(i);  },
				writeDouble: function(buff, p, n)
				{
					UTIF._binBE.fl64[0] = n;
					for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];
				}
			};
			UTIF._binBE.ui8  = new Uint8Array  (8);
			UTIF._binBE.i16  = new Int16Array  (UTIF._binBE.ui8.buffer);
			UTIF._binBE.i32  = new Int32Array  (UTIF._binBE.ui8.buffer);
			UTIF._binBE.ui32 = new Uint32Array (UTIF._binBE.ui8.buffer);
			UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer);
			UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer);
			
			UTIF._binLE =
			{
				nextZero   : UTIF._binBE.nextZero,
				readUshort : function(buff, p) {  return (buff[p+1]<< 8) |  buff[p];  },
				readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];							        return UTIF._binBE. i16[0];  },
				readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE. i32[0];  },
				readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE.ui32[0];  },
				readASCII  : UTIF._binBE.readASCII,
				readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl32[0];  },
				readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl64[0];  },
				
				writeUshort: function(buff, p, n) {  buff[p] = (n)&255;  buff[p+1] =  (n>>8)&255;  },
				writeInt   : function(buff, p, n) {  var a=UTIF._binBE.ui8;  UTIF._binBE.i32[0]=n;  buff[p+0]=a[0];  buff[p+1]=a[1];  buff[p+2]=a[2];  buff[p+3]=a[3];  },
				writeUint  : function(buff, p, n) {  buff[p] = (n>>>0)&255;  buff[p+1] = (n>>>8)&255;  buff[p+2] = (n>>>16)&255;  buff[p+3] = (n>>>24)&255;  },
				writeASCII : UTIF._binBE.writeASCII
			};
			UTIF._copyTile = function(tb, tw, th, b, w, h, xoff, yoff)
			{
				//log("copyTile", tw, th,  w, h, xoff, yoff);
				var xlim = Math.min(tw, w-xoff);
				var ylim = Math.min(th, h-yoff);
				for(var y=0; y<ylim; y++)
				{
					var tof = (yoff+y)*w+xoff;
					var sof = y*tw;
					for(var x=0; x<xlim; x++) b[tof+x] = tb[sof+x];
				}
			};
			
			UTIF.LosslessJpegDecode =function(){var b,O;function l(){return b[O++]}function m(){return b[O++]<<8|b[O++]}function a0(h){var V=l(),I=[0,0,0,255],f=[],G=8;
			for(var w=0;w<16;w++)f[w]=l();for(var w=0;w<16;w++){for(var x=0;x<f[w];x++){var T=z(I,0,w+1,1);I[T+3]=l();}}var E=new Uint8Array(1<<G);
			h[V]=[new Uint8Array(I),E];for(var w=0;w<1<<G;w++){var s=G,_=w,Y=0,F=0;while(I[Y+3]==255&&s!=0){F=_>>--s&1;
			Y=I[Y+F];}E[w]=Y;}}function z(h,V,I,f){if(h[V+3]!=255)return 0;if(I==0)return V;for(var w=0;w<2;w++){if(h[V+w]==0){h[V+w]=h.length;
			h.push(0,0,f,255);}var x=z(h,h[V+w],I-1,f+1);if(x!=0)return x}return 0}function i(h){var V=h.b,I=h.f;
			while(V<25&&h.a<h.d){var f=h.data[h.a++];if(f==255&&!h.c)h.a++;I=I<<8|f;V+=8;}if(V<0)throw "e";h.b=V;h.f=I;}function H(h,V){if(V.b<h)i(V);
			return V.f>>(V.b-=h)&65535>>16-h}function g(h,V){var I=h[0],f=0,w=255,x=0;if(V.b<16)i(V);var T=V.f>>V.b-8&255;
			f=h[1][T];w=I[f+3];V.b-=I[f+2];while(w==255){x=V.f>>--V.b&1;f=I[f+x];w=I[f+3];}return w}function P(h,V){if(h<32768>>16-V)h+=-(1<<V)+1;
			return h}function a2(h,V){var I=g(h,V);if(I==0)return 0;if(I==16)return  -32768;var f=H(I,V);return P(f,I)}function X(h,V,I,f,w,x){var T=0;
			for(var G=0;G<x;G++){var s=G*V;for(var _=0;_<V;_+=w){T++;for(var Y=0;Y<w;Y++)h[s+_+Y]=a2(f[Y],I);}if(I.e!=0&&T%I.e==0&&G!=0){var F=I.a,t=I.data;
			while(t[F]!=255||!(208<=t[F+1]&&t[F+1]<=215))F--;I.a=F+2;I.f=0;I.b=0;}}}function o(h,V){return P(H(h,V),h)}function a1(h,V,I,f,w){var x=b.length-O;
			for(var T=0;T<x;T+=4){var G=b[O+T];b[O+T]=b[O+T+3];b[O+T+3]=G;var G=b[O+T+1];b[O+T+1]=b[O+T+2];b[O+T+2]=G;}for(var E=0;
			E<w;E++){var s=32768,_=32768;for(var Y=0;Y<V;Y+=2){var F=g(f,I),t=g(f,I);if(F!=0)s+=o(F,I);if(t!=0)_+=o(t,I);
			h[E*V+Y]=s&65535;h[E*V+Y+1]=_&65535;}}}function C(h){b=h;O=0;if(m()!=65496)throw "e";var V=[],I=0,f=0,w=0,x=[],T=[],G=[],E=0,s=0,_=0;
			while(true){var Y=m();if(Y==65535){O--;continue}var F=m();if(Y==65475){f=l();s=m();_=m();E=l();for(var t=0;
			t<E;t++){var a=l(),J=l(),r=l();if(r!=0)throw "e";V[a]=[t,J>>4,J&15];}}else if(Y==65476){var a3=O+F-2;while(O<a3)a0(T);}else if(Y==65498){O++;
			for(var t=0;t<E;t++){var a5=l(),v=V[a5];G[v[0]]=T[l()>>>4];x[v[0]]=v.slice(1);}I=l();O+=2;break}else if(Y==65501){w=m();}else {O+=F-2;}}var a4=f>8?Uint16Array:Uint8Array,$=new a4(s*_*E),M={b:0,f:0,c:I==8,a:O,data:b,d:b.length,e:w};
			if(M.c)a1($,_*E,M,G[0],s);else {var c=[],p=0,D=0;for(var t=0;t<E;t++){var N=x[t],S=N[0],K=N[1];if(S>p)p=S;
			if(K>D)D=K;c.push(S*K);}if(p!=1||D!=1){if(E!=3||c[1]!=1||c[2]!=1)throw "e";if(p!=2||D!=1&&D!=2)throw "e";
			var u=[],Z=0;for(var t=0;t<E;t++){for(var R=0;R<c[t];R++)u.push(G[t]);Z+=c[t];}var B=_/p,e=s/D,d=B*e;
			X($,B*Z,M,u,Z,e);j($,I,B,e,Z-2,Z,Z,f);var A=new Uint16Array(d*c[0]);if(p==2&&D==2){for(var t=0;t<d;t++){A[4*t]=$[6*t];
			A[4*t+1]=$[6*t+1];A[4*t+2]=$[6*t+2];A[4*t+3]=$[6*t+3];}j(A,I,B*4,e,0,1,1,f);for(var t=0;t<d;t++){$[6*t]=A[4*t];
			$[6*t+1]=A[4*t+1];$[6*t+2]=A[4*t+2];$[6*t+3]=A[4*t+3];}}if(p==2&&D==1){for(var t=0;t<d;t++){A[2*t]=$[4*t];
			A[2*t+1]=$[4*t+1];}j(A,I,B*2,e,0,1,1,f);for(var t=0;t<d;t++){$[4*t]=A[2*t];$[4*t+1]=A[2*t+1];}}var n=$.slice(0);
			for(var K=0;K<s;K++){if(D==2)for(var S=0;S<_;S++){var q=(K*_+S)*E,k=((K>>>1)*B+(S>>>1))*Z,y=(K&1)*2+(S&1);
			$[q]=n[k+y];$[q+1]=n[k+4];$[q+2]=n[k+5];}else for(var S=0;S<_;S++){var q=(K*_+S)*E,k=(K*B+(S>>>1))*Z,y=S&1;
			$[q]=n[k+y];$[q+1]=n[k+2];$[q+2]=n[k+3];}}}else {X($,_*E,M,G,E,s);if(w==0)j($,I,_,s,0,E,E,f);else {var U=Math.floor(w/_);
			for(var K=0;K<s;K+=U){var L=$.slice(K*_*E,(K+U)*_*E);j(L,I,_,U,0,E,E,f);$.set(L,K*_*E);}}}}return $}function j(h,V,I,f,w,x,G,E){var s=I*G;
			for(var _=w;_<x;_++)h[_]+=1<<E-1;for(var Y=G;Y<s;Y+=G)for(var _=w;_<x;_++)h[Y+_]+=h[Y+_-G];for(var F=1;
			F<f;F++){var t=F*s;for(var _=w;_<x;_++)h[t+_]+=h[t+_-s];for(var Y=G;Y<s;Y+=G){for(var _=w;_<x;_++){var a=t+Y+_,J=a-s,r=h[a-G],Q=0;
			if(V==0)Q=0;else if(V==1)Q=r;else if(V==2)Q=h[J];else if(V==3)Q=h[J-G];else if(V==4)Q=r+(h[J]-h[J-G]);
			else if(V==5)Q=r+(h[J]-h[J-G]>>>1);else if(V==6)Q=h[J]+(r-h[J-G]>>>1);else if(V==7)Q=r+h[J]>>>1;else throw V;
			h[a]+=Q;}}}}return C}();
			
			
			(function(){var G=0,F=1,i=2,b=3,J=4,N=5,E=6,s=7,c=8,T=9,a3=10,f=11,q=12,M=13,m=14,x=15,L=16,$=17,p=18;
			function a5(t){var Z=UTIF._binBE.readUshort,u={b:Z(t,0),i:t[2],C:t[3],u:t[4],q:Z(t,5),k:Z(t,7),e:Z(t,9),l:Z(t,11),s:t[13],d:Z(t,14)};
			if(u.b!=18771||u.i>1||u.q<6||u.q%6||u.e<768||u.e%24||u.l!=768||u.k<u.l||u.k%u.l||u.k-u.e>=u.l||u.s>16||u.s!=u.k/u.l||u.s!=Math.ceil(u.e/u.l)||u.d!=u.q/6||u.u!=12&&u.u!=14&&u.u!=16||u.C!=16&&u.C!=0){throw "Invalid data"}if(u.i==0){throw "Not implemented. We need this file!"}u.h=u.C==16;
			u.m=(u.h?u.l*2/3:u.l>>>1)|0;u.A=u.m+2;u.f=64;u.g=(1<<u.u)-1;u.n=4*u.u;return u}function a7(t,Z){var u=new Array(Z.s),e=4*Z.s,Q=16+e;
			if(e&12)Q+=16-(e&12);for(var V=0,O=16;V<Z.s;O+=4){var o=UTIF._binBE.readUint(t,O);u[V]=t.slice(Q,Q+o);u[V].j=0;u[V].a=0;
			Q+=o;V++;}if(Q!=t.length)throw "Invalid data";return u}function a6(t,Z){for(var u=-Z[4],e=0;u<=Z[4];e++,u++){t[e]=u<=-276?-4:u<=-67?-3:u<=-18?-2:u<-0?-1:u<=Z[0]?0:u<Z[1]?1:u<Z[2]?2:u<Z[3]?3:4;}}function a1(t,Z,u){var e=[Z,3*Z+18,5*Z+67,7*Z+276,u];
			t.o=Z;t.w=(e[4]+2*Z)/(2*Z+1)+1|0;t.v=Math.ceil(Math.log2(t.w));t.t=9;a6(t.c,e);}function a2(t){var Z={c:new Int8Array(2<<t.u)};
			a1(Z,0,t.g);return Z}function D(t){var Z=[[],[],[]],u=Math.max(2,t.w+32>>>6);for(var e=0;e<3;e++){for(var Q=0;
			Q<41;Q++){Z[e][Q]=[u,1];}}return Z}function a4(t){for(var Z=-1,u=0;!u;Z++){u=t[t.j]>>>7-t.a&1;t.a++;t.a&=7;
			if(!t.a)t.j++;}return Z}function K(t,Z){var u=0,e=8-t.a;t.j;t.a;if(Z){if(Z>=e){do{u<<=e;Z-=e;u|=t[t.j]&(1<<e)-1;
			t.j++;e=8;}while(Z>=8)}if(Z){u<<=Z;e-=Z;u|=t[t.j]>>>e&(1<<Z)-1;}t.a=8-e;}return u}function a0(t,Z){var u=0;
			if(Z<t){while(u<=14&&Z<<++u<t);}return u}function r(t,Z,u,e,Q,V,O,o){if(o==null)o=0;var X=V+1,k=X%2,a=0,l,R,w=e[Q],S=e[Q-1],H=e[Q-2][X],g=S[X-1],Y=S[X],P=S[X+1],A=w[X-1],v=w[X+1],y=Math.abs,d,C,n,h;
			if(k){d=y(P-Y);C=y(H-Y);n=y(g-Y);}if(k){h=d>n&&C<d?H+g:d<n&&C<n?H+P:P+g;h=h+2*Y>>>2;if(o){w[X]=h;return}l=Z.t*Z.c[t.g+Y-H]+Z.c[t.g+g-Y];}else {h=Y>g&&Y>P||Y<g&&Y<P?v+A+2*Y>>>2:A+v>>>1;
			l=Z.t*Z.c[t.g+Y-g]+Z.c[t.g+g-A];}R=y(l);var W=a4(u);if(W<t.n-Z.v-1){var z=a0(O[R][0],O[R][1]);a=K(u,z)+(W<<z);}else {a=K(u,Z.v)+1;}a=a&1?-1-(a>>>1):a>>>1;
			O[R][0]+=y(a);if(O[R][1]==t.f){O[R][0]>>>=1;O[R][1]>>>=1;}O[R][1]++;h=l<0?h-a:h+a;if(t.i){if(h<0)h+=Z.w;
			else if(h>t.g)h-=Z.w;}w[X]=h>=0?Math.min(h,t.g):0;}function U(t,Z,u){var e=t[0].length;for(var Q=Z;Q<=u;
			Q++){t[Q][0]=t[Q-1][1];t[Q][e-1]=t[Q-1][e-2];}}function B(t){U(t,s,q);U(t,i,J);U(t,x,$);}function _(t,Z,u,e,Q,V,O,o,X,k,j,I,a){var l=0,R=1,w=Q<M&&Q>J;
			while(R<t.m){if(l<t.m){r(t,Z,u,e,Q,l,O[X],t.h&&(w&&k||!w&&(j||(l&I)==a)));r(t,Z,u,e,V,l,O[X],t.h&&(!w&&k||w&&(j||(l&I)==a)));
			l+=2;}if(l>8){r(t,Z,u,e,Q,R,o[X]);r(t,Z,u,e,V,R,o[X]);R+=2;}}B(e);}function a8(t,Z,u,e,Q,V){_(t,Z,u,e,i,s,Q,V,0,0,1,0,8);
			_(t,Z,u,e,c,x,Q,V,1,0,1,0,8);_(t,Z,u,e,b,T,Q,V,2,1,0,3,0);_(t,Z,u,e,a3,L,Q,V,0,0,0,3,2);_(t,Z,u,e,J,f,Q,V,1,0,0,3,2);
			_(t,Z,u,e,q,$,Q,V,2,1,0,3,0);}function a9(t,Z,u,e,Q,V){var O=V.length,o=t.l;if(Q+1==t.s)o=t.e-Q*t.l;var X=6*t.e*e+Q*t.l;
			for(var k=0;k<6;k++){for(var j=0;j<o;j++){var I=V[k%O][j%O],a;if(I==0){a=i+(k>>>1);}else if(I==2){a=x+(k>>>1);}else {a=s+k;}var l=t.h?(j*2/3&2147483646|j%3&1)+(j%3>>>1):j>>>1;
			Z[X+j]=u[a][l+1];}X+=t.e;}}UTIF._decompressRAF=function(t,Z){var u=a5(t),e=a7(t,u),Q=a2(u),V=new Int16Array(u.e*u.q);
			if(Z==null){Z=u.h?[[1,1,0,1,1,2],[1,1,2,1,1,0],[2,0,1,0,2,1],[1,1,2,1,1,0],[1,1,0,1,1,2],[0,2,1,2,0,1]]:[[0,1],[3,2]];}var O=[[G,b],[F,J],[N,f],[E,q],[M,L],[m,$]],o=[];
			for(var X=0;X<p;X++){o[X]=new Uint16Array(u.A);}for(var k=0;k<u.s;k++){var j=D(Q),I=D(Q);for(var X=0;
			X<p;X++){for(var a=0;a<u.A;a++){o[X][a]=0;}}for(var l=0;l<u.d;l++){a8(u,Q,e[k],o,j,I);for(var X=0;X<6;
			X++){for(var a=0;a<u.A;a++){o[O[X][0]][a]=o[O[X][1]][a];}}a9(u,V,o,l,k,Z);for(var X=i;X<p;X++){if([N,E,M,m].indexOf(X)==-1){for(var a=0;
			a<u.A;a++){o[X][a]=0;}}}B(o);}}return V};}());
			
			
			
			})(UTIF, pako);
			})(); 
	} (UTIF));
	return UTIF.exports;
}

var UTIFExports = requireUTIF();
const utif = /*@__PURE__*/getDefaultExportFromCjs(UTIFExports);

function getDimensionValue(dimension) {
    if (typeof dimension === "number") {
        return dimension;
    }
    if (dimension instanceof Uint8Array) {
        return dimension[0];
    }
    if (typeof dimension[0] === "string") {
        return parseInt(dimension[0]);
    }
    return dimension[0];
}
function tiff() {
    return {
        mime: "image/tiff",
        encode: (bitmap) => {
            const tiff = utif.encodeImage(bitmap.data, bitmap.width, bitmap.height);
            return Buffer.from(tiff);
        },
        decode: (data) => {
            const ifds = utif.decode(data);
            const page = ifds[0];
            if (!page) {
                throw new Error("No page found in TIFF");
            }
            if (!page.t256) {
                throw new Error("No image width found in TIFF");
            }
            if (!page.t257) {
                throw new Error("No image height found in TIFF");
            }
            ifds.forEach((ifd) => {
                utif.decodeImage(data, ifd);
            });
            const rgba = utif.toRGBA8(page);
            return {
                data: Buffer.from(rgba),
                width: getDimensionValue(page.t256),
                height: getDimensionValue(page.t257),
            };
        },
    };
}

var util$1;
(function (util) {
    util.assertEqual = (_) => { };
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util$1 || (util$1 = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$1.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util$1.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                const firstEl = sub.path[0];
                fieldErrors[firstEl] = fieldErrors[firstEl] || [];
                fieldErrors[firstEl].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$1.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util$1.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util$1.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util$1.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util$1.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "bigint")
                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util$1.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap, // contextual error map is first priority
            ctx.schemaErrorMap, // then schema-bound map if available
            overrideMap, // then global override map
            overrideMap === errorMap ? undefined : errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    // biome-ignore lint:
    errorUtil.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message ?? ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: message ?? required_error ?? ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap,
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return isValid(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if (err?.message?.toLowerCase()?.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true,
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        if (!header)
            return false;
        // Convert base64url to base64
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if ("typ" in decoded && decoded?.typ !== "JWT")
            return false;
        if (!decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$1.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...errorUtil.errToObj(options?.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...errorUtil.errToObj(options?.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options?.position,
            ...errorUtil.errToObj(options?.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util$1.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$1.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || (ch.kind === "multipleOf" && util$1.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$1.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util$1.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util$1.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: errorUtil.errToObj(message).message ?? defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        for (const key of util$1.objectKeys(mask)) {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        for (const key of util$1.objectKeys(this.shape)) {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        for (const key of util$1.objectKeys(this.shape)) {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        for (const key of util$1.objectKeys(this.shape)) {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util$1.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util$1.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util$1.objectKeys(b);
        const sharedKeys = util$1.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util$1.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!this._cache) {
            this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util$1.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util$1.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util$1.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!this._cache) {
            this._cache = new Set(util$1.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
            const expectedValues = util$1.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                    if (!isValid(base))
                        return INVALID;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                        status: status.value,
                        value: result,
                    }));
                });
            }
        }
        util$1.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
}
function custom(check, _params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            const r = check(data);
            if (r instanceof Promise) {
                return r.then((r) => {
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = params.fatal ?? fatal ?? true;
                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
                    }
                });
            }
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
            return;
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

const z = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  BRAND,
  DIRTY,
  EMPTY_PATH,
  INVALID,
  NEVER,
  OK,
  ParseStatus,
  Schema: ZodType,
  ZodAny,
  ZodArray,
  ZodBigInt,
  ZodBoolean,
  ZodBranded,
  ZodCatch,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodEnum,
  ZodError,
  get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
  ZodFunction,
  ZodIntersection,
  ZodIssueCode,
  ZodLazy,
  ZodLiteral,
  ZodMap,
  ZodNaN,
  ZodNativeEnum,
  ZodNever,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodObject,
  ZodOptional,
  ZodParsedType,
  ZodPipeline,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodSchema: ZodType,
  ZodSet,
  ZodString,
  ZodSymbol,
  ZodTransformer: ZodEffects,
  ZodTuple,
  ZodType,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  addIssueToContext,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  coerce,
  custom,
  date: dateType,
  datetimeRegex,
  defaultErrorMap: errorMap,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  getErrorMap,
  getParsedType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  late,
  lazy: lazyType,
  literal: literalType,
  makeIssue,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  get objectUtil () { return objectUtil; },
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  quotelessJson,
  record: recordType,
  set: setType,
  setErrorMap,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  get util () { return util$1; },
  void: voidType
}, Symbol.toStringTag, { value: 'Module' }));

var Edge;
(function (Edge) {
    Edge[Edge["EXTEND"] = 1] = "EXTEND";
    Edge[Edge["WRAP"] = 2] = "WRAP";
    Edge[Edge["CROP"] = 3] = "CROP";
})(Edge || (Edge = {}));
const JimpClassSchema = objectType({
    bitmap: objectType({
        data: unionType([instanceOfType(Buffer), instanceOfType(Uint8Array)]),
        width: numberType(),
        height: numberType(),
    }),
});

const BlitOptionsSchemaComplex = objectType({
    src: JimpClassSchema,
    /** the x position to blit the image */
    x: numberType().optional(),
    /** the y position to blit the image */
    y: numberType().optional(),
    /** the x position from which to crop the source image */
    srcX: numberType().optional(),
    /** the y position from which to crop the source image */
    srcY: numberType().optional(),
    /** the width to which to crop the source image */
    srcW: numberType().optional(),
    /** the height to which to crop the source image */
    srcH: numberType().optional(),
});
const BlitOptionsSchema = unionType([JimpClassSchema, BlitOptionsSchemaComplex]);
const methods$h = {
    /**
     * Short for "bit-block transfer".
     * It involves the transfer of a block of pixel data from one area of a computer's memory to another area, typically for the purpose of rendering images on the screen or manipulating them in various ways.
     * It's a fundamental operation in computer graphics utilized in various applications, from operating systems to video games.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const parrot = await Jimp.read("test/party-parrot.png");
     *
     * image.blit({ src: parrot, x: 10, y: 10 });
     * ```
     */
    blit(image, options) {
        const parsed = BlitOptionsSchema.parse(options);
        let { 
        // eslint-disable-next-line prefer-const
        src, x = 0, y = 0, srcX = 0, srcY = 0, srcW = src.bitmap.width, srcH = src.bitmap.height, } = "bitmap" in parsed ? { src: parsed } : parsed;
        if (!("bitmap" in src)) {
            throw new Error("The source must be a Jimp image");
        }
        if (typeof x !== "number" || typeof y !== "number") {
            throw new Error("x and y must be numbers");
        }
        // round input
        x = Math.round(x);
        y = Math.round(y);
        // round input
        srcX = Math.round(srcX);
        srcY = Math.round(srcY);
        srcW = Math.round(srcW);
        srcH = Math.round(srcH);
        const maxWidth = image.bitmap.width;
        const maxHeight = image.bitmap.height;
        scan(src, srcX, srcY, srcW, srcH, function (sx, sy, idx) {
            const xOffset = x + sx - srcX;
            const yOffset = y + sy - srcY;
            if (xOffset >= 0 &&
                yOffset >= 0 &&
                maxWidth - xOffset > 0 &&
                maxHeight - yOffset > 0) {
                const dstIdx = image.getPixelIndex(xOffset, yOffset);
                const srcColor = {
                    r: src.bitmap.data[idx] || 0,
                    g: src.bitmap.data[idx + 1] || 0,
                    b: src.bitmap.data[idx + 2] || 0,
                    a: src.bitmap.data[idx + 3] || 0,
                };
                const dst = {
                    r: image.bitmap.data[dstIdx] || 0,
                    g: image.bitmap.data[dstIdx + 1] || 0,
                    b: image.bitmap.data[dstIdx + 2] || 0,
                    a: image.bitmap.data[dstIdx + 3] || 0,
                };
                image.bitmap.data[dstIdx] =
                    ((srcColor.a * (srcColor.r - dst.r) - dst.r + 255) >> 8) + dst.r;
                image.bitmap.data[dstIdx + 1] =
                    ((srcColor.a * (srcColor.g - dst.g) - dst.g + 255) >> 8) + dst.g;
                image.bitmap.data[dstIdx + 2] =
                    ((srcColor.a * (srcColor.b - dst.b) - dst.b + 255) >> 8) + dst.b;
                image.bitmap.data[dstIdx + 3] = limit255(dst.a + srcColor.a);
            }
        });
        return image;
    },
};

const mulTable = [
    1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107,
    3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221,
    209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103,
    99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119,
    231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151,
    147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13,
    51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75,
    147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229,
    113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183,
    181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37,
    73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61,
    121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207,
    205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178,
    176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153,
    19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133,
    66, 131, 65, 129, 1,
];
const shgTable = [
    0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18,
    16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20,
    20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21,
    20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20,
    22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22,
    22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18,
    22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22,
    21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24,
    24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24,
    24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22,
    25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23,
    25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25,
    20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25,
    22, 25, 25, 25, 24, 25, 24, 25, 18,
];

/*
    Superfast Blur (0.5)
    http://www.quasimondo.com/BoxBlurForCanvas/FastBlur.js

    Copyright (c) 2011 Mario Klingemann

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/
const methods$g = {
    /**
     * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
     * @param r the pixel radius of the blur
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.blur(5);
     * ```
     */
    blur(image, r) {
        if (typeof r !== "number") {
            throw new Error("r must be a number");
        }
        if (r < 1) {
            throw new Error("r must be greater than 0");
        }
        let rsum;
        let gsum;
        let bsum;
        let asum;
        let x;
        let y;
        let i;
        let p;
        let p1;
        let p2;
        let yp;
        let yi;
        let yw;
        const wm = image.bitmap.width - 1;
        const hm = image.bitmap.height - 1;
        // const wh = image.bitmap.width * image.bitmap.height;
        const rad1 = r + 1;
        const mulSum = mulTable[r];
        const shgSum = shgTable[r];
        const red = [];
        const green = [];
        const blue = [];
        const alpha = [];
        const vmin = [];
        const vmax = [];
        let iterations = 2;
        while (iterations-- > 0) {
            yi = 0;
            yw = 0;
            for (y = 0; y < image.bitmap.height; y++) {
                rsum = image.bitmap.data[yw] * rad1;
                gsum = image.bitmap.data[yw + 1] * rad1;
                bsum = image.bitmap.data[yw + 2] * rad1;
                asum = image.bitmap.data[yw + 3] * rad1;
                for (i = 1; i <= r; i++) {
                    p = yw + ((i > wm ? wm : i) << 2);
                    rsum += image.bitmap.data[p++];
                    gsum += image.bitmap.data[p++];
                    bsum += image.bitmap.data[p++];
                    asum += image.bitmap.data[p];
                }
                for (x = 0; x < image.bitmap.width; x++) {
                    red[yi] = rsum;
                    green[yi] = gsum;
                    blue[yi] = bsum;
                    alpha[yi] = asum;
                    if (y === 0) {
                        vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                        vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
                    }
                    p1 = yw + vmin[x];
                    p2 = yw + vmax[x];
                    rsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
                    gsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
                    bsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
                    asum += image.bitmap.data[p1] - image.bitmap.data[p2++];
                    yi++;
                }
                yw += image.bitmap.width << 2;
            }
            for (x = 0; x < image.bitmap.width; x++) {
                yp = x;
                rsum = red[yp] * rad1;
                gsum = green[yp] * rad1;
                bsum = blue[yp] * rad1;
                asum = alpha[yp] * rad1;
                for (i = 1; i <= r; i++) {
                    yp += i > hm ? 0 : image.bitmap.width;
                    rsum += red[yp];
                    gsum += green[yp];
                    bsum += blue[yp];
                    asum += alpha[yp];
                }
                yi = x << 2;
                for (y = 0; y < image.bitmap.height; y++) {
                    image.bitmap.data[yi] = limit255((rsum * mulSum) >>> shgSum);
                    image.bitmap.data[yi + 1] = limit255((gsum * mulSum) >>> shgSum);
                    image.bitmap.data[yi + 2] = limit255((bsum * mulSum) >>> shgSum);
                    image.bitmap.data[yi + 3] = limit255((asum * mulSum) >>> shgSum);
                    if (x === 0) {
                        vmin[y] = ((p = y + rad1) < hm ? p : hm) * image.bitmap.width;
                        vmax[y] = (p = y - r) > 0 ? p * image.bitmap.width : 0;
                    }
                    p1 = x + vmin[y];
                    p2 = x + vmax[y];
                    rsum += red[p1] - red[p2];
                    gsum += green[p1] - green[p2];
                    bsum += blue[p1] - blue[p2];
                    asum += alpha[p1] - alpha[p2];
                    yi += image.bitmap.width << 2;
                }
            }
        }
        return image;
    },
    // http://blog.ivank.net/fastest-gaussian-blur.html
    /**
     * Applies a true Gaussian blur to the image (warning: this is VERY slow)
     * @param r the pixel radius of the blur
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.gaussian(15);
     * ```
     */
    gaussian(image, r) {
        if (typeof r !== "number") {
            throw new Error("r must be a number");
        }
        if (r < 1) {
            throw new Error("r must be greater than 0");
        }
        const rs = Math.ceil(r * 2.57); // significant radius
        const range = rs * 2 + 1;
        const rr2 = r * r * 2;
        const rr2pi = rr2 * Math.PI;
        const weights = [];
        for (let y = 0; y < range; y++) {
            const weightsRow = [];
            for (let x = 0; x < range; x++) {
                const dsq = (x - rs) ** 2 + (y - rs) ** 2;
                weightsRow[x] = Math.exp(-dsq / rr2) / rr2pi;
            }
            weights.push(weightsRow);
        }
        for (let y = 0; y < image.bitmap.height; y++) {
            for (let x = 0; x < image.bitmap.width; x++) {
                let red = 0;
                let green = 0;
                let blue = 0;
                let alpha = 0;
                let wsum = 0;
                for (let iy = 0; iy < range; iy++) {
                    for (let ix = 0; ix < range; ix++) {
                        const x1 = Math.min(image.bitmap.width - 1, Math.max(0, ix + x - rs));
                        const y1 = Math.min(image.bitmap.height - 1, Math.max(0, iy + y - rs));
                        const weight = weights[iy][ix];
                        const idx = (y1 * image.bitmap.width + x1) << 2;
                        red += image.bitmap.data[idx] * weight;
                        green += image.bitmap.data[idx + 1] * weight;
                        blue += image.bitmap.data[idx + 2] * weight;
                        alpha += image.bitmap.data[idx + 3] * weight;
                        wsum += weight;
                    }
                    const idx = (y * image.bitmap.width + x) << 2;
                    image.bitmap.data[idx] = Math.round(red / wsum);
                    image.bitmap.data[idx + 1] = Math.round(green / wsum);
                    image.bitmap.data[idx + 2] = Math.round(blue / wsum);
                    image.bitmap.data[idx + 3] = Math.round(alpha / wsum);
                }
            }
        }
        return image;
    },
};

const CircleOptionsSchema = objectType({
    /** the x position to draw the circle */
    x: numberType().optional(),
    /** the y position to draw the circle */
    y: numberType().optional(),
    /** the radius of the circle */
    radius: numberType().min(0).optional(),
});
const methods$f = {
    /**
     * Creates a circle out of an image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.circle();
     * // or
     * image.circle({ radius: 50, x: 25, y: 25 });
     * ```
     */
    circle(image, options = {}) {
        const parsed = CircleOptionsSchema.parse(options);
        const radius = parsed.radius ||
            (image.bitmap.width > image.bitmap.height
                ? image.bitmap.height
                : image.bitmap.width) / 2;
        const center = {
            x: typeof parsed.x === "number" ? parsed.x : image.bitmap.width / 2,
            y: typeof parsed.y === "number" ? parsed.y : image.bitmap.height / 2,
        };
        image.scan((x, y, idx) => {
            const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
            if (radius - curR <= 0.0) {
                image.bitmap.data[idx + 3] = 0;
            }
            else if (radius - curR < 1.0) {
                image.bitmap.data[idx + 3] = 255 * (radius - curR);
            }
        });
        return image;
    },
};

const ConvolutionMatrixSchema = arrayType(numberType()).min(1).array();
const ConvolutionComplexOptionsSchema = objectType({
    /** a matrix to weight the neighbors sum */
    kernel: ConvolutionMatrixSchema,
    /**define how to sum pixels from outside the border */
    edgeHandling: nativeEnumType(Edge).optional(),
});
const ConvolutionOptionsSchema = unionType([
    ConvolutionMatrixSchema,
    ConvolutionComplexOptionsSchema,
]);
const ConvoluteComplexOptionsSchema = objectType({
    /** the convolution kernel */
    kernel: ConvolutionMatrixSchema,
    /** the x position of the region to apply convolution to */
    x: numberType().optional(),
    /** the y position of the region to apply convolution to */
    y: numberType().optional(),
    /** the width of the region to apply convolution to */
    w: numberType().optional(),
    /** the height of the region to apply convolution to */
    h: numberType().optional(),
});
const ConvoluteOptionsSchema = unionType([
    ConvolutionMatrixSchema,
    ConvoluteComplexOptionsSchema,
]);
const PixelateSize = numberType().min(1).max(Infinity);
const PixelateComplexOptionsSchema = objectType({
    /** the size of the pixels */
    size: PixelateSize,
    /** the x position of the region to pixelate */
    x: numberType().optional(),
    /** the y position of the region to pixelate */
    y: numberType().optional(),
    /** the width of the region to pixelate */
    w: numberType().optional(),
    /** the height of the region to pixelate */
    h: numberType().optional(),
});
const PixelateOptionsSchema = unionType([
    PixelateSize,
    PixelateComplexOptionsSchema,
]);
function applyKernel(image, kernel, x, y) {
    const value = [0, 0, 0, 0];
    const size = (kernel.length - 1) / 2;
    for (let kx = 0; kx < kernel.length; kx += 1) {
        for (let ky = 0; ky < kernel[kx].length; ky += 1) {
            const idx = image.getPixelIndex(x + kx - size, y + ky - size);
            value[0] += image.bitmap.data[idx] * kernel[kx][ky];
            value[1] += image.bitmap.data[idx + 1] * kernel[kx][ky];
            value[2] += image.bitmap.data[idx + 2] * kernel[kx][ky];
            value[3] += image.bitmap.data[idx + 3] * kernel[kx][ky];
        }
    }
    return value;
}
function mix(clr, clr2, p = 50) {
    return {
        r: (clr2.r - clr.r) * (p / 100) + clr.r,
        g: (clr2.g - clr.g) * (p / 100) + clr.g,
        b: (clr2.b - clr.b) * (p / 100) + clr.b,
    };
}
const HueActionSchema = objectType({
    apply: literalType("hue"),
    params: tupleType([numberType().min(-360).max(360)]),
});
const SpinActionSchema = objectType({
    apply: literalType("spin"),
    params: tupleType([numberType().min(-360).max(360)]),
});
const LightenActionSchema = objectType({
    apply: literalType("lighten"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const RGBColorSchema = objectType({
    r: numberType().min(0).max(255),
    g: numberType().min(0).max(255),
    b: numberType().min(0).max(255),
});
const MixActionSchema = objectType({
    apply: literalType("mix"),
    params: unionType([
        tupleType([RGBColorSchema]),
        tupleType([RGBColorSchema, numberType().min(0).max(100)]),
    ]),
});
const TintActionSchema = objectType({
    apply: literalType("tint"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const ShadeActionSchema = objectType({
    apply: literalType("shade"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const XorActionSchema = objectType({
    apply: literalType("xor"),
    params: tupleType([RGBColorSchema]),
});
const RedActionSchema = objectType({
    apply: literalType("red"),
    params: tupleType([numberType().min(-255).max(255)]),
});
const GreenActionSchema = objectType({
    apply: literalType("green"),
    params: tupleType([numberType().min(-255).max(255)]),
});
const BlueActionSchema = objectType({
    apply: literalType("blue"),
    params: tupleType([numberType().min(-255).max(255)]),
});
const BrightenActionSchema = objectType({
    apply: literalType("brighten"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const DarkenActionSchema = objectType({
    apply: literalType("darken"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const DesaturateActionSchema = objectType({
    apply: literalType("desaturate"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const SaturateActionSchema = objectType({
    apply: literalType("saturate"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const GrayscaleActionSchema = objectType({
    apply: literalType("greyscale"),
    params: tupleType([]).optional(),
});
const ColorActionNameSchema = unionType([
    HueActionSchema,
    SpinActionSchema,
    LightenActionSchema,
    MixActionSchema,
    TintActionSchema,
    ShadeActionSchema,
    XorActionSchema,
    RedActionSchema,
    GreenActionSchema,
    BlueActionSchema,
    BrightenActionSchema,
    DarkenActionSchema,
    DesaturateActionSchema,
    SaturateActionSchema,
    GrayscaleActionSchema,
]);
/**
 * Get an image's histogram
 * @return An object with an array of color occurrence counts for each channel (r,g,b)
 */
function histogram(image) {
    const histogram = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0),
    };
    image.scan((_, __, index) => {
        histogram.r[image.bitmap.data[index + 0]]++;
        histogram.g[image.bitmap.data[index + 1]]++;
        histogram.b[image.bitmap.data[index + 2]]++;
    });
    return histogram;
}
/**
 * Normalize values
 * @param  value Pixel channel value.
 * @param  min   Minimum value for channel
 * @param  max   Maximum value for channel
 */
const normalizeValue = function (value, min, max) {
    return ((value - min) * 255) / (max - min);
};
const getBounds = function (histogramChannel) {
    return [
        histogramChannel.findIndex((value) => value > 0),
        255 -
            histogramChannel
                .slice()
                .reverse()
                .findIndex((value) => value > 0),
    ];
};
const methods$e = {
    /**
     * Normalizes the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.normalize();
     * ```
     */
    normalize(image) {
        const h = histogram(image);
        // store bounds (minimum and maximum values)
        const bounds = {
            r: getBounds(h.r),
            g: getBounds(h.g),
            b: getBounds(h.b),
        };
        // apply value transformations
        image.scan((_, __, idx) => {
            const r = image.bitmap.data[idx + 0];
            const g = image.bitmap.data[idx + 1];
            const b = image.bitmap.data[idx + 2];
            image.bitmap.data[idx + 0] = normalizeValue(r, bounds.r[0], bounds.r[1]);
            image.bitmap.data[idx + 1] = normalizeValue(g, bounds.g[0], bounds.g[1]);
            image.bitmap.data[idx + 2] = normalizeValue(b, bounds.b[0], bounds.b[1]);
        });
        return image;
    },
    /**
     * Inverts the colors in the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.invert();
     * ```
     */
    invert(image) {
        image.scan((_, __, idx) => {
            image.bitmap.data[idx] = 255 - image.bitmap.data[idx];
            image.bitmap.data[idx + 1] = 255 - image.bitmap.data[idx + 1];
            image.bitmap.data[idx + 2] = 255 - image.bitmap.data[idx + 2];
        });
        return image;
    },
    /**
     * Adjusts the brightness of the image
     * @param val the amount to adjust the brightness.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.brightness(0.5);
     * ```
     */
    brightness(image, val) {
        if (typeof val !== "number") {
            throw new Error("val must be numbers");
        }
        image.scan((_, __, idx) => {
            image.bitmap.data[idx] = limit255(image.bitmap.data[idx] * val);
            image.bitmap.data[idx + 1] = limit255(image.bitmap.data[idx + 1] * val);
            image.bitmap.data[idx + 2] = limit255(image.bitmap.data[idx + 2] * val);
        });
        return image;
    },
    /**
     * Adjusts the contrast of the image
     * @param val the amount to adjust the contrast, a number between -1 and +1
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.contrast(0.75);
     * ```
     */
    contrast(image, val) {
        if (typeof val !== "number") {
            throw new Error("val must be numbers");
        }
        if (val < -1 || val > 1) {
            throw new Error("val must be a number between -1 and +1");
        }
        const factor = (val + 1) / (1 - val);
        function adjust(value) {
            value = Math.floor(factor * (value - 127) + 127);
            return value < 0 ? 0 : value > 255 ? 255 : value;
        }
        image.scan((_, __, idx) => {
            image.bitmap.data[idx] = adjust(image.bitmap.data[idx]);
            image.bitmap.data[idx + 1] = adjust(image.bitmap.data[idx + 1]);
            image.bitmap.data[idx + 2] = adjust(image.bitmap.data[idx + 2]);
        });
        return image;
    },
    /**
     * Apply a posterize effect
     * @param  n the amount to adjust the contrast, minimum threshold is two
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.posterize(5);
     * ```
     */
    posterize(image, n) {
        if (typeof n !== "number") {
            throw new Error("n must be numbers");
        }
        // minimum of 2 levels
        if (n < 2) {
            n = 2;
        }
        image.scan((_, __, idx) => {
            const r = image.bitmap.data[idx];
            const g = image.bitmap.data[idx + 1];
            const b = image.bitmap.data[idx + 2];
            image.bitmap.data[idx] =
                (Math.floor((r / 255) * (n - 1)) / (n - 1)) * 255;
            image.bitmap.data[idx + 1] =
                (Math.floor((g / 255) * (n - 1)) / (n - 1)) * 255;
            image.bitmap.data[idx + 2] =
                (Math.floor((b / 255) * (n - 1)) / (n - 1)) * 255;
        });
        return image;
    },
    /**
     * Removes colour from the image using ITU Rec 709 luminance values
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.greyscale();
     * ```
     */
    greyscale(image) {
        image.scan((_, __, idx) => {
            // const grey = parseInt(
            //   0.2126 * image.bitmap.data[idx]! +
            //     0.7152 * image.bitmap.data[idx + 1]! +
            //     0.0722 * image.bitmap.data[idx + 2]!,
            //   10
            // );
            const grey = 0.2126 * image.bitmap.data[idx] +
                0.7152 * image.bitmap.data[idx + 1] +
                0.0722 * image.bitmap.data[idx + 2];
            image.bitmap.data[idx] = grey;
            image.bitmap.data[idx + 1] = grey;
            image.bitmap.data[idx + 2] = grey;
        });
        return image;
    },
    /**
     * Multiplies the opacity of each pixel by a factor between 0 and 1
     * @param f A number, the factor by which to multiply the opacity of each pixel
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.opacity(0.5);
     * ```
     */
    opacity(image, f) {
        if (typeof f !== "number") {
            throw new Error("f must be a number");
        }
        if (f < 0 || f > 1) {
            throw new Error("f must be a number from 0 to 1");
        }
        image.scan((_, __, idx) => {
            const v = image.bitmap.data[idx + 3] * f;
            image.bitmap.data[idx + 3] = v;
        });
        return image;
    },
    /**
     * Applies a sepia tone to the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.sepia();
     * ```
     */
    sepia(image) {
        image.scan((_, __, idx) => {
            let red = image.bitmap.data[idx];
            let green = image.bitmap.data[idx + 1];
            let blue = image.bitmap.data[idx + 2];
            red = red * 0.393 + green * 0.769 + blue * 0.189;
            green = red * 0.349 + green * 0.686 + blue * 0.168;
            blue = red * 0.272 + green * 0.534 + blue * 0.131;
            image.bitmap.data[idx] = red < 255 ? red : 255;
            image.bitmap.data[idx + 1] = green < 255 ? green : 255;
            image.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
        });
        return image;
    },
    /**
     * Fades each pixel by a factor between 0 and 1
     * @param f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.fade(0.7);
     * ```
     */
    fade(image, f) {
        if (typeof f !== "number") {
            throw new Error("f must be a number");
        }
        if (f < 0 || f > 1) {
            throw new Error("f must be a number from 0 to 1");
        }
        // this method is an alternative to opacity (which may be deprecated)
        return this.opacity(image, 1 - f);
    },
    /**
     * Adds each element of the image to its local neighbors, weighted by the kernel
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.convolute([
     *   [-1, -1, 0],
     *   [-1, 1, 1],
     *   [0, 1, 1],
     * ]);
     * ```
     */
    convolution(image, options) {
        const parsed = ConvolutionOptionsSchema.parse(options);
        const { kernel, edgeHandling = Edge.EXTEND } = "kernel" in parsed ? parsed : { kernel: parsed, edgeHandling: undefined };
        if (!kernel[0]) {
            throw new Error("kernel must be a matrix");
        }
        const newData = Buffer.from(image.bitmap.data);
        const kRows = kernel.length;
        const kCols = kernel[0].length;
        const rowEnd = Math.floor(kRows / 2);
        const colEnd = Math.floor(kCols / 2);
        const rowIni = -rowEnd;
        const colIni = -colEnd;
        let weight;
        let rSum;
        let gSum;
        let bSum;
        let ri;
        let gi;
        let bi;
        let xi;
        let yi;
        let idxi;
        image.scan((x, y, idx) => {
            bSum = 0;
            gSum = 0;
            rSum = 0;
            for (let row = rowIni; row <= rowEnd; row++) {
                for (let col = colIni; col <= colEnd; col++) {
                    xi = x + col;
                    yi = y + row;
                    weight = kernel[row + rowEnd][col + colEnd];
                    idxi = image.getPixelIndex(xi, yi, edgeHandling);
                    if (idxi === -1) {
                        bi = 0;
                        gi = 0;
                        ri = 0;
                    }
                    else {
                        ri = image.bitmap.data[idxi + 0];
                        gi = image.bitmap.data[idxi + 1];
                        bi = image.bitmap.data[idxi + 2];
                    }
                    rSum += weight * ri;
                    gSum += weight * gi;
                    bSum += weight * bi;
                }
            }
            if (rSum < 0) {
                rSum = 0;
            }
            if (gSum < 0) {
                gSum = 0;
            }
            if (bSum < 0) {
                bSum = 0;
            }
            if (rSum > 255) {
                rSum = 255;
            }
            if (gSum > 255) {
                gSum = 255;
            }
            if (bSum > 255) {
                bSum = 255;
            }
            newData[idx + 0] = rSum;
            newData[idx + 1] = gSum;
            newData[idx + 2] = bSum;
        });
        image.bitmap.data = newData;
        return image;
    },
    /**
     * Set the alpha channel on every pixel to fully opaque.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.opaque();
     * ```
     */
    opaque(image) {
        image.scan((_, __, idx) => {
            image.bitmap.data[idx + 3] = 255;
        });
        return image;
    },
    /**
     * Pixelates the image or a region
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * // pixelate the whole image
     * image.pixelate(10);
     *
     * // pixelate a region
     * image.pixelate(10, 10, 10, 20, 20);
     * ```
     */
    pixelate(image, options) {
        const parsed = PixelateOptionsSchema.parse(options);
        const { size, x = 0, y = 0, w = image.bitmap.width - x, h = image.bitmap.height - y, } = typeof parsed === "number"
            ? { size: parsed }
            : parsed;
        const kernel = [
            [1 / 16, 2 / 16, 1 / 16],
            [2 / 16, 4 / 16, 2 / 16],
            [1 / 16, 2 / 16, 1 / 16],
        ];
        const source = clone(image);
        scan(source, x, y, w, h, (xx, yx, idx) => {
            xx = size * Math.floor(xx / size);
            yx = size * Math.floor(yx / size);
            const value = applyKernel(source, kernel, xx, yx);
            image.bitmap.data[idx] = value[0];
            image.bitmap.data[idx + 1] = value[1];
            image.bitmap.data[idx + 2] = value[2];
            image.bitmap.data[idx + 3] = value[3];
        });
        return image;
    },
    /**
     * Applies a convolution kernel to the image or a region
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * // apply a convolution kernel to the whole image
     * image.convolution([
     *   [-1, -1, 0],
     *   [-1, 1, 1],
     *   [0, 1, 1],
     * ]);
     *
     * // apply a convolution kernel to a region
     * image.convolution([
     *   [-1, -1, 0],
     *   [-1, 1, 1],
     *   [0, 1, 1],
     * ], 10, 10, 10, 20);
     * ```
     */
    convolute(image, options) {
        const parsed = ConvoluteOptionsSchema.parse(options);
        const { kernel, x = 0, y = 0, w = image.bitmap.width - x, h = image.bitmap.height - y, } = "kernel" in parsed
            ? parsed
            : { kernel: parsed };
        const source = clone(image);
        scan(source, x, y, w, h, (xx, yx, idx) => {
            const value = applyKernel(source, kernel, xx, yx);
            image.bitmap.data[idx] = limit255(value[0]);
            image.bitmap.data[idx + 1] = limit255(value[1]);
            image.bitmap.data[idx + 2] = limit255(value[2]);
            image.bitmap.data[idx + 3] = limit255(value[3]);
        });
        return image;
    },
    /**
     * Apply multiple color modification rules
     * @param  actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.color([
     *   { apply: "hue", params: [-90] },
     *   { apply: "lighten", params: [50] },
     *   { apply: "xor", params: ["#06D"] },
     * ]);
     * ```
     */
    color(image, actions) {
        if (!actions || !Array.isArray(actions)) {
            throw new Error("actions must be an array");
        }
        actions.forEach((action) => ColorActionNameSchema.parse(action));
        actions = actions.map((action) => {
            if (action.apply === "xor" || action.apply === "mix") {
                action.params[0] = tinycolor(action.params[0]).toRgb();
            }
            return action;
        });
        image.scan((_, __, idx) => {
            let clr = {
                r: image.bitmap.data[idx],
                g: image.bitmap.data[idx + 1],
                b: image.bitmap.data[idx + 2],
            };
            const colorModifier = (i, amount) => limit255(clr[i] + amount);
            actions.forEach((action) => {
                if (action.apply === "mix") {
                    clr = mix(clr, action.params[0], action.params[1]);
                }
                else if (action.apply === "tint") {
                    clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params?.[0]);
                }
                else if (action.apply === "shade") {
                    clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params?.[0]);
                }
                else if (action.apply === "xor") {
                    clr = {
                        r: clr.r ^ action.params[0].r,
                        g: clr.g ^ action.params[0].g,
                        b: clr.b ^ action.params[0].b,
                    };
                }
                else if (action.apply === "red") {
                    clr.r = colorModifier("r", action.params[0]);
                }
                else if (action.apply === "green") {
                    clr.g = colorModifier("g", action.params[0]);
                }
                else if (action.apply === "blue") {
                    clr.b = colorModifier("b", action.params[0]);
                }
                else {
                    if (action.apply === "hue") {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        action.apply = "spin";
                    }
                    const tnyClr = tinycolor(clr);
                    const fn = tnyClr[action.apply].bind(tnyClr);
                    if (!fn) {
                        throw new Error("action " + action.apply + " not supported");
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    clr = fn(...(action.params || [])).toRgb();
                }
            });
            image.bitmap.data[idx] = clr.r;
            image.bitmap.data[idx + 1] = clr.g;
            image.bitmap.data[idx + 2] = clr.b;
        });
        return image;
    },
};

var lib$1 = {};

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AnsiStringType = exports$1.StringType = exports$1.BufferType = exports$1.Uint8ArrayType = exports$1.IgnoreType = exports$1.Float80_LE = exports$1.Float80_BE = exports$1.Float64_LE = exports$1.Float64_BE = exports$1.Float32_LE = exports$1.Float32_BE = exports$1.Float16_LE = exports$1.Float16_BE = exports$1.INT64_BE = exports$1.UINT64_BE = exports$1.INT64_LE = exports$1.UINT64_LE = exports$1.INT32_LE = exports$1.INT32_BE = exports$1.INT24_BE = exports$1.INT24_LE = exports$1.INT16_LE = exports$1.INT16_BE = exports$1.INT8 = exports$1.UINT32_BE = exports$1.UINT32_LE = exports$1.UINT24_BE = exports$1.UINT24_LE = exports$1.UINT16_BE = exports$1.UINT16_LE = exports$1.UINT8 = void 0;
		const ieee754 = requireIeee754();
		// Primitive types
		function dv(array) {
		    return new DataView(array.buffer, array.byteOffset);
		}
		/**
		 * 8-bit unsigned integer
		 */
		exports$1.UINT8 = {
		    len: 1,
		    get(array, offset) {
		        return dv(array).getUint8(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setUint8(offset, value);
		        return offset + 1;
		    }
		};
		/**
		 * 16-bit unsigned integer, Little Endian byte order
		 */
		exports$1.UINT16_LE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getUint16(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setUint16(offset, value, true);
		        return offset + 2;
		    }
		};
		/**
		 * 16-bit unsigned integer, Big Endian byte order
		 */
		exports$1.UINT16_BE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getUint16(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setUint16(offset, value);
		        return offset + 2;
		    }
		};
		/**
		 * 24-bit unsigned integer, Little Endian byte order
		 */
		exports$1.UINT24_LE = {
		    len: 3,
		    get(array, offset) {
		        const dataView = dv(array);
		        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint8(offset, value & 0xff);
		        dataView.setUint16(offset + 1, value >> 8, true);
		        return offset + 3;
		    }
		};
		/**
		 * 24-bit unsigned integer, Big Endian byte order
		 */
		exports$1.UINT24_BE = {
		    len: 3,
		    get(array, offset) {
		        const dataView = dv(array);
		        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint16(offset, value >> 8);
		        dataView.setUint8(offset + 2, value & 0xff);
		        return offset + 3;
		    }
		};
		/**
		 * 32-bit unsigned integer, Little Endian byte order
		 */
		exports$1.UINT32_LE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getUint32(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setUint32(offset, value, true);
		        return offset + 4;
		    }
		};
		/**
		 * 32-bit unsigned integer, Big Endian byte order
		 */
		exports$1.UINT32_BE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getUint32(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setUint32(offset, value);
		        return offset + 4;
		    }
		};
		/**
		 * 8-bit signed integer
		 */
		exports$1.INT8 = {
		    len: 1,
		    get(array, offset) {
		        return dv(array).getInt8(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setInt8(offset, value);
		        return offset + 1;
		    }
		};
		/**
		 * 16-bit signed integer, Big Endian byte order
		 */
		exports$1.INT16_BE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getInt16(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setInt16(offset, value);
		        return offset + 2;
		    }
		};
		/**
		 * 16-bit signed integer, Little Endian byte order
		 */
		exports$1.INT16_LE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getInt16(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setInt16(offset, value, true);
		        return offset + 2;
		    }
		};
		/**
		 * 24-bit signed integer, Little Endian byte order
		 */
		exports$1.INT24_LE = {
		    len: 3,
		    get(array, offset) {
		        const unsigned = exports$1.UINT24_LE.get(array, offset);
		        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint8(offset, value & 0xff);
		        dataView.setUint16(offset + 1, value >> 8, true);
		        return offset + 3;
		    }
		};
		/**
		 * 24-bit signed integer, Big Endian byte order
		 */
		exports$1.INT24_BE = {
		    len: 3,
		    get(array, offset) {
		        const unsigned = exports$1.UINT24_BE.get(array, offset);
		        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint16(offset, value >> 8);
		        dataView.setUint8(offset + 2, value & 0xff);
		        return offset + 3;
		    }
		};
		/**
		 * 32-bit signed integer, Big Endian byte order
		 */
		exports$1.INT32_BE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getInt32(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setInt32(offset, value);
		        return offset + 4;
		    }
		};
		/**
		 * 32-bit signed integer, Big Endian byte order
		 */
		exports$1.INT32_LE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getInt32(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setInt32(offset, value, true);
		        return offset + 4;
		    }
		};
		/**
		 * 64-bit unsigned integer, Little Endian byte order
		 */
		exports$1.UINT64_LE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigUint64(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setBigUint64(offset, value, true);
		        return offset + 8;
		    }
		};
		/**
		 * 64-bit signed integer, Little Endian byte order
		 */
		exports$1.INT64_LE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigInt64(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setBigInt64(offset, value, true);
		        return offset + 8;
		    }
		};
		/**
		 * 64-bit unsigned integer, Big Endian byte order
		 */
		exports$1.UINT64_BE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigUint64(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setBigUint64(offset, value);
		        return offset + 8;
		    }
		};
		/**
		 * 64-bit signed integer, Big Endian byte order
		 */
		exports$1.INT64_BE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigInt64(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setBigInt64(offset, value);
		        return offset + 8;
		    }
		};
		/**
		 * IEEE 754 16-bit (half precision) float, big endian
		 */
		exports$1.Float16_BE = {
		    len: 2,
		    get(dataView, offset) {
		        return ieee754.read(dataView, offset, false, 10, this.len);
		    },
		    put(dataView, offset, value) {
		        ieee754.write(dataView, value, offset, false, 10, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * IEEE 754 16-bit (half precision) float, little endian
		 */
		exports$1.Float16_LE = {
		    len: 2,
		    get(array, offset) {
		        return ieee754.read(array, offset, true, 10, this.len);
		    },
		    put(array, offset, value) {
		        ieee754.write(array, value, offset, true, 10, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * IEEE 754 32-bit (single precision) float, big endian
		 */
		exports$1.Float32_BE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getFloat32(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat32(offset, value);
		        return offset + 4;
		    }
		};
		/**
		 * IEEE 754 32-bit (single precision) float, little endian
		 */
		exports$1.Float32_LE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getFloat32(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat32(offset, value, true);
		        return offset + 4;
		    }
		};
		/**
		 * IEEE 754 64-bit (double precision) float, big endian
		 */
		exports$1.Float64_BE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getFloat64(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat64(offset, value);
		        return offset + 8;
		    }
		};
		/**
		 * IEEE 754 64-bit (double precision) float, little endian
		 */
		exports$1.Float64_LE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getFloat64(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat64(offset, value, true);
		        return offset + 8;
		    }
		};
		/**
		 * IEEE 754 80-bit (extended precision) float, big endian
		 */
		exports$1.Float80_BE = {
		    len: 10,
		    get(array, offset) {
		        return ieee754.read(array, offset, false, 63, this.len);
		    },
		    put(array, offset, value) {
		        ieee754.write(array, value, offset, false, 63, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * IEEE 754 80-bit (extended precision) float, little endian
		 */
		exports$1.Float80_LE = {
		    len: 10,
		    get(array, offset) {
		        return ieee754.read(array, offset, true, 63, this.len);
		    },
		    put(array, offset, value) {
		        ieee754.write(array, value, offset, true, 63, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * Ignore a given number of bytes
		 */
		class IgnoreType {
		    /**
		     * @param len number of bytes to ignore
		     */
		    constructor(len) {
		        this.len = len;
		    }
		    // ToDo: don't read, but skip data
		    get(array, off) {
		    }
		}
		exports$1.IgnoreType = IgnoreType;
		class Uint8ArrayType {
		    constructor(len) {
		        this.len = len;
		    }
		    get(array, offset) {
		        return array.subarray(offset, offset + this.len);
		    }
		}
		exports$1.Uint8ArrayType = Uint8ArrayType;
		class BufferType {
		    constructor(len) {
		        this.len = len;
		    }
		    get(uint8Array, off) {
		        return Buffer.from(uint8Array.subarray(off, off + this.len));
		    }
		}
		exports$1.BufferType = BufferType;
		/**
		 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
		 */
		class StringType {
		    constructor(len, encoding) {
		        this.len = len;
		        this.encoding = encoding;
		    }
		    get(uint8Array, offset) {
		        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
		    }
		}
		exports$1.StringType = StringType;
		/**
		 * ANSI Latin 1 String
		 * Using windows-1252 / ISO 8859-1 decoding
		 */
		class AnsiStringType {
		    constructor(len) {
		        this.len = len;
		    }
		    static decode(buffer, offset, until) {
		        let str = '';
		        for (let i = offset; i < until; ++i) {
		            str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
		        }
		        return str;
		    }
		    static inRange(a, min, max) {
		        return min <= a && a <= max;
		    }
		    static codePointToString(cp) {
		        if (cp <= 0xFFFF) {
		            return String.fromCharCode(cp);
		        }
		        else {
		            cp -= 0x10000;
		            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
		        }
		    }
		    static singleByteDecoder(bite) {
		        if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {
		            return bite;
		        }
		        const codePoint = AnsiStringType.windows1252[bite - 0x80];
		        if (codePoint === null) {
		            throw Error('invaliding encoding');
		        }
		        return codePoint;
		    }
		    get(buffer, offset = 0) {
		        return AnsiStringType.decode(buffer, offset, offset + this.len);
		    }
		}
		exports$1.AnsiStringType = AnsiStringType;
		AnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,
		    8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,
		    8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,
		    169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
		    185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,
		    201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
		    217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
		    233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
		    248, 249, 250, 251, 252, 253, 254, 255]; 
	} (lib$1));
	return lib$1;
}

var core$1 = {};

var ReadStreamTokenizer = {};

var AbstractTokenizer = {};

var lib = {};

var EndOfFileStream = {};

var hasRequiredEndOfFileStream;

function requireEndOfFileStream () {
	if (hasRequiredEndOfFileStream) return EndOfFileStream;
	hasRequiredEndOfFileStream = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.EndOfStreamError = exports$1.defaultMessages = void 0;
		exports$1.defaultMessages = 'End-Of-Stream';
		/**
		 * Thrown on read operation of the end of file or stream has been reached
		 */
		class EndOfStreamError extends Error {
		    constructor() {
		        super(exports$1.defaultMessages);
		    }
		}
		exports$1.EndOfStreamError = EndOfStreamError; 
	} (EndOfFileStream));
	return EndOfFileStream;
}

var StreamReader = {};

var Deferred = {};

var hasRequiredDeferred;

function requireDeferred () {
	if (hasRequiredDeferred) return Deferred;
	hasRequiredDeferred = 1;
	Object.defineProperty(Deferred, "__esModule", { value: true });
	Deferred.Deferred = void 0;
	let Deferred$1 = class Deferred {
	    constructor() {
	        this.resolve = () => null;
	        this.reject = () => null;
	        this.promise = new Promise((resolve, reject) => {
	            this.reject = reject;
	            this.resolve = resolve;
	        });
	    }
	};
	Deferred.Deferred = Deferred$1;
	return Deferred;
}

var hasRequiredStreamReader;

function requireStreamReader () {
	if (hasRequiredStreamReader) return StreamReader;
	hasRequiredStreamReader = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.StreamReader = exports$1.EndOfStreamError = void 0;
		const EndOfFileStream_1 = requireEndOfFileStream();
		const Deferred_1 = requireDeferred();
		var EndOfFileStream_2 = requireEndOfFileStream();
		Object.defineProperty(exports$1, "EndOfStreamError", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });
		const maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation
		class StreamReader {
		    constructor(s) {
		        this.s = s;
		        /**
		         * Deferred used for postponed read request (as not data is yet available to read)
		         */
		        this.deferred = null;
		        this.endOfStream = false;
		        /**
		         * Store peeked data
		         * @type {Array}
		         */
		        this.peekQueue = [];
		        if (!s.read || !s.once) {
		            throw new Error('Expected an instance of stream.Readable');
		        }
		        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
		        this.s.once('error', err => this.reject(err));
		        this.s.once('close', () => this.reject(new Error('Stream closed')));
		    }
		    /**
		     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
		     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
		     * @param offset - Offset target
		     * @param length - Number of bytes to read
		     * @returns Number of bytes peeked
		     */
		    async peek(uint8Array, offset, length) {
		        const bytesRead = await this.read(uint8Array, offset, length);
		        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
		        return bytesRead;
		    }
		    /**
		     * Read chunk from stream
		     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
		     * @param offset - Offset target
		     * @param length - Number of bytes to read
		     * @returns Number of bytes read
		     */
		    async read(buffer, offset, length) {
		        if (length === 0) {
		            return 0;
		        }
		        if (this.peekQueue.length === 0 && this.endOfStream) {
		            throw new EndOfFileStream_1.EndOfStreamError();
		        }
		        let remaining = length;
		        let bytesRead = 0;
		        // consume peeked data first
		        while (this.peekQueue.length > 0 && remaining > 0) {
		            const peekData = this.peekQueue.pop(); // Front of queue
		            if (!peekData)
		                throw new Error('peekData should be defined');
		            const lenCopy = Math.min(peekData.length, remaining);
		            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
		            bytesRead += lenCopy;
		            remaining -= lenCopy;
		            if (lenCopy < peekData.length) {
		                // remainder back to queue
		                this.peekQueue.push(peekData.subarray(lenCopy));
		            }
		        }
		        // continue reading from stream if required
		        while (remaining > 0 && !this.endOfStream) {
		            const reqLen = Math.min(remaining, maxStreamReadSize);
		            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
		            bytesRead += chunkLen;
		            if (chunkLen < reqLen)
		                break;
		            remaining -= chunkLen;
		        }
		        return bytesRead;
		    }
		    /**
		     * Read chunk from stream
		     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
		     * @param offset Offset target
		     * @param length Number of bytes to read
		     * @returns Number of bytes read
		     */
		    async readFromStream(buffer, offset, length) {
		        const readBuffer = this.s.read(length);
		        if (readBuffer) {
		            buffer.set(readBuffer, offset);
		            return readBuffer.length;
		        }
		        else {
		            const request = {
		                buffer,
		                offset,
		                length,
		                deferred: new Deferred_1.Deferred()
		            };
		            this.deferred = request.deferred;
		            this.s.once('readable', () => {
		                this.readDeferred(request);
		            });
		            return request.deferred.promise;
		        }
		    }
		    /**
		     * Process deferred read request
		     * @param request Deferred read request
		     */
		    readDeferred(request) {
		        const readBuffer = this.s.read(request.length);
		        if (readBuffer) {
		            request.buffer.set(readBuffer, request.offset);
		            request.deferred.resolve(readBuffer.length);
		            this.deferred = null;
		        }
		        else {
		            this.s.once('readable', () => {
		                this.readDeferred(request);
		            });
		        }
		    }
		    reject(err) {
		        this.endOfStream = true;
		        if (this.deferred) {
		            this.deferred.reject(err);
		            this.deferred = null;
		        }
		    }
		}
		exports$1.StreamReader = StreamReader; 
	} (StreamReader));
	return StreamReader;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.StreamReader = exports$1.EndOfStreamError = void 0;
		var EndOfFileStream_1 = requireEndOfFileStream();
		Object.defineProperty(exports$1, "EndOfStreamError", { enumerable: true, get: function () { return EndOfFileStream_1.EndOfStreamError; } });
		var StreamReader_1 = requireStreamReader();
		Object.defineProperty(exports$1, "StreamReader", { enumerable: true, get: function () { return StreamReader_1.StreamReader; } }); 
	} (lib));
	return lib;
}

var hasRequiredAbstractTokenizer;

function requireAbstractTokenizer () {
	if (hasRequiredAbstractTokenizer) return AbstractTokenizer;
	hasRequiredAbstractTokenizer = 1;
	Object.defineProperty(AbstractTokenizer, "__esModule", { value: true });
	AbstractTokenizer.AbstractTokenizer = void 0;
	const peek_readable_1 = requireLib();
	/**
	 * Core tokenizer
	 */
	let AbstractTokenizer$1 = class AbstractTokenizer {
	    constructor(fileInfo) {
	        /**
	         * Tokenizer-stream position
	         */
	        this.position = 0;
	        this.numBuffer = new Uint8Array(8);
	        this.fileInfo = fileInfo ? fileInfo : {};
	    }
	    /**
	     * Read a token from the tokenizer-stream
	     * @param token - The token to read
	     * @param position - If provided, the desired position in the tokenizer-stream
	     * @returns Promise with token data
	     */
	    async readToken(token, position = this.position) {
	        const uint8Array = Buffer.alloc(token.len);
	        const len = await this.readBuffer(uint8Array, { position });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(uint8Array, 0);
	    }
	    /**
	     * Peek a token from the tokenizer-stream.
	     * @param token - Token to peek from the tokenizer-stream.
	     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
	     * @returns Promise with token data
	     */
	    async peekToken(token, position = this.position) {
	        const uint8Array = Buffer.alloc(token.len);
	        const len = await this.peekBuffer(uint8Array, { position });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(uint8Array, 0);
	    }
	    /**
	     * Read a numeric token from the stream
	     * @param token - Numeric token
	     * @returns Promise with number
	     */
	    async readNumber(token) {
	        const len = await this.readBuffer(this.numBuffer, { length: token.len });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(this.numBuffer, 0);
	    }
	    /**
	     * Read a numeric token from the stream
	     * @param token - Numeric token
	     * @returns Promise with number
	     */
	    async peekNumber(token) {
	        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(this.numBuffer, 0);
	    }
	    /**
	     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
	     * @param length - Number of bytes to ignore
	     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
	     */
	    async ignore(length) {
	        if (this.fileInfo.size !== undefined) {
	            const bytesLeft = this.fileInfo.size - this.position;
	            if (length > bytesLeft) {
	                this.position += bytesLeft;
	                return bytesLeft;
	            }
	        }
	        this.position += length;
	        return length;
	    }
	    async close() {
	        // empty
	    }
	    normalizeOptions(uint8Array, options) {
	        if (options && options.position !== undefined && options.position < this.position) {
	            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	        }
	        if (options) {
	            return {
	                mayBeLess: options.mayBeLess === true,
	                offset: options.offset ? options.offset : 0,
	                length: options.length ? options.length : (uint8Array.length - (options.offset ? options.offset : 0)),
	                position: options.position ? options.position : this.position
	            };
	        }
	        return {
	            mayBeLess: false,
	            offset: 0,
	            length: uint8Array.length,
	            position: this.position
	        };
	    }
	};
	AbstractTokenizer.AbstractTokenizer = AbstractTokenizer$1;
	return AbstractTokenizer;
}

var hasRequiredReadStreamTokenizer;

function requireReadStreamTokenizer () {
	if (hasRequiredReadStreamTokenizer) return ReadStreamTokenizer;
	hasRequiredReadStreamTokenizer = 1;
	Object.defineProperty(ReadStreamTokenizer, "__esModule", { value: true });
	ReadStreamTokenizer.ReadStreamTokenizer = void 0;
	const AbstractTokenizer_1 = requireAbstractTokenizer();
	const peek_readable_1 = requireLib();
	const maxBufferSize = 256000;
	let ReadStreamTokenizer$1 = class ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
	    constructor(stream, fileInfo) {
	        super(fileInfo);
	        this.streamReader = new peek_readable_1.StreamReader(stream);
	    }
	    /**
	     * Get file information, an HTTP-client may implement this doing a HEAD request
	     * @return Promise with file information
	     */
	    async getFileInfo() {
	        return this.fileInfo;
	    }
	    /**
	     * Read buffer from tokenizer
	     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
	     * @param options - Read behaviour options
	     * @returns Promise with number of bytes read
	     */
	    async readBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        const skipBytes = normOptions.position - this.position;
	        if (skipBytes > 0) {
	            await this.ignore(skipBytes);
	            return this.readBuffer(uint8Array, options);
	        }
	        else if (skipBytes < 0) {
	            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	        }
	        if (normOptions.length === 0) {
	            return 0;
	        }
	        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
	        this.position += bytesRead;
	        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
	            throw new peek_readable_1.EndOfStreamError();
	        }
	        return bytesRead;
	    }
	    /**
	     * Peek (read ahead) buffer from tokenizer
	     * @param uint8Array - Uint8Array (or Buffer) to write data to
	     * @param options - Read behaviour options
	     * @returns Promise with number of bytes peeked
	     */
	    async peekBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        let bytesRead = 0;
	        if (normOptions.position) {
	            const skipBytes = normOptions.position - this.position;
	            if (skipBytes > 0) {
	                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
	                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
	                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
	                return bytesRead - skipBytes;
	            }
	            else if (skipBytes < 0) {
	                throw new Error('Cannot peek from a negative offset in a stream');
	            }
	        }
	        if (normOptions.length > 0) {
	            try {
	                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
	            }
	            catch (err) {
	                if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
	                    return 0;
	                }
	                throw err;
	            }
	            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {
	                throw new peek_readable_1.EndOfStreamError();
	            }
	        }
	        return bytesRead;
	    }
	    async ignore(length) {
	        // debug(`ignore ${this.position}...${this.position + length - 1}`);
	        const bufSize = Math.min(maxBufferSize, length);
	        const buf = new Uint8Array(bufSize);
	        let totBytesRead = 0;
	        while (totBytesRead < length) {
	            const remaining = length - totBytesRead;
	            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
	            if (bytesRead < 0) {
	                return bytesRead;
	            }
	            totBytesRead += bytesRead;
	        }
	        return totBytesRead;
	    }
	};
	ReadStreamTokenizer.ReadStreamTokenizer = ReadStreamTokenizer$1;
	return ReadStreamTokenizer;
}

var BufferTokenizer = {};

var hasRequiredBufferTokenizer;

function requireBufferTokenizer () {
	if (hasRequiredBufferTokenizer) return BufferTokenizer;
	hasRequiredBufferTokenizer = 1;
	Object.defineProperty(BufferTokenizer, "__esModule", { value: true });
	BufferTokenizer.BufferTokenizer = void 0;
	const peek_readable_1 = requireLib();
	const AbstractTokenizer_1 = requireAbstractTokenizer();
	let BufferTokenizer$1 = class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
	    /**
	     * Construct BufferTokenizer
	     * @param uint8Array - Uint8Array to tokenize
	     * @param fileInfo - Pass additional file information to the tokenizer
	     */
	    constructor(uint8Array, fileInfo) {
	        super(fileInfo);
	        this.uint8Array = uint8Array;
	        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
	    }
	    /**
	     * Read buffer from tokenizer
	     * @param uint8Array - Uint8Array to tokenize
	     * @param options - Read behaviour options
	     * @returns {Promise<number>}
	     */
	    async readBuffer(uint8Array, options) {
	        if (options && options.position) {
	            if (options.position < this.position) {
	                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	            }
	            this.position = options.position;
	        }
	        const bytesRead = await this.peekBuffer(uint8Array, options);
	        this.position += bytesRead;
	        return bytesRead;
	    }
	    /**
	     * Peek (read ahead) buffer from tokenizer
	     * @param uint8Array
	     * @param options - Read behaviour options
	     * @returns {Promise<number>}
	     */
	    async peekBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
	        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {
	            throw new peek_readable_1.EndOfStreamError();
	        }
	        else {
	            uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
	            return bytes2read;
	        }
	    }
	    async close() {
	        // empty
	    }
	};
	BufferTokenizer.BufferTokenizer = BufferTokenizer$1;
	return BufferTokenizer;
}

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.fromBuffer = exports$1.fromStream = exports$1.EndOfStreamError = void 0;
		const ReadStreamTokenizer_1 = requireReadStreamTokenizer();
		const BufferTokenizer_1 = requireBufferTokenizer();
		var peek_readable_1 = requireLib();
		Object.defineProperty(exports$1, "EndOfStreamError", { enumerable: true, get: function () { return peek_readable_1.EndOfStreamError; } });
		/**
		 * Construct ReadStreamTokenizer from given Stream.
		 * Will set fileSize, if provided given Stream has set the .path property/
		 * @param stream - Read from Node.js Stream.Readable
		 * @param fileInfo - Pass the file information, like size and MIME-type of the corresponding stream.
		 * @returns ReadStreamTokenizer
		 */
		function fromStream(stream, fileInfo) {
		    fileInfo = fileInfo ? fileInfo : {};
		    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);
		}
		exports$1.fromStream = fromStream;
		/**
		 * Construct ReadStreamTokenizer from given Buffer.
		 * @param uint8Array - Uint8Array to tokenize
		 * @param fileInfo - Pass additional file information to the tokenizer
		 * @returns BufferTokenizer
		 */
		function fromBuffer(uint8Array, fileInfo) {
		    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
		}
		exports$1.fromBuffer = fromBuffer; 
	} (core$1));
	return core$1;
}

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;

	util.stringToBytes = string => [...string].map(character => character.charCodeAt(0));

	/**
	Checks whether the TAR checksum is valid.

	@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.
	@param {number} offset - TAR header offset.
	@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
	*/
	util.tarHeaderChecksumMatches = (buffer, offset = 0) => {
		const readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\0.*$/, '').trim(), 8); // Read sum in header
		if (isNaN(readSum)) {
			return false;
		}

		let sum = 8 * 0x20; // Initialize signed bit sum

		for (let i = offset; i < offset + 148; i++) {
			sum += buffer[i];
		}

		for (let i = offset + 156; i < offset + 512; i++) {
			sum += buffer[i];
		}

		return readSum === sum;
	};

	/**
	ID3 UINT32 sync-safe tokenizer token.
	28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
	*/
	util.uint32SyncSafeToken = {
		get: (buffer, offset) => {
			return (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);
		},
		len: 4
	};
	return util;
}

var supported;
var hasRequiredSupported;

function requireSupported () {
	if (hasRequiredSupported) return supported;
	hasRequiredSupported = 1;

	supported = {
		extensions: [
			'jpg',
			'png',
			'apng',
			'gif',
			'webp',
			'flif',
			'xcf',
			'cr2',
			'cr3',
			'orf',
			'arw',
			'dng',
			'nef',
			'rw2',
			'raf',
			'tif',
			'bmp',
			'icns',
			'jxr',
			'psd',
			'indd',
			'zip',
			'tar',
			'rar',
			'gz',
			'bz2',
			'7z',
			'dmg',
			'mp4',
			'mid',
			'mkv',
			'webm',
			'mov',
			'avi',
			'mpg',
			'mp2',
			'mp3',
			'm4a',
			'oga',
			'ogg',
			'ogv',
			'opus',
			'flac',
			'wav',
			'spx',
			'amr',
			'pdf',
			'epub',
			'exe',
			'swf',
			'rtf',
			'wasm',
			'woff',
			'woff2',
			'eot',
			'ttf',
			'otf',
			'ico',
			'flv',
			'ps',
			'xz',
			'sqlite',
			'nes',
			'crx',
			'xpi',
			'cab',
			'deb',
			'ar',
			'rpm',
			'Z',
			'lz',
			'cfb',
			'mxf',
			'mts',
			'blend',
			'bpg',
			'docx',
			'pptx',
			'xlsx',
			'3gp',
			'3g2',
			'jp2',
			'jpm',
			'jpx',
			'mj2',
			'aif',
			'qcp',
			'odt',
			'ods',
			'odp',
			'xml',
			'mobi',
			'heic',
			'cur',
			'ktx',
			'ape',
			'wv',
			'dcm',
			'ics',
			'glb',
			'pcap',
			'dsf',
			'lnk',
			'alias',
			'voc',
			'ac3',
			'm4v',
			'm4p',
			'm4b',
			'f4v',
			'f4p',
			'f4b',
			'f4a',
			'mie',
			'asf',
			'ogm',
			'ogx',
			'mpc',
			'arrow',
			'shp',
			'aac',
			'mp1',
			'it',
			's3m',
			'xm',
			'ai',
			'skp',
			'avif',
			'eps',
			'lzh',
			'pgp',
			'asar',
			'stl',
			'chm',
			'3mf',
			'zst',
			'jxl',
			'vcf'
		],
		mimeTypes: [
			'image/jpeg',
			'image/png',
			'image/gif',
			'image/webp',
			'image/flif',
			'image/x-xcf',
			'image/x-canon-cr2',
			'image/x-canon-cr3',
			'image/tiff',
			'image/bmp',
			'image/vnd.ms-photo',
			'image/vnd.adobe.photoshop',
			'application/x-indesign',
			'application/epub+zip',
			'application/x-xpinstall',
			'application/vnd.oasis.opendocument.text',
			'application/vnd.oasis.opendocument.spreadsheet',
			'application/vnd.oasis.opendocument.presentation',
			'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
			'application/vnd.openxmlformats-officedocument.presentationml.presentation',
			'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
			'application/zip',
			'application/x-tar',
			'application/x-rar-compressed',
			'application/gzip',
			'application/x-bzip2',
			'application/x-7z-compressed',
			'application/x-apple-diskimage',
			'application/x-apache-arrow',
			'video/mp4',
			'audio/midi',
			'video/x-matroska',
			'video/webm',
			'video/quicktime',
			'video/vnd.avi',
			'audio/vnd.wave',
			'audio/qcelp',
			'audio/x-ms-asf',
			'video/x-ms-asf',
			'application/vnd.ms-asf',
			'video/mpeg',
			'video/3gpp',
			'audio/mpeg',
			'audio/mp4', // RFC 4337
			'audio/opus',
			'video/ogg',
			'audio/ogg',
			'application/ogg',
			'audio/x-flac',
			'audio/ape',
			'audio/wavpack',
			'audio/amr',
			'application/pdf',
			'application/x-msdownload',
			'application/x-shockwave-flash',
			'application/rtf',
			'application/wasm',
			'font/woff',
			'font/woff2',
			'application/vnd.ms-fontobject',
			'font/ttf',
			'font/otf',
			'image/x-icon',
			'video/x-flv',
			'application/postscript',
			'application/eps',
			'application/x-xz',
			'application/x-sqlite3',
			'application/x-nintendo-nes-rom',
			'application/x-google-chrome-extension',
			'application/vnd.ms-cab-compressed',
			'application/x-deb',
			'application/x-unix-archive',
			'application/x-rpm',
			'application/x-compress',
			'application/x-lzip',
			'application/x-cfb',
			'application/x-mie',
			'application/mxf',
			'video/mp2t',
			'application/x-blender',
			'image/bpg',
			'image/jp2',
			'image/jpx',
			'image/jpm',
			'image/mj2',
			'audio/aiff',
			'application/xml',
			'application/x-mobipocket-ebook',
			'image/heif',
			'image/heif-sequence',
			'image/heic',
			'image/heic-sequence',
			'image/icns',
			'image/ktx',
			'application/dicom',
			'audio/x-musepack',
			'text/calendar',
			'text/vcard',
			'model/gltf-binary',
			'application/vnd.tcpdump.pcap',
			'audio/x-dsf', // Non-standard
			'application/x.ms.shortcut', // Invented by us
			'application/x.apple.alias', // Invented by us
			'audio/x-voc',
			'audio/vnd.dolby.dd-raw',
			'audio/x-m4a',
			'image/apng',
			'image/x-olympus-orf',
			'image/x-sony-arw',
			'image/x-adobe-dng',
			'image/x-nikon-nef',
			'image/x-panasonic-rw2',
			'image/x-fujifilm-raf',
			'video/x-m4v',
			'video/3gpp2',
			'application/x-esri-shape',
			'audio/aac',
			'audio/x-it',
			'audio/x-s3m',
			'audio/x-xm',
			'video/MP1S',
			'video/MP2P',
			'application/vnd.sketchup.skp',
			'image/avif',
			'application/x-lzh-compressed',
			'application/pgp-encrypted',
			'application/x-asar',
			'model/stl',
			'application/vnd.ms-htmlhelp',
			'model/3mf',
			'image/jxl',
			'application/zstd'
		]
	};
	return supported;
}

var core;
var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	const Token = requireLib$1();
	const strtok3 = requireCore$1();
	const {
		stringToBytes,
		tarHeaderChecksumMatches,
		uint32SyncSafeToken
	} = requireUtil();
	const supported = requireSupported();

	const minimumBytes = 4100; // A fair amount of file-types are detectable within this range

	async function fromStream(stream) {
		const tokenizer = await strtok3.fromStream(stream);
		try {
			return await fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async function fromBuffer(input) {
		if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
			throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
		}

		const buffer = input instanceof Buffer ? input : Buffer.from(input);

		if (!(buffer && buffer.length > 1)) {
			return;
		}

		const tokenizer = strtok3.fromBuffer(buffer);
		return fromTokenizer(tokenizer);
	}

	function _check(buffer, headers, options) {
		options = {
			offset: 0,
			...options
		};

		for (const [index, header] of headers.entries()) {
			// If a bitmask is set
			if (options.mask) {
				// If header doesn't equal `buf` with bits masked off
				if (header !== (options.mask[index] & buffer[index + options.offset])) {
					return false;
				}
			} else if (header !== buffer[index + options.offset]) {
				return false;
			}
		}

		return true;
	}

	async function fromTokenizer(tokenizer) {
		try {
			return _fromTokenizer(tokenizer);
		} catch (error) {
			if (!(error instanceof strtok3.EndOfStreamError)) {
				throw error;
			}
		}
	}

	async function _fromTokenizer(tokenizer) {
		let buffer = Buffer.alloc(minimumBytes);
		const bytesRead = 12;
		const check = (header, options) => _check(buffer, header, options);
		const checkString = (header, options) => check(stringToBytes(header), options);

		// Keep reading until EOF if the file size is unknown.
		if (!tokenizer.fileInfo.size) {
			tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
		}

		await tokenizer.peekBuffer(buffer, {length: bytesRead, mayBeLess: true});

		// -- 2-byte signatures --

		if (check([0x42, 0x4D])) {
			return {
				ext: 'bmp',
				mime: 'image/bmp'
			};
		}

		if (check([0x0B, 0x77])) {
			return {
				ext: 'ac3',
				mime: 'audio/vnd.dolby.dd-raw'
			};
		}

		if (check([0x78, 0x01])) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage'
			};
		}

		if (check([0x4D, 0x5A])) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload'
			};
		}

		if (check([0x25, 0x21])) {
			await tokenizer.peekBuffer(buffer, {length: 24, mayBeLess: true});

			if (checkString('PS-Adobe-', {offset: 2}) &&
				checkString(' EPSF-', {offset: 14})) {
				return {
					ext: 'eps',
					mime: 'application/eps'
				};
			}

			return {
				ext: 'ps',
				mime: 'application/postscript'
			};
		}

		if (
			check([0x1F, 0xA0]) ||
			check([0x1F, 0x9D])
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress'
			};
		}

		// -- 3-byte signatures --

		if (check([0xFF, 0xD8, 0xFF])) {
			return {
				ext: 'jpg',
				mime: 'image/jpeg'
			};
		}

		if (check([0x49, 0x49, 0xBC])) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo'
			};
		}

		if (check([0x1F, 0x8B, 0x8])) {
			return {
				ext: 'gz',
				mime: 'application/gzip'
			};
		}

		if (check([0x42, 0x5A, 0x68])) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2'
			};
		}

		if (checkString('ID3')) {
			await tokenizer.ignore(6); // Skip ID3 header until the header size
			const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
			if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
				// Guess file type based on ID3 header for backward compatibility
				return {
					ext: 'mp3',
					mime: 'audio/mpeg'
				};
			}

			await tokenizer.ignore(id3HeaderLen);
			return fromTokenizer(tokenizer); // Skip ID3 header, recursion
		}

		// Musepack, SV7
		if (checkString('MP+')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack'
			};
		}

		if (
			(buffer[0] === 0x43 || buffer[0] === 0x46) &&
			check([0x57, 0x53], {offset: 1})
		) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash'
			};
		}

		// -- 4-byte signatures --

		if (check([0x47, 0x49, 0x46])) {
			return {
				ext: 'gif',
				mime: 'image/gif'
			};
		}

		if (checkString('FLIF')) {
			return {
				ext: 'flif',
				mime: 'image/flif'
			};
		}

		if (checkString('8BPS')) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop'
			};
		}

		if (checkString('WEBP', {offset: 8})) {
			return {
				ext: 'webp',
				mime: 'image/webp'
			};
		}

		// Musepack, SV8
		if (checkString('MPCK')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack'
			};
		}

		if (checkString('FORM')) {
			return {
				ext: 'aif',
				mime: 'audio/aiff'
			};
		}

		if (checkString('icns', {offset: 0})) {
			return {
				ext: 'icns',
				mime: 'image/icns'
			};
		}

		// Zip-based file formats
		// Need to be before the `zip` check
		if (check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature
			try {
				while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
					await tokenizer.readBuffer(buffer, {length: 30});

					// https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
					const zipHeader = {
						compressedSize: buffer.readUInt32LE(18),
						uncompressedSize: buffer.readUInt32LE(22),
						filenameLength: buffer.readUInt16LE(26),
						extraFieldLength: buffer.readUInt16LE(28)
					};

					zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));
					await tokenizer.ignore(zipHeader.extraFieldLength);

					// Assumes signed `.xpi` from addons.mozilla.org
					if (zipHeader.filename === 'META-INF/mozilla.rsa') {
						return {
							ext: 'xpi',
							mime: 'application/x-xpinstall'
						};
					}

					if (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {
						const type = zipHeader.filename.split('/')[0];
						switch (type) {
							case '_rels':
								break;
							case 'word':
								return {
									ext: 'docx',
									mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
								};
							case 'ppt':
								return {
									ext: 'pptx',
									mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
								};
							case 'xl':
								return {
									ext: 'xlsx',
									mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
								};
							default:
								break;
						}
					}

					if (zipHeader.filename.startsWith('xl/')) {
						return {
							ext: 'xlsx',
							mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
						};
					}

					if (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {
						return {
							ext: '3mf',
							mime: 'model/3mf'
						};
					}

					// The docx, xlsx and pptx file types extend the Office Open XML file format:
					// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
					// We look for:
					// - one entry named '[Content_Types].xml' or '_rels/.rels',
					// - one entry indicating specific type of file.
					// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
					if (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {
						const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));

						switch (mimeType) {
							case 'application/epub+zip':
								return {
									ext: 'epub',
									mime: 'application/epub+zip'
								};
							case 'application/vnd.oasis.opendocument.text':
								return {
									ext: 'odt',
									mime: 'application/vnd.oasis.opendocument.text'
								};
							case 'application/vnd.oasis.opendocument.spreadsheet':
								return {
									ext: 'ods',
									mime: 'application/vnd.oasis.opendocument.spreadsheet'
								};
							case 'application/vnd.oasis.opendocument.presentation':
								return {
									ext: 'odp',
									mime: 'application/vnd.oasis.opendocument.presentation'
								};
							default:
						}
					}

					// Try to find next header manually when current one is corrupted
					if (zipHeader.compressedSize === 0) {
						let nextHeaderIndex = -1;

						while (nextHeaderIndex < 0 && (tokenizer.position < tokenizer.fileInfo.size)) {
							await tokenizer.peekBuffer(buffer, {mayBeLess: true});

							nextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex');
							// Move position to the next header if found, skip the whole buffer otherwise
							await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
						}
					} else {
						await tokenizer.ignore(zipHeader.compressedSize);
					}
				}
			} catch (error) {
				if (!(error instanceof strtok3.EndOfStreamError)) {
					throw error;
				}
			}

			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		if (checkString('OggS')) {
			// This is an OGG container
			await tokenizer.ignore(28);
			const type = Buffer.alloc(8);
			await tokenizer.readBuffer(type);

			// Needs to be before `ogg` check
			if (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
				return {
					ext: 'opus',
					mime: 'audio/opus'
				};
			}

			// If ' theora' in header.
			if (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
				return {
					ext: 'ogv',
					mime: 'video/ogg'
				};
			}

			// If '\x01video' in header.
			if (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
				return {
					ext: 'ogm',
					mime: 'video/ogg'
				};
			}

			// If ' FLAC' in header  https://xiph.org/flac/faq.html
			if (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
				return {
					ext: 'oga',
					mime: 'audio/ogg'
				};
			}

			// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
			if (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
				return {
					ext: 'spx',
					mime: 'audio/ogg'
				};
			}

			// If '\x01vorbis' in header
			if (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
				return {
					ext: 'ogg',
					mime: 'audio/ogg'
				};
			}

			// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
			return {
				ext: 'ogx',
				mime: 'application/ogg'
			};
		}

		if (
			check([0x50, 0x4B]) &&
			(buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) &&
			(buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8)
		) {
			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		//

		// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
		// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
		// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
		// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
		if (
			checkString('ftyp', {offset: 4}) &&
			(buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
		) {
			// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
			// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
			const brandMajor = buffer.toString('binary', 8, 12).replace('\0', ' ').trim();
			switch (brandMajor) {
				case 'avif':
					return {ext: 'avif', mime: 'image/avif'};
				case 'mif1':
					return {ext: 'heic', mime: 'image/heif'};
				case 'msf1':
					return {ext: 'heic', mime: 'image/heif-sequence'};
				case 'heic':
				case 'heix':
					return {ext: 'heic', mime: 'image/heic'};
				case 'hevc':
				case 'hevx':
					return {ext: 'heic', mime: 'image/heic-sequence'};
				case 'qt':
					return {ext: 'mov', mime: 'video/quicktime'};
				case 'M4V':
				case 'M4VH':
				case 'M4VP':
					return {ext: 'm4v', mime: 'video/x-m4v'};
				case 'M4P':
					return {ext: 'm4p', mime: 'video/mp4'};
				case 'M4B':
					return {ext: 'm4b', mime: 'audio/mp4'};
				case 'M4A':
					return {ext: 'm4a', mime: 'audio/x-m4a'};
				case 'F4V':
					return {ext: 'f4v', mime: 'video/mp4'};
				case 'F4P':
					return {ext: 'f4p', mime: 'video/mp4'};
				case 'F4A':
					return {ext: 'f4a', mime: 'audio/mp4'};
				case 'F4B':
					return {ext: 'f4b', mime: 'audio/mp4'};
				case 'crx':
					return {ext: 'cr3', mime: 'image/x-canon-cr3'};
				default:
					if (brandMajor.startsWith('3g')) {
						if (brandMajor.startsWith('3g2')) {
							return {ext: '3g2', mime: 'video/3gpp2'};
						}

						return {ext: '3gp', mime: 'video/3gpp'};
					}

					return {ext: 'mp4', mime: 'video/mp4'};
			}
		}

		if (checkString('MThd')) {
			return {
				ext: 'mid',
				mime: 'audio/midi'
			};
		}

		if (
			checkString('wOFF') &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff',
				mime: 'font/woff'
			};
		}

		if (
			checkString('wOF2') &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff2',
				mime: 'font/woff2'
			};
		}

		if (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {
			return {
				ext: 'pcap',
				mime: 'application/vnd.tcpdump.pcap'
			};
		}

		// Sony DSD Stream File (DSF)
		if (checkString('DSD ')) {
			return {
				ext: 'dsf',
				mime: 'audio/x-dsf' // Non-standard
			};
		}

		if (checkString('LZIP')) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip'
			};
		}

		if (checkString('fLaC')) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac'
			};
		}

		if (check([0x42, 0x50, 0x47, 0xFB])) {
			return {
				ext: 'bpg',
				mime: 'image/bpg'
			};
		}

		if (checkString('wvpk')) {
			return {
				ext: 'wv',
				mime: 'audio/wavpack'
			};
		}

		if (checkString('%PDF')) {
			await tokenizer.ignore(1350);
			const maxBufferSize = 10 * 1024 * 1024;
			const buffer = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
			await tokenizer.readBuffer(buffer, {mayBeLess: true});

			// Check if this is an Adobe Illustrator file
			if (buffer.includes(Buffer.from('AIPrivateData'))) {
				return {
					ext: 'ai',
					mime: 'application/postscript'
				};
			}

			// Assume this is just a normal PDF
			return {
				ext: 'pdf',
				mime: 'application/pdf'
			};
		}

		if (check([0x00, 0x61, 0x73, 0x6D])) {
			return {
				ext: 'wasm',
				mime: 'application/wasm'
			};
		}

		// TIFF, little-endian type
		if (check([0x49, 0x49, 0x2A, 0x0])) {
			if (checkString('CR', {offset: 8})) {
				return {
					ext: 'cr2',
					mime: 'image/x-canon-cr2'
				};
			}

			if (check([0x1C, 0x00, 0xFE, 0x00], {offset: 8}) || check([0x1F, 0x00, 0x0B, 0x00], {offset: 8})) {
				return {
					ext: 'nef',
					mime: 'image/x-nikon-nef'
				};
			}

			if (
				check([0x08, 0x00, 0x00, 0x00], {offset: 4}) &&
				(check([0x2D, 0x00, 0xFE, 0x00], {offset: 8}) ||
					check([0x27, 0x00, 0xFE, 0x00], {offset: 8}))
			) {
				return {
					ext: 'dng',
					mime: 'image/x-adobe-dng'
				};
			}

			buffer = Buffer.alloc(24);
			await tokenizer.peekBuffer(buffer);
			if (
				(check([0x10, 0xFB, 0x86, 0x01], {offset: 4}) || check([0x08, 0x00, 0x00, 0x00], {offset: 4})) &&
				// This pattern differentiates ARW from other TIFF-ish file types:
				check([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {offset: 9})
			) {
				return {
					ext: 'arw',
					mime: 'image/x-sony-arw'
				};
			}

			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		// TIFF, big-endian type
		if (check([0x4D, 0x4D, 0x0, 0x2A])) {
			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		if (checkString('MAC ')) {
			return {
				ext: 'ape',
				mime: 'audio/ape'
			};
		}

		// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
		if (check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML
			async function readField() {
				const msb = await tokenizer.peekNumber(Token.UINT8);
				let mask = 0x80;
				let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

				while ((msb & mask) === 0 && mask !== 0) {
					++ic;
					mask >>= 1;
				}

				const id = Buffer.alloc(ic + 1);
				await tokenizer.readBuffer(id);
				return id;
			}

			async function readElement() {
				const id = await readField();
				const lenField = await readField();
				lenField[0] ^= 0x80 >> (lenField.length - 1);
				const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer
				return {
					id: id.readUIntBE(0, id.length),
					len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
				};
			}

			async function readChildren(level, children) {
				while (children > 0) {
					const e = await readElement();
					if (e.id === 0x4282) {
						return tokenizer.readToken(new Token.StringType(e.len, 'utf-8')); // Return DocType
					}

					await tokenizer.ignore(e.len); // ignore payload
					--children;
				}
			}

			const re = await readElement();
			const docType = await readChildren(1, re.len);

			switch (docType) {
				case 'webm':
					return {
						ext: 'webm',
						mime: 'video/webm'
					};

				case 'matroska':
					return {
						ext: 'mkv',
						mime: 'video/x-matroska'
					};

				default:
					return;
			}
		}

		// RIFF file format which might be AVI, WAV, QCP, etc
		if (check([0x52, 0x49, 0x46, 0x46])) {
			if (check([0x41, 0x56, 0x49], {offset: 8})) {
				return {
					ext: 'avi',
					mime: 'video/vnd.avi'
				};
			}

			if (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
				return {
					ext: 'wav',
					mime: 'audio/vnd.wave'
				};
			}

			// QLCM, QCP file
			if (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
				return {
					ext: 'qcp',
					mime: 'audio/qcelp'
				};
			}
		}

		if (checkString('SQLi')) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3'
			};
		}

		if (check([0x4E, 0x45, 0x53, 0x1A])) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom'
			};
		}

		if (checkString('Cr24')) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension'
			};
		}

		if (
			checkString('MSCF') ||
			checkString('ISc(')
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed'
			};
		}

		if (check([0xED, 0xAB, 0xEE, 0xDB])) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm'
			};
		}

		if (check([0xC5, 0xD0, 0xD3, 0xC6])) {
			return {
				ext: 'eps',
				mime: 'application/eps'
			};
		}

		if (check([0x28, 0xB5, 0x2F, 0xFD])) {
			return {
				ext: 'zst',
				mime: 'application/zstd'
			};
		}

		// -- 5-byte signatures --

		if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
			return {
				ext: 'otf',
				mime: 'font/otf'
			};
		}

		if (checkString('#!AMR')) {
			return {
				ext: 'amr',
				mime: 'audio/amr'
			};
		}

		if (checkString('{\\rtf')) {
			return {
				ext: 'rtf',
				mime: 'application/rtf'
			};
		}

		if (check([0x46, 0x4C, 0x56, 0x01])) {
			return {
				ext: 'flv',
				mime: 'video/x-flv'
			};
		}

		if (checkString('IMPM')) {
			return {
				ext: 'it',
				mime: 'audio/x-it'
			};
		}

		if (
			checkString('-lh0-', {offset: 2}) ||
			checkString('-lh1-', {offset: 2}) ||
			checkString('-lh2-', {offset: 2}) ||
			checkString('-lh3-', {offset: 2}) ||
			checkString('-lh4-', {offset: 2}) ||
			checkString('-lh5-', {offset: 2}) ||
			checkString('-lh6-', {offset: 2}) ||
			checkString('-lh7-', {offset: 2}) ||
			checkString('-lzs-', {offset: 2}) ||
			checkString('-lz4-', {offset: 2}) ||
			checkString('-lz5-', {offset: 2}) ||
			checkString('-lhd-', {offset: 2})
		) {
			return {
				ext: 'lzh',
				mime: 'application/x-lzh-compressed'
			};
		}

		// MPEG program stream (PS or MPEG-PS)
		if (check([0x00, 0x00, 0x01, 0xBA])) {
			//  MPEG-PS, MPEG-1 Part 1
			if (check([0x21], {offset: 4, mask: [0xF1]})) {
				return {
					ext: 'mpg', // May also be .ps, .mpeg
					mime: 'video/MP1S'
				};
			}

			// MPEG-PS, MPEG-2 Part 1
			if (check([0x44], {offset: 4, mask: [0xC4]})) {
				return {
					ext: 'mpg', // May also be .mpg, .m2p, .vob or .sub
					mime: 'video/MP2P'
				};
			}
		}

		if (checkString('ITSF')) {
			return {
				ext: 'chm',
				mime: 'application/vnd.ms-htmlhelp'
			};
		}

		// -- 6-byte signatures --

		if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
			return {
				ext: 'xz',
				mime: 'application/x-xz'
			};
		}

		if (checkString('<?xml ')) {
			return {
				ext: 'xml',
				mime: 'application/xml'
			};
		}

		if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed'
			};
		}

		if (
			check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&
			(buffer[6] === 0x0 || buffer[6] === 0x1)
		) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed'
			};
		}

		if (checkString('solid ')) {
			return {
				ext: 'stl',
				mime: 'model/stl'
			};
		}

		// -- 7-byte signatures --

		if (checkString('BLENDER')) {
			return {
				ext: 'blend',
				mime: 'application/x-blender'
			};
		}

		if (checkString('!<arch>')) {
			await tokenizer.ignore(8);
			const str = await tokenizer.readToken(new Token.StringType(13, 'ascii'));
			if (str === 'debian-binary') {
				return {
					ext: 'deb',
					mime: 'application/x-deb'
				};
			}

			return {
				ext: 'ar',
				mime: 'application/x-unix-archive'
			};
		}

		// -- 8-byte signatures --

		if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
			// APNG format (https://wiki.mozilla.org/APNG_Specification)
			// 1. Find the first IDAT (image data) chunk (49 44 41 54)
			// 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)

			// Offset calculated as follows:
			// - 8 bytes: PNG signature
			// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk

			await tokenizer.ignore(8); // ignore PNG signature

			async function readChunkHeader() {
				return {
					length: await tokenizer.readToken(Token.INT32_BE),
					type: await tokenizer.readToken(new Token.StringType(4, 'binary'))
				};
			}

			do {
				const chunk = await readChunkHeader();
				if (chunk.length < 0) {
					return; // Invalid chunk length
				}

				switch (chunk.type) {
					case 'IDAT':
						return {
							ext: 'png',
							mime: 'image/png'
						};
					case 'acTL':
						return {
							ext: 'apng',
							mime: 'image/apng'
						};
					default:
						await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
				}
			} while (tokenizer.position + 8 < tokenizer.fileInfo.size);

			return {
				ext: 'png',
				mime: 'image/png'
			};
		}

		if (check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
			return {
				ext: 'arrow',
				mime: 'application/x-apache-arrow'
			};
		}

		if (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
			return {
				ext: 'glb',
				mime: 'model/gltf-binary'
			};
		}

		// `mov` format variants
		if (
			check([0x66, 0x72, 0x65, 0x65], {offset: 4}) || // `free`
			check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // `mdat` MJPEG
			check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) || // `moov`
			check([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`
		) {
			return {
				ext: 'mov',
				mime: 'video/quicktime'
			};
		}

		// -- 9-byte signatures --

		if (check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
			return {
				ext: 'orf',
				mime: 'image/x-olympus-orf'
			};
		}

		if (checkString('gimp xcf ')) {
			return {
				ext: 'xcf',
				mime: 'image/x-xcf'
			};
		}

		// -- 12-byte signatures --

		if (check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
			return {
				ext: 'rw2',
				mime: 'image/x-panasonic-rw2'
			};
		}

		// ASF_Header_Object first 80 bytes
		if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
			async function readHeader() {
				const guid = Buffer.alloc(16);
				await tokenizer.readBuffer(guid);
				return {
					id: guid,
					size: Number(await tokenizer.readToken(Token.UINT64_LE))
				};
			}

			await tokenizer.ignore(30);
			// Search for header should be in first 1KB of file.
			while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
				const header = await readHeader();
				let payload = header.size - 24;
				if (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
					// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
					const typeId = Buffer.alloc(16);
					payload -= await tokenizer.readBuffer(typeId);

					if (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found audio:
						return {
							ext: 'asf',
							mime: 'audio/x-ms-asf'
						};
					}

					if (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found video:
						return {
							ext: 'asf',
							mime: 'video/x-ms-asf'
						};
					}

					break;
				}

				await tokenizer.ignore(payload);
			}

			// Default to ASF generic extension
			return {
				ext: 'asf',
				mime: 'application/vnd.ms-asf'
			};
		}

		if (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
			return {
				ext: 'ktx',
				mime: 'image/ktx'
			};
		}

		if ((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {
			return {
				ext: 'mie',
				mime: 'application/x-mie'
			};
		}

		if (check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {
			return {
				ext: 'shp',
				mime: 'application/x-esri-shape'
			};
		}

		if (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
			// JPEG-2000 family

			await tokenizer.ignore(20);
			const type = await tokenizer.readToken(new Token.StringType(4, 'ascii'));
			switch (type) {
				case 'jp2 ':
					return {
						ext: 'jp2',
						mime: 'image/jp2'
					};
				case 'jpx ':
					return {
						ext: 'jpx',
						mime: 'image/jpx'
					};
				case 'jpm ':
					return {
						ext: 'jpm',
						mime: 'image/jpm'
					};
				case 'mjp2':
					return {
						ext: 'mj2',
						mime: 'image/mj2'
					};
				default:
					return;
			}
		}

		if (
			check([0xFF, 0x0A]) ||
			check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])
		) {
			return {
				ext: 'jxl',
				mime: 'image/jxl'
			};
		}

		// -- Unsafe signatures --

		if (
			check([0x0, 0x0, 0x1, 0xBA]) ||
			check([0x0, 0x0, 0x1, 0xB3])
		) {
			return {
				ext: 'mpg',
				mime: 'video/mpeg'
			};
		}

		if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
			return {
				ext: 'ttf',
				mime: 'font/ttf'
			};
		}

		if (check([0x00, 0x00, 0x01, 0x00])) {
			return {
				ext: 'ico',
				mime: 'image/x-icon'
			};
		}

		if (check([0x00, 0x00, 0x02, 0x00])) {
			return {
				ext: 'cur',
				mime: 'image/x-icon'
			};
		}

		if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
			// Detected Microsoft Compound File Binary File (MS-CFB) Format.
			return {
				ext: 'cfb',
				mime: 'application/x-cfb'
			};
		}

		// Increase sample size from 12 to 256.
		await tokenizer.peekBuffer(buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});

		// -- 15-byte signatures --

		if (checkString('BEGIN:')) {
			if (checkString('VCARD', {offset: 6})) {
				return {
					ext: 'vcf',
					mime: 'text/vcard'
				};
			}

			if (checkString('VCALENDAR', {offset: 6})) {
				return {
					ext: 'ics',
					mime: 'text/calendar'
				};
			}
		}

		// `raf` is here just to keep all the raw image detectors together.
		if (checkString('FUJIFILMCCD-RAW')) {
			return {
				ext: 'raf',
				mime: 'image/x-fujifilm-raf'
			};
		}

		if (checkString('Extended Module:')) {
			return {
				ext: 'xm',
				mime: 'audio/x-xm'
			};
		}

		if (checkString('Creative Voice File')) {
			return {
				ext: 'voc',
				mime: 'audio/x-voc'
			};
		}

		if (check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16) { // Rough & quick check Pickle/ASAR
			const jsonSize = buffer.readUInt32LE(12);
			if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
				try {
					const header = buffer.slice(16, jsonSize + 16).toString();
					const json = JSON.parse(header);
					// Check if Pickle is ASAR
					if (json.files) { // Final check, assuring Pickle/ASAR format
						return {
							ext: 'asar',
							mime: 'application/x-asar'
						};
					}
				} catch (_) {
				}
			}
		}

		if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
			return {
				ext: 'mxf',
				mime: 'application/mxf'
			};
		}

		if (checkString('SCRM', {offset: 44})) {
			return {
				ext: 's3m',
				mime: 'audio/x-s3m'
			};
		}

		if (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {
			return {
				ext: 'mts',
				mime: 'video/mp2t'
			};
		}

		if (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
			return {
				ext: 'mobi',
				mime: 'application/x-mobipocket-ebook'
			};
		}

		if (check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {
			return {
				ext: 'dcm',
				mime: 'application/dicom'
			};
		}

		if (check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
			return {
				ext: 'lnk',
				mime: 'application/x.ms.shortcut' // Invented by us
			};
		}

		if (check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
			return {
				ext: 'alias',
				mime: 'application/x.apple.alias' // Invented by us
			};
		}

		if (
			check([0x4C, 0x50], {offset: 34}) &&
			(
				check([0x00, 0x00, 0x01], {offset: 8}) ||
				check([0x01, 0x00, 0x02], {offset: 8}) ||
				check([0x02, 0x00, 0x02], {offset: 8})
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/vnd.ms-fontobject'
			};
		}

		if (check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
			return {
				ext: 'indd',
				mime: 'application/x-indesign'
			};
		}

		// Increase sample size from 256 to 512
		await tokenizer.peekBuffer(buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});

		// Requires a buffer size of 512 bytes
		if (tarHeaderChecksumMatches(buffer)) {
			return {
				ext: 'tar',
				mime: 'application/x-tar'
			};
		}

		if (check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {
			return {
				ext: 'skp',
				mime: 'application/vnd.sketchup.skp'
			};
		}

		if (checkString('-----BEGIN PGP MESSAGE-----')) {
			return {
				ext: 'pgp',
				mime: 'application/pgp-encrypted'
			};
		}

		// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
		if (buffer.length >= 2 && check([0xFF, 0xE0], {offset: 0, mask: [0xFF, 0xE0]})) {
			if (check([0x10], {offset: 1, mask: [0x16]})) {
				// Check for (ADTS) MPEG-2
				if (check([0x08], {offset: 1, mask: [0x08]})) {
					return {
						ext: 'aac',
						mime: 'audio/aac'
					};
				}

				// Must be (ADTS) MPEG-4
				return {
					ext: 'aac',
					mime: 'audio/aac'
				};
			}

			// MPEG 1 or 2 Layer 3 header
			// Check for MPEG layer 3
			if (check([0x02], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp3',
					mime: 'audio/mpeg'
				};
			}

			// Check for MPEG layer 2
			if (check([0x04], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp2',
					mime: 'audio/mpeg'
				};
			}

			// Check for MPEG layer 1
			if (check([0x06], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp1',
					mime: 'audio/mpeg'
				};
			}
		}
	}

	const stream = readableStream => new Promise((resolve, reject) => {
		// Using `eval` to work around issues when bundling with Webpack
		const stream = eval('require')('stream'); // eslint-disable-line no-eval

		readableStream.on('error', reject);
		readableStream.once('readable', async () => {
			// Set up output stream
			const pass = new stream.PassThrough();
			let outputStream;
			if (stream.pipeline) {
				outputStream = stream.pipeline(readableStream, pass, () => {
				});
			} else {
				outputStream = readableStream.pipe(pass);
			}

			// Read the input stream and detect the filetype
			const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
			try {
				const fileType = await fromBuffer(chunk);
				pass.fileType = fileType;
			} catch (error) {
				reject(error);
			}

			resolve(outputStream);
		});
	});

	const fileType = {
		fromStream,
		fromTokenizer,
		fromBuffer,
		stream
	};

	Object.defineProperty(fileType, 'extensions', {
		get() {
			return new Set(supported.extensions);
		}
	});

	Object.defineProperty(fileType, 'mimeTypes', {
		get() {
			return new Set(supported.mimeTypes);
		}
	});

	core = fileType;
	return core;
}

var coreExports = requireCore();
const fileType = /*@__PURE__*/getDefaultExportFromCjs(coreExports);

/**
 * @param { Promise } promise
 * @param { Object= } errorExt - Additional Information you can pass to the err object
 * @return { Promise }
 */
function to(promise, errorExt) {
    return promise
        .then(function (data) { return [null, data]; })
        .catch(function (err) {
        return [err, undefined];
    });
}

const readFile = promises.readFile;
const writeFile = promises.writeFile;

var Mime_1;
var hasRequiredMime;

function requireMime () {
	if (hasRequiredMime) return Mime_1;
	hasRequiredMime = 1;

	/**
	 * @param typeMap [Object] Map of MIME type -> Array[extensions]
	 * @param ...
	 */
	function Mime() {
	  this._types = Object.create(null);
	  this._extensions = Object.create(null);

	  for (let i = 0; i < arguments.length; i++) {
	    this.define(arguments[i]);
	  }

	  this.define = this.define.bind(this);
	  this.getType = this.getType.bind(this);
	  this.getExtension = this.getExtension.bind(this);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * If a type declares an extension that has already been defined, an error will
	 * be thrown.  To suppress this error and force the extension to be associated
	 * with the new type, pass `force`=true.  Alternatively, you may prefix the
	 * extension with "*" to map the type to extension, without mapping the
	 * extension to the type.
	 *
	 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
	 *
	 *
	 * @param map (Object) type definitions
	 * @param force (Boolean) if true, force overriding of existing definitions
	 */
	Mime.prototype.define = function(typeMap, force) {
	  for (let type in typeMap) {
	    let extensions = typeMap[type].map(function(t) {
	      return t.toLowerCase();
	    });
	    type = type.toLowerCase();

	    for (let i = 0; i < extensions.length; i++) {
	      const ext = extensions[i];

	      // '*' prefix = not the preferred type for this extension.  So fixup the
	      // extension, and skip it.
	      if (ext[0] === '*') {
	        continue;
	      }

	      if (!force && (ext in this._types)) {
	        throw new Error(
	          'Attempt to change mapping for "' + ext +
	          '" extension from "' + this._types[ext] + '" to "' + type +
	          '". Pass `force=true` to allow this, otherwise remove "' + ext +
	          '" from the list of extensions for "' + type + '".'
	        );
	      }

	      this._types[ext] = type;
	    }

	    // Use first extension as default
	    if (force || !this._extensions[type]) {
	      const ext = extensions[0];
	      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
	    }
	  }
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.getType = function(path) {
	  path = String(path);
	  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
	  let ext = last.replace(/^.*\./, '').toLowerCase();

	  let hasPath = last.length < path.length;
	  let hasDot = ext.length < last.length - 1;

	  return (hasDot || !hasPath) && this._types[ext] || null;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.getExtension = function(type) {
	  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
	  return type && this._extensions[type.toLowerCase()] || null;
	};

	Mime_1 = Mime;
	return Mime_1;
}

var standard;
var hasRequiredStandard;

function requireStandard () {
	if (hasRequiredStandard) return standard;
	hasRequiredStandard = 1;
	standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};
	return standard;
}

var lite;
var hasRequiredLite;

function requireLite () {
	if (hasRequiredLite) return lite;
	hasRequiredLite = 1;

	let Mime = requireMime();
	lite = new Mime(requireStandard());
	return lite;
}

var liteExports = requireLite();
const mime = /*@__PURE__*/getDefaultExportFromCjs(liteExports);

/* Horizontal align modes for cover, contain, bit masks */
var HorizontalAlign;
(function (HorizontalAlign) {
    HorizontalAlign[HorizontalAlign["LEFT"] = 1] = "LEFT";
    HorizontalAlign[HorizontalAlign["CENTER"] = 2] = "CENTER";
    HorizontalAlign[HorizontalAlign["RIGHT"] = 4] = "RIGHT";
})(HorizontalAlign || (HorizontalAlign = {}));
/* Vertical align modes for cover, contain, bit masks */
var VerticalAlign;
(function (VerticalAlign) {
    VerticalAlign[VerticalAlign["TOP"] = 8] = "TOP";
    VerticalAlign[VerticalAlign["MIDDLE"] = 16] = "MIDDLE";
    VerticalAlign[VerticalAlign["BOTTOM"] = 32] = "BOTTOM";
})(VerticalAlign || (VerticalAlign = {}));
/**
 * How to blend two images together
 */
var BlendMode;
(function (BlendMode) {
    /**
     * Composite the source image over the destination image.
     * This is the default value. It represents the most intuitive case, where shapes are painted on top of what is below, with transparent areas showing the destination layer.
     */
    BlendMode["SRC_OVER"] = "srcOver";
    /** Composite the source image under the destination image. */
    BlendMode["DST_OVER"] = "dstOver";
    /**
     * Multiply the color components of the source and destination images.
     * This can only result in the same or darker colors (multiplying by white, 1.0, results in no change; multiplying by black, 0.0, results in black).
     * When compositing two opaque images, this has similar effect to overlapping two transparencies on a projector.
     *
     * This mode is useful for coloring shadows.
     */
    BlendMode["MULTIPLY"] = "multiply";
    /**
     * The Add mode adds the color information of the base layers and the blending layer.
     * In digital terms, adding color increases the brightness.
     */
    BlendMode["ADD"] = "add";
    /**
     * Multiply the inverse of the components of the source and destination images, and inverse the result.
     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.
     * This is essentially the same as modulate blend mode, but with the values of the colors inverted before the multiplication and the result being inverted back before rendering.
     * This can only result in the same or lighter colors (multiplying by black, 1.0, results in no change; multiplying by white, 0.0, results in white). Similarly, in the alpha channel, it can only result in more opaque colors.
     * This has similar effect to two projectors displaying their images on the same screen simultaneously.
     */
    BlendMode["SCREEN"] = "screen";
    /**
     * Multiply the components of the source and destination images after adjusting them to favor the destination.
     * Specifically, if the destination value is smaller, this multiplies it with the source value, whereas is the source value is smaller, it multiplies the inverse of the source value with the inverse of the destination value, then inverts the result.
     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.
     *
     * The Overlay mode behaves like Screen mode in bright areas, and like Multiply mode in darker areas.
     * With this mode, the bright areas will look brighter and the dark areas will look darker.
     */
    BlendMode["OVERLAY"] = "overlay";
    /**
     * Composite the source and destination image by choosing the lowest value from each color channel.
     * The opacity of the output image is computed in the same way as for srcOver.
     */
    BlendMode["DARKEN"] = "darken";
    /**
     * Composite the source and destination image by choosing the highest value from each color channel.
     * The opacity of the output image is computed in the same way as for srcOver.
     */
    BlendMode["LIGHTEN"] = "lighten";
    /**
     * Multiply the components of the source and destination images after adjusting them to favor the source.
     * Specifically, if the source value is smaller, this multiplies it with the destination value, whereas is the destination value is smaller, it multiplies the inverse of the destination value with the inverse of the source value, then inverts the result.
     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.
     *
     * The effect of the Hard light mode depends on the density of the superimposed color. Using bright colors on the blending layer will create a brighter effect like the Screen modes, while dark colors will create darker colors like the Multiply mode.
     */
    BlendMode["HARD_LIGHT"] = "hardLight";
    /**
     * Subtract the smaller value from the bigger value for each channel.
     * Compositing black has no effect; compositing white inverts the colors of the other image.
     * The opacity of the output image is computed in the same way as for srcOver.
     * The effect is similar to exclusion but harsher.
     */
    BlendMode["DIFFERENCE"] = "difference";
    /**
     * Subtract double the product of the two images from the sum of the two images.
     * Compositing black has no effect; compositing white inverts the colors of the other image.
     * The opacity of the output image is computed in the same way as for srcOver.
     * The effect is similar to difference but softer.
     */
    BlendMode["EXCLUSION"] = "exclusion";
})(BlendMode || (BlendMode = {}));

function srcOver(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
    const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
    const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
    return { r, g, b, a };
}
function dstOver(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
    const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
    const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
    return { r, g, b, a };
}
function multiply(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return { r, g, b, a };
}
function add(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra + dra) / a;
    const g = (sga + dga) / a;
    const b = (sba + dba) / a;
    return { r, g, b, a };
}
function screen(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra * dst.a +
        dra * src.a -
        sra * dra +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (sga * dst.a +
        dga * src.a -
        sga * dga +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (sba * dst.a +
        dba * src.a -
        sba * dba +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
function overlay(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (2 * dra <= dst.a
        ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)
        : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /
        a;
    const g = (2 * dga <= dst.a
        ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)
        : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /
        a;
    const b = (2 * dba <= dst.a
        ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)
        : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /
        a;
    return { r, g, b, a };
}
function darken(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (Math.min(sra * dst.a, dra * src.a) +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (Math.min(sga * dst.a, dga * src.a) +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (Math.min(sba * dst.a, dba * src.a) +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
function lighten(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (Math.max(sra * dst.a, dra * src.a) +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (Math.max(sga * dst.a, dga * src.a) +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (Math.max(sba * dst.a, dba * src.a) +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
function hardLight(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (2 * sra <= src.a
        ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)
        : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /
        a;
    const g = (2 * sga <= src.a
        ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)
        : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /
        a;
    const b = (2 * sba <= src.a
        ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)
        : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /
        a;
    return { r, g, b, a };
}
function difference(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
    const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
    const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
    return { r, g, b, a };
}
function exclusion(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra * dst.a +
        dra * src.a -
        2 * sra * dra +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (sga * dst.a +
        dga * src.a -
        2 * sga * dga +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (sba * dst.a +
        dba * src.a -
        2 * sba * dba +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
const names = [
    srcOver,
    dstOver,
    multiply,
    add,
    screen,
    overlay,
    darken,
    lighten,
    hardLight,
    difference,
    exclusion,
];

const compositeModes = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  add,
  darken,
  difference,
  dstOver,
  exclusion,
  hardLight,
  lighten,
  multiply,
  names,
  overlay,
  screen,
  srcOver
}, Symbol.toStringTag, { value: 'Module' }));

function composite(baseImage, src, x = 0, y = 0, options = {}) {
    if (!(src instanceof baseImage.constructor)) {
        throw new Error("The source must be a Jimp image");
    }
    if (typeof x !== "number" || typeof y !== "number") {
        throw new Error("x and y must be numbers");
    }
    const { mode = BlendMode.SRC_OVER } = options;
    let { opacitySource = 1.0, opacityDest = 1.0 } = options;
    if (typeof opacitySource !== "number" ||
        opacitySource < 0 ||
        opacitySource > 1) {
        opacitySource = 1.0;
    }
    if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
        opacityDest = 1.0;
    }
    const blendmode = compositeModes[mode];
    // round input
    x = Math.round(x);
    y = Math.round(y);
    if (opacityDest !== 1.0) {
        baseImage.scan((_, __, idx) => {
            const v = baseImage.bitmap.data[idx + 3] * opacityDest;
            baseImage.bitmap.data[idx + 3] = v;
        });
    }
    src.scan((sx, sy, idx) => {
        const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, Edge.CROP);
        if (dstIdx === -1) {
            // Skip target pixels outside of dst
            return;
        }
        const blended = blendmode({
            r: src.bitmap.data[idx + 0] / 255,
            g: src.bitmap.data[idx + 1] / 255,
            b: src.bitmap.data[idx + 2] / 255,
            a: src.bitmap.data[idx + 3] / 255,
        }, {
            r: baseImage.bitmap.data[dstIdx + 0] / 255,
            g: baseImage.bitmap.data[dstIdx + 1] / 255,
            b: baseImage.bitmap.data[dstIdx + 2] / 255,
            a: baseImage.bitmap.data[dstIdx + 3] / 255,
        }, opacitySource);
        baseImage.bitmap.data[dstIdx + 0] = limit255(blended.r * 255);
        baseImage.bitmap.data[dstIdx + 1] = limit255(blended.g * 255);
        baseImage.bitmap.data[dstIdx + 2] = limit255(blended.b * 255);
        baseImage.bitmap.data[dstIdx + 3] = limit255(blended.a * 255);
    });
    return baseImage;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var jpeg;
var hasRequiredJpeg;

function requireJpeg () {
	if (hasRequiredJpeg) return jpeg;
	hasRequiredJpeg = 1;
	jpeg = {
		parseSections: function(stream, iterator) {
			var len, markerType;
			stream.setBigEndian(true);
			//stop reading the stream at the SOS (Start of Stream) marker,
			//because its length is not stored in the header so we can't
			//know where to jump to. The only marker after that is just EOI (End Of Image) anyway
			while(stream.remainingLength() > 0 && markerType !== 0xDA) {
				if(stream.nextUInt8() !== 0xFF) {
					throw new Error('Invalid JPEG section offset');
				}
				markerType = stream.nextUInt8();
				//don't read size from markers that have no datas
				if((markerType >= 0xD0 && markerType <= 0xD9) || markerType === 0xDA) {
					len = 0;
				} else {
					len = stream.nextUInt16() - 2;
				}
				iterator(markerType, stream.branch(0, len));
				stream.skip(len);
			}
		},
		//stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
		getSizeFromSOFSection: function(stream) {
			stream.skip(1);
			return {
				height: stream.nextUInt16(),
				width: stream.nextUInt16()
			};
		},
		getSectionName: function(markerType) {
			var name, index;
			switch(markerType) {
				case 0xD8: name = 'SOI'; break;
				case 0xC4: name = 'DHT'; break;
				case 0xDB: name = 'DQT'; break;
				case 0xDD: name = 'DRI'; break;
				case 0xDA: name = 'SOS'; break;
				case 0xFE: name = 'COM'; break;
				case 0xD9: name = 'EOI'; break;
				default:
					if(markerType >= 0xE0 && markerType <= 0xEF) {
						name = 'APP';
						index = markerType - 0xE0;
					}
					else if(markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {
						name = 'SOF';
						index = markerType - 0xC0;
					}
					else if(markerType >= 0xD0 && markerType <= 0xD7) {
						name = 'RST';
						index = markerType - 0xD0;
					}
					break;
			}
			var nameStruct = {
				name: name
			};
			if(typeof index === 'number') {
				nameStruct.index = index;
			}
			return nameStruct;
		}
	};
	return jpeg;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var exif;
var hasRequiredExif;

function requireExif () {
	if (hasRequiredExif) return exif;
	hasRequiredExif = 1;
	function readExifValue(format, stream) {
		switch(format) {
			case 1: return stream.nextUInt8();
			case 3: return stream.nextUInt16();
			case 4: return stream.nextUInt32();
			case 5: return [stream.nextUInt32(), stream.nextUInt32()];
			case 6: return stream.nextInt8();
			case 8: return stream.nextUInt16();
			case 9: return stream.nextUInt32();
			case 10: return [stream.nextInt32(), stream.nextInt32()];
			case 11: return stream.nextFloat();
			case 12: return stream.nextDouble();
			default: throw new Error('Invalid format while decoding: ' + format);
		}
	}

	function getBytesPerComponent(format) {
		switch(format) {
			case 1:
			case 2:
			case 6:
			case 7:
				return 1;
			case 3:
			case 8:
				return 2;
			case 4:
			case 9:
			case 11:
				return 4;
			case 5:
			case 10:
			case 12:
				return 8;
			default:
				return 0;
		}
	}

	function readExifTag(tiffMarker, stream) {
		var tagType = stream.nextUInt16(),
			format = stream.nextUInt16(),
			bytesPerComponent = getBytesPerComponent(format),
			components = stream.nextUInt32(),
			valueBytes = bytesPerComponent * components,
			values,
			c;

		/* if the value is bigger then 4 bytes, the value is in the data section of the IFD
		and the value present in the tag is the offset starting from the tiff header. So we replace the stream
		with a stream that is located at the given offset in the data section. s*/
		if(valueBytes > 4) {
			stream = tiffMarker.openWithOffset(stream.nextUInt32());
		}
		//we don't want to read strings as arrays
		if(format === 2) {
			values = stream.nextString(components);
			//cut off \0 characters
			var lastNull = values.indexOf('\0');
			if(lastNull !== -1) {
				values = values.substr(0, lastNull);
			}
		}
		else if(format === 7) {
			values = stream.nextBuffer(components);
		}
		else if(format !== 0) {
			values = [];
			for(c = 0; c < components; ++c) {
				values.push(readExifValue(format, stream));
			}
		}
		//since our stream is a stateful object, we need to skip remaining bytes
		//so our offset stays correct
		if(valueBytes < 4) {
			stream.skip(4 - valueBytes);
		}

		return [tagType, values, format];
	}

	function readIFDSection(tiffMarker, stream, iterator) {
		var numberOfEntries = stream.nextUInt16(), tag, i;
		for(i = 0; i < numberOfEntries; ++i) {
			tag = readExifTag(tiffMarker, stream);
			iterator(tag[0], tag[1], tag[2]);
		}
	}

	function readHeader(stream) {
		var exifHeader = stream.nextString(6);
		if(exifHeader !== 'Exif\0\0') {
			throw new Error('Invalid EXIF header');
		}

		var tiffMarker = stream.mark();
		var tiffHeader = stream.nextUInt16();
		if(tiffHeader === 0x4949) {
			stream.setBigEndian(false);
		} else if(tiffHeader === 0x4D4D) {
			stream.setBigEndian(true);
		} else {
			throw new Error('Invalid TIFF header');
		}
		if(stream.nextUInt16() !== 0x002A) {
			throw new Error('Invalid TIFF data');
		}
		return tiffMarker;
	}

	exif = {
		IFD0: 1,
		IFD1: 2,
		GPSIFD: 3,
		SubIFD: 4,
		InteropIFD: 5,
		parseTags: function(stream, iterator) {
			var tiffMarker;
			try {
				tiffMarker = readHeader(stream);
			} catch(e) {
				return false;	//ignore APP1 sections with invalid headers
			}
			var subIfdOffset, gpsOffset, interopOffset;
			var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()),
				IFD0 = this.IFD0;
			readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {
				switch(tagType) {
					case 0x8825: gpsOffset = value[0]; break;
					case 0x8769: subIfdOffset = value[0]; break;
					default: iterator(IFD0, tagType, value, format); break;
				}
			});
			var ifd1Offset = ifd0Stream.nextUInt32();
			if(ifd1Offset !== 0) {
				var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
				readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
			}

			if(gpsOffset) {
				var gpsStream = tiffMarker.openWithOffset(gpsOffset);
				readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
			}

			if(subIfdOffset) {
				var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
				readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {
					if(tagType === 0xA005) {
						interopOffset = value[0];
					} else {
						iterator(InteropIFD, tagType, value, format);
					}
				});
			}

			if(interopOffset) {
				var interopStream = tiffMarker.openWithOffset(interopOffset);
				readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
			}
			return true;
		}
	};
	return exif;
}

var date;
var hasRequiredDate;

function requireDate () {
	if (hasRequiredDate) return date;
	hasRequiredDate = 1;
	function parseNumber(s) {
		return parseInt(s, 10);
	}

	//in seconds
	var hours = 3600;
	var minutes = 60;

	//take date (year, month, day) and time (hour, minutes, seconds) digits in UTC
	//and return a timestamp in seconds
	function parseDateTimeParts(dateParts, timeParts) {
		dateParts = dateParts.map(parseNumber);
		timeParts = timeParts.map(parseNumber);
		var year = dateParts[0];
		var month = dateParts[1] - 1;
		var day = dateParts[2];
		var hours = timeParts[0];
		var minutes = timeParts[1];
		var seconds = timeParts[2];
		var date = Date.UTC(year, month, day, hours, minutes, seconds, 0);
		var timestamp = date / 1000;
		return timestamp;
	}

	//parse date with "2004-09-04T23:39:06-08:00" format,
	//one of the formats supported by ISO 8601, and
	//convert to utc timestamp in seconds
	function parseDateWithTimezoneFormat(dateTimeStr) {

		var dateParts = dateTimeStr.substr(0, 10).split('-');
		var timeParts = dateTimeStr.substr(11, 8).split(':');
		var timezoneStr = dateTimeStr.substr(19, 6);
		var timezoneParts = timezoneStr.split(':').map(parseNumber);
		var timezoneOffset = (timezoneParts[0] * hours) +
			(timezoneParts[1] * minutes);

		var timestamp = parseDateTimeParts(dateParts, timeParts);
		//minus because the timezoneOffset describes
		//how much the described time is ahead of UTC
		timestamp -= timezoneOffset;

		if(typeof timestamp === 'number' && !isNaN(timestamp)) {
			return timestamp;
		}
	}

	//parse date with "YYYY:MM:DD hh:mm:ss" format, convert to utc timestamp in seconds
	function parseDateWithSpecFormat(dateTimeStr) {
		var parts = dateTimeStr.split(' '),
			dateParts = parts[0].split(':'),
			timeParts = parts[1].split(':');

		var timestamp = parseDateTimeParts(dateParts, timeParts);

		if(typeof timestamp === 'number' && !isNaN(timestamp)) {
			return timestamp;
		}
	}

	function parseExifDate(dateTimeStr) {
		//some easy checks to determine two common date formats

		//is the date in the standard "YYYY:MM:DD hh:mm:ss" format?
		var isSpecFormat = dateTimeStr.length === 19 &&
			dateTimeStr.charAt(4) === ':';
		//is the date in the non-standard format,
		//"2004-09-04T23:39:06-08:00" to include a timezone?
		var isTimezoneFormat = dateTimeStr.length === 25 &&
			dateTimeStr.charAt(10) === 'T';

		if(isTimezoneFormat) {
			return parseDateWithTimezoneFormat(dateTimeStr);
		}
		else if(isSpecFormat) {
			return parseDateWithSpecFormat(dateTimeStr);
		}
	}

	date = {
		parseDateWithSpecFormat: parseDateWithSpecFormat,
		parseDateWithTimezoneFormat: parseDateWithTimezoneFormat,
		parseExifDate: parseExifDate
	};
	return date;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;
	var exif = requireExif();
	var date = requireDate();

	var degreeTags = [{
		section: exif.GPSIFD,
		type: 0x0002,
		name: 'GPSLatitude',
		refType: 0x0001,
		refName: 'GPSLatitudeRef',
		posVal: 'N'
	},
	{
		section: exif.GPSIFD,
		type: 0x0004,
		name: 'GPSLongitude',
		refType: 0x0003,
		refName: 'GPSLongitudeRef',
		posVal: 'E'
	}];
	var dateTags = [{
		section: exif.SubIFD,
		type: 0x0132,
		name: 'ModifyDate'
	},
	{
		section: exif.SubIFD,
		type: 0x9003,
		name: 'DateTimeOriginal'
	},
	{
		section: exif.SubIFD,
		type: 0x9004,
		name: 'CreateDate'
	},
	{
		section: exif.SubIFD,
		type: 0x0132,
		name : 'ModifyDate',
	}];

	simplify = {
		castDegreeValues: function(getTagValue, setTagValue) {
			degreeTags.forEach(function(t) {
				var degreeVal = getTagValue(t);
				if(degreeVal) {
					var degreeRef = getTagValue({section: t.section, type: t.refType, name: t.refName});
					var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
					var degree = (degreeVal[0] + (degreeVal[1] / 60) + (degreeVal[2] / 3600)) * degreeNumRef;
					setTagValue(t, degree);
				}
			});
		},
		castDateValues: function(getTagValue, setTagValue) {
			dateTags.forEach(function(t) {
				var dateStrVal = getTagValue(t);
				if(dateStrVal) {
					//some easy checks to determine two common date formats
					var timestamp = date.parseExifDate(dateStrVal);
					if(typeof timestamp !== 'undefined') {
						setTagValue(t, timestamp);
					}
				}
			});
		},
		simplifyValue: function(values, format) {
			if(Array.isArray(values)) {
				values = values.map(function(value) {
					if(format === 10 || format === 5) {
						return value[0] / value[1];
					}
					return value;
				});
				if(values.length === 1) {
					values = values[0];
				}
			}
			return values;
		}
	};
	return simplify;
}

var exifTags;
var hasRequiredExifTags;

function requireExifTags () {
	if (hasRequiredExifTags) return exifTags;
	hasRequiredExifTags = 1;
	exifTags = {
		exif : {
			0x0001 : "InteropIndex",
			0x0002 : "InteropVersion",
			0x000B : "ProcessingSoftware",
			0x00FE : "SubfileType",
			0x00FF : "OldSubfileType",
			0x0100 : "ImageWidth",
			0x0101 : "ImageHeight",
			0x0102 : "BitsPerSample",
			0x0103 : "Compression",
			0x0106 : "PhotometricInterpretation",
			0x0107 : "Thresholding",
			0x0108 : "CellWidth",
			0x0109 : "CellLength",
			0x010A : "FillOrder",
			0x010D : "DocumentName",
			0x010E : "ImageDescription",
			0x010F : "Make",
			0x0110 : "Model",
			0x0111 : "StripOffsets",
			0x0112 : "Orientation",
			0x0115 : "SamplesPerPixel",
			0x0116 : "RowsPerStrip",
			0x0117 : "StripByteCounts",
			0x0118 : "MinSampleValue",
			0x0119 : "MaxSampleValue",
			0x011A : "XResolution",
			0x011B : "YResolution",
			0x011C : "PlanarConfiguration",
			0x011D : "PageName",
			0x011E : "XPosition",
			0x011F : "YPosition",
			0x0120 : "FreeOffsets",
			0x0121 : "FreeByteCounts",
			0x0122 : "GrayResponseUnit",
			0x0123 : "GrayResponseCurve",
			0x0124 : "T4Options",
			0x0125 : "T6Options",
			0x0128 : "ResolutionUnit",
			0x0129 : "PageNumber",
			0x012C : "ColorResponseUnit",
			0x012D : "TransferFunction",
			0x0131 : "Software",
			0x0132 : "ModifyDate",
			0x013B : "Artist",
			0x013C : "HostComputer",
			0x013D : "Predictor",
			0x013E : "WhitePoint",
			0x013F : "PrimaryChromaticities",
			0x0140 : "ColorMap",
			0x0141 : "HalftoneHints",
			0x0142 : "TileWidth",
			0x0143 : "TileLength",
			0x0144 : "TileOffsets",
			0x0145 : "TileByteCounts",
			0x0146 : "BadFaxLines",
			0x0147 : "CleanFaxData",
			0x0148 : "ConsecutiveBadFaxLines",
			0x014A : "SubIFD",
			0x014C : "InkSet",
			0x014D : "InkNames",
			0x014E : "NumberofInks",
			0x0150 : "DotRange",
			0x0151 : "TargetPrinter",
			0x0152 : "ExtraSamples",
			0x0153 : "SampleFormat",
			0x0154 : "SMinSampleValue",
			0x0155 : "SMaxSampleValue",
			0x0156 : "TransferRange",
			0x0157 : "ClipPath",
			0x0158 : "XClipPathUnits",
			0x0159 : "YClipPathUnits",
			0x015A : "Indexed",
			0x015B : "JPEGTables",
			0x015F : "OPIProxy",
			0x0190 : "GlobalParametersIFD",
			0x0191 : "ProfileType",
			0x0192 : "FaxProfile",
			0x0193 : "CodingMethods",
			0x0194 : "VersionYear",
			0x0195 : "ModeNumber",
			0x01B1 : "Decode",
			0x01B2 : "DefaultImageColor",
			0x01B3 : "T82Options",
			0x01B5 : "JPEGTables",
			0x0200 : "JPEGProc",
			0x0201 : "ThumbnailOffset",
			0x0202 : "ThumbnailLength",
			0x0203 : "JPEGRestartInterval",
			0x0205 : "JPEGLosslessPredictors",
			0x0206 : "JPEGPointTransforms",
			0x0207 : "JPEGQTables",
			0x0208 : "JPEGDCTables",
			0x0209 : "JPEGACTables",
			0x0211 : "YCbCrCoefficients",
			0x0212 : "YCbCrSubSampling",
			0x0213 : "YCbCrPositioning",
			0x0214 : "ReferenceBlackWhite",
			0x022F : "StripRowCounts",
			0x02BC : "ApplicationNotes",
			0x03E7 : "USPTOMiscellaneous",
			0x1000 : "RelatedImageFileFormat",
			0x1001 : "RelatedImageWidth",
			0x1002 : "RelatedImageHeight",
			0x4746 : "Rating",
			0x4747 : "XP_DIP_XML",
			0x4748 : "StitchInfo",
			0x4749 : "RatingPercent",
			0x800D : "ImageID",
			0x80A3 : "WangTag1",
			0x80A4 : "WangAnnotation",
			0x80A5 : "WangTag3",
			0x80A6 : "WangTag4",
			0x80E3 : "Matteing",
			0x80E4 : "DataType",
			0x80E5 : "ImageDepth",
			0x80E6 : "TileDepth",
			0x827D : "Model2",
			0x828D : "CFARepeatPatternDim",
			0x828E : "CFAPattern2",
			0x828F : "BatteryLevel",
			0x8290 : "KodakIFD",
			0x8298 : "Copyright",
			0x829A : "ExposureTime",
			0x829D : "FNumber",
			0x82A5 : "MDFileTag",
			0x82A6 : "MDScalePixel",
			0x82A7 : "MDColorTable",
			0x82A8 : "MDLabName",
			0x82A9 : "MDSampleInfo",
			0x82AA : "MDPrepDate",
			0x82AB : "MDPrepTime",
			0x82AC : "MDFileUnits",
			0x830E : "PixelScale",
			0x8335 : "AdventScale",
			0x8336 : "AdventRevision",
			0x835C : "UIC1Tag",
			0x835D : "UIC2Tag",
			0x835E : "UIC3Tag",
			0x835F : "UIC4Tag",
			0x83BB : "IPTC-NAA",
			0x847E : "IntergraphPacketData",
			0x847F : "IntergraphFlagRegisters",
			0x8480 : "IntergraphMatrix",
			0x8481 : "INGRReserved",
			0x8482 : "ModelTiePoint",
			0x84E0 : "Site",
			0x84E1 : "ColorSequence",
			0x84E2 : "IT8Header",
			0x84E3 : "RasterPadding",
			0x84E4 : "BitsPerRunLength",
			0x84E5 : "BitsPerExtendedRunLength",
			0x84E6 : "ColorTable",
			0x84E7 : "ImageColorIndicator",
			0x84E8 : "BackgroundColorIndicator",
			0x84E9 : "ImageColorValue",
			0x84EA : "BackgroundColorValue",
			0x84EB : "PixelIntensityRange",
			0x84EC : "TransparencyIndicator",
			0x84ED : "ColorCharacterization",
			0x84EE : "HCUsage",
			0x84EF : "TrapIndicator",
			0x84F0 : "CMYKEquivalent",
			0x8546 : "SEMInfo",
			0x8568 : "AFCP_IPTC",
			0x85B8 : "PixelMagicJBIGOptions",
			0x85D8 : "ModelTransform",
			0x8602 : "WB_GRGBLevels",
			0x8606 : "LeafData",
			0x8649 : "PhotoshopSettings",
			0x8769 : "ExifOffset",
			0x8773 : "ICC_Profile",
			0x877F : "TIFF_FXExtensions",
			0x8780 : "MultiProfiles",
			0x8781 : "SharedData",
			0x8782 : "T88Options",
			0x87AC : "ImageLayer",
			0x87AF : "GeoTiffDirectory",
			0x87B0 : "GeoTiffDoubleParams",
			0x87B1 : "GeoTiffAsciiParams",
			0x8822 : "ExposureProgram",
			0x8824 : "SpectralSensitivity",
			0x8825 : "GPSInfo",
			0x8827 : "ISO",
			0x8828 : "Opto-ElectricConvFactor",
			0x8829 : "Interlace",
			0x882A : "TimeZoneOffset",
			0x882B : "SelfTimerMode",
			0x8830 : "SensitivityType",
			0x8831 : "StandardOutputSensitivity",
			0x8832 : "RecommendedExposureIndex",
			0x8833 : "ISOSpeed",
			0x8834 : "ISOSpeedLatitudeyyy",
			0x8835 : "ISOSpeedLatitudezzz",
			0x885C : "FaxRecvParams",
			0x885D : "FaxSubAddress",
			0x885E : "FaxRecvTime",
			0x888A : "LeafSubIFD",
			0x9000 : "ExifVersion",
			0x9003 : "DateTimeOriginal",
			0x9004 : "CreateDate",
			0x9101 : "ComponentsConfiguration",
			0x9102 : "CompressedBitsPerPixel",
			0x9201 : "ShutterSpeedValue",
			0x9202 : "ApertureValue",
			0x9203 : "BrightnessValue",
			0x9204 : "ExposureCompensation",
			0x9205 : "MaxApertureValue",
			0x9206 : "SubjectDistance",
			0x9207 : "MeteringMode",
			0x9208 : "LightSource",
			0x9209 : "Flash",
			0x920A : "FocalLength",
			0x920B : "FlashEnergy",
			0x920C : "SpatialFrequencyResponse",
			0x920D : "Noise",
			0x920E : "FocalPlaneXResolution",
			0x920F : "FocalPlaneYResolution",
			0x9210 : "FocalPlaneResolutionUnit",
			0x9211 : "ImageNumber",
			0x9212 : "SecurityClassification",
			0x9213 : "ImageHistory",
			0x9214 : "SubjectArea",
			0x9215 : "ExposureIndex",
			0x9216 : "TIFF-EPStandardID",
			0x9217 : "SensingMethod",
			0x923A : "CIP3DataFile",
			0x923B : "CIP3Sheet",
			0x923C : "CIP3Side",
			0x923F : "StoNits",
			0x927C : "MakerNote",
			0x9286 : "UserComment",
			0x9290 : "SubSecTime",
			0x9291 : "SubSecTimeOriginal",
			0x9292 : "SubSecTimeDigitized",
			0x932F : "MSDocumentText",
			0x9330 : "MSPropertySetStorage",
			0x9331 : "MSDocumentTextPosition",
			0x935C : "ImageSourceData",
			0x9C9B : "XPTitle",
			0x9C9C : "XPComment",
			0x9C9D : "XPAuthor",
			0x9C9E : "XPKeywords",
			0x9C9F : "XPSubject",
			0xA000 : "FlashpixVersion",
			0xA001 : "ColorSpace",
			0xA002 : "ExifImageWidth",
			0xA003 : "ExifImageHeight",
			0xA004 : "RelatedSoundFile",
			0xA005 : "InteropOffset",
			0xA20B : "FlashEnergy",
			0xA20C : "SpatialFrequencyResponse",
			0xA20D : "Noise",
			0xA20E : "FocalPlaneXResolution",
			0xA20F : "FocalPlaneYResolution",
			0xA210 : "FocalPlaneResolutionUnit",
			0xA211 : "ImageNumber",
			0xA212 : "SecurityClassification",
			0xA213 : "ImageHistory",
			0xA214 : "SubjectLocation",
			0xA215 : "ExposureIndex",
			0xA216 : "TIFF-EPStandardID",
			0xA217 : "SensingMethod",
			0xA300 : "FileSource",
			0xA301 : "SceneType",
			0xA302 : "CFAPattern",
			0xA401 : "CustomRendered",
			0xA402 : "ExposureMode",
			0xA403 : "WhiteBalance",
			0xA404 : "DigitalZoomRatio",
			0xA405 : "FocalLengthIn35mmFormat",
			0xA406 : "SceneCaptureType",
			0xA407 : "GainControl",
			0xA408 : "Contrast",
			0xA409 : "Saturation",
			0xA40A : "Sharpness",
			0xA40B : "DeviceSettingDescription",
			0xA40C : "SubjectDistanceRange",
			0xA420 : "ImageUniqueID",
			0xA430 : "OwnerName",
			0xA431 : "SerialNumber",
			0xA432 : "LensInfo",
			0xA433 : "LensMake",
			0xA434 : "LensModel",
			0xA435 : "LensSerialNumber",
			0xA480 : "GDALMetadata",
			0xA481 : "GDALNoData",
			0xA500 : "Gamma",
			0xAFC0 : "ExpandSoftware",
			0xAFC1 : "ExpandLens",
			0xAFC2 : "ExpandFilm",
			0xAFC3 : "ExpandFilterLens",
			0xAFC4 : "ExpandScanner",
			0xAFC5 : "ExpandFlashLamp",
			0xBC01 : "PixelFormat",
			0xBC02 : "Transformation",
			0xBC03 : "Uncompressed",
			0xBC04 : "ImageType",
			0xBC80 : "ImageWidth",
			0xBC81 : "ImageHeight",
			0xBC82 : "WidthResolution",
			0xBC83 : "HeightResolution",
			0xBCC0 : "ImageOffset",
			0xBCC1 : "ImageByteCount",
			0xBCC2 : "AlphaOffset",
			0xBCC3 : "AlphaByteCount",
			0xBCC4 : "ImageDataDiscard",
			0xBCC5 : "AlphaDataDiscard",
			0xC427 : "OceScanjobDesc",
			0xC428 : "OceApplicationSelector",
			0xC429 : "OceIDNumber",
			0xC42A : "OceImageLogic",
			0xC44F : "Annotations",
			0xC4A5 : "PrintIM",
			0xC580 : "USPTOOriginalContentType",
			0xC612 : "DNGVersion",
			0xC613 : "DNGBackwardVersion",
			0xC614 : "UniqueCameraModel",
			0xC615 : "LocalizedCameraModel",
			0xC616 : "CFAPlaneColor",
			0xC617 : "CFALayout",
			0xC618 : "LinearizationTable",
			0xC619 : "BlackLevelRepeatDim",
			0xC61A : "BlackLevel",
			0xC61B : "BlackLevelDeltaH",
			0xC61C : "BlackLevelDeltaV",
			0xC61D : "WhiteLevel",
			0xC61E : "DefaultScale",
			0xC61F : "DefaultCropOrigin",
			0xC620 : "DefaultCropSize",
			0xC621 : "ColorMatrix1",
			0xC622 : "ColorMatrix2",
			0xC623 : "CameraCalibration1",
			0xC624 : "CameraCalibration2",
			0xC625 : "ReductionMatrix1",
			0xC626 : "ReductionMatrix2",
			0xC627 : "AnalogBalance",
			0xC628 : "AsShotNeutral",
			0xC629 : "AsShotWhiteXY",
			0xC62A : "BaselineExposure",
			0xC62B : "BaselineNoise",
			0xC62C : "BaselineSharpness",
			0xC62D : "BayerGreenSplit",
			0xC62E : "LinearResponseLimit",
			0xC62F : "CameraSerialNumber",
			0xC630 : "DNGLensInfo",
			0xC631 : "ChromaBlurRadius",
			0xC632 : "AntiAliasStrength",
			0xC633 : "ShadowScale",
			0xC634 : "DNGPrivateData",
			0xC635 : "MakerNoteSafety",
			0xC640 : "RawImageSegmentation",
			0xC65A : "CalibrationIlluminant1",
			0xC65B : "CalibrationIlluminant2",
			0xC65C : "BestQualityScale",
			0xC65D : "RawDataUniqueID",
			0xC660 : "AliasLayerMetadata",
			0xC68B : "OriginalRawFileName",
			0xC68C : "OriginalRawFileData",
			0xC68D : "ActiveArea",
			0xC68E : "MaskedAreas",
			0xC68F : "AsShotICCProfile",
			0xC690 : "AsShotPreProfileMatrix",
			0xC691 : "CurrentICCProfile",
			0xC692 : "CurrentPreProfileMatrix",
			0xC6BF : "ColorimetricReference",
			0xC6D2 : "PanasonicTitle",
			0xC6D3 : "PanasonicTitle2",
			0xC6F3 : "CameraCalibrationSig",
			0xC6F4 : "ProfileCalibrationSig",
			0xC6F5 : "ProfileIFD",
			0xC6F6 : "AsShotProfileName",
			0xC6F7 : "NoiseReductionApplied",
			0xC6F8 : "ProfileName",
			0xC6F9 : "ProfileHueSatMapDims",
			0xC6FA : "ProfileHueSatMapData1",
			0xC6FB : "ProfileHueSatMapData2",
			0xC6FC : "ProfileToneCurve",
			0xC6FD : "ProfileEmbedPolicy",
			0xC6FE : "ProfileCopyright",
			0xC714 : "ForwardMatrix1",
			0xC715 : "ForwardMatrix2",
			0xC716 : "PreviewApplicationName",
			0xC717 : "PreviewApplicationVersion",
			0xC718 : "PreviewSettingsName",
			0xC719 : "PreviewSettingsDigest",
			0xC71A : "PreviewColorSpace",
			0xC71B : "PreviewDateTime",
			0xC71C : "RawImageDigest",
			0xC71D : "OriginalRawFileDigest",
			0xC71E : "SubTileBlockSize",
			0xC71F : "RowInterleaveFactor",
			0xC725 : "ProfileLookTableDims",
			0xC726 : "ProfileLookTableData",
			0xC740 : "OpcodeList1",
			0xC741 : "OpcodeList2",
			0xC74E : "OpcodeList3",
			0xC761 : "NoiseProfile",
			0xC763 : "TimeCodes",
			0xC764 : "FrameRate",
			0xC772 : "TStop",
			0xC789 : "ReelName",
			0xC791 : "OriginalDefaultFinalSize",
			0xC792 : "OriginalBestQualitySize",
			0xC793 : "OriginalDefaultCropSize",
			0xC7A1 : "CameraLabel",
			0xC7A3 : "ProfileHueSatMapEncoding",
			0xC7A4 : "ProfileLookTableEncoding",
			0xC7A5 : "BaselineExposureOffset",
			0xC7A6 : "DefaultBlackRender",
			0xC7A7 : "NewRawImageDigest",
			0xC7A8 : "RawToPreviewGain",
			0xC7B5 : "DefaultUserCrop",
			0xEA1C : "Padding",
			0xEA1D : "OffsetSchema",
			0xFDE8 : "OwnerName",
			0xFDE9 : "SerialNumber",
			0xFDEA : "Lens",
			0xFE00 : "KDC_IFD",
			0xFE4C : "RawFile",
			0xFE4D : "Converter",
			0xFE4E : "WhiteBalance",
			0xFE51 : "Exposure",
			0xFE52 : "Shadows",
			0xFE53 : "Brightness",
			0xFE54 : "Contrast",
			0xFE55 : "Saturation",
			0xFE56 : "Sharpness",
			0xFE57 : "Smoothness",
			0xFE58 : "MoireFilter"
			
		},
		gps : {	
			0x0000 : 'GPSVersionID',
			0x0001 : 'GPSLatitudeRef',
			0x0002 : 'GPSLatitude',
			0x0003 : 'GPSLongitudeRef',
			0x0004 : 'GPSLongitude',
			0x0005 : 'GPSAltitudeRef',
			0x0006 : 'GPSAltitude',
			0x0007 : 'GPSTimeStamp',
			0x0008 : 'GPSSatellites',
			0x0009 : 'GPSStatus',
			0x000A : 'GPSMeasureMode',
			0x000B : 'GPSDOP',
			0x000C : 'GPSSpeedRef',
			0x000D : 'GPSSpeed',
			0x000E : 'GPSTrackRef',
			0x000F : 'GPSTrack',
			0x0010 : 'GPSImgDirectionRef',
			0x0011 : 'GPSImgDirection',
			0x0012 : 'GPSMapDatum',
			0x0013 : 'GPSDestLatitudeRef',
			0x0014 : 'GPSDestLatitude',
			0x0015 : 'GPSDestLongitudeRef',
			0x0016 : 'GPSDestLongitude',
			0x0017 : 'GPSDestBearingRef',
			0x0018 : 'GPSDestBearing',
			0x0019 : 'GPSDestDistanceRef',
			0x001A : 'GPSDestDistance',
			0x001B : 'GPSProcessingMethod',
			0x001C : 'GPSAreaInformation',
			0x001D : 'GPSDateStamp',
			0x001E : 'GPSDifferential',
			0x001F : 'GPSHPositioningError'
		}
	};
	return exifTags;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var parser;
var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;
	var jpeg = requireJpeg(),
		exif = requireExif(),
		simplify = requireSimplify();

	function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
		this.startMarker = startMarker;
		this.tags = tags;
		this.imageSize = imageSize;
		this.thumbnailOffset = thumbnailOffset;
		this.thumbnailLength = thumbnailLength;
		this.thumbnailType = thumbnailType;
		this.app1Offset = app1Offset;
	}

	ExifResult.prototype = {
		hasThumbnail: function(mime) {
			if(!this.thumbnailOffset || !this.thumbnailLength) {
				return false;
			}
			if(typeof mime !== 'string') {
				return true;
			}
			if(mime.toLowerCase().trim() === 'image/jpeg') {
				return this.thumbnailType === 6;
			}
			if(mime.toLowerCase().trim() === 'image/tiff') {
				return this.thumbnailType === 1;
			}
			return false;
		},
		getThumbnailOffset: function() {
			return this.app1Offset + 6 + this.thumbnailOffset;
		},
		getThumbnailLength: function() {
			return this.thumbnailLength;
		},
		getThumbnailBuffer: function() {
			return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
		},
		_getThumbnailStream: function() {
			return this.startMarker.openWithOffset(this.getThumbnailOffset());
		},
		getImageSize: function() {
			return this.imageSize;
		},
		getThumbnailSize: function() {
			var stream = this._getThumbnailStream(), size;
			jpeg.parseSections(stream, function(sectionType, sectionStream) {
				if(jpeg.getSectionName(sectionType).name === 'SOF') {
					size = jpeg.getSizeFromSOFSection(sectionStream);
				}
			});
			return size;
		}
	};

	function Parser(stream) {
		this.stream = stream;
		this.flags = {
			readBinaryTags: false,
			resolveTagNames: true,
			simplifyValues: true,
			imageSize: true,
			hidePointers: true,
			returnTags: true
		};
	}

	Parser.prototype = {
		enableBinaryFields: function(enable) {
			this.flags.readBinaryTags = !!enable;
			return this;
		},
		enablePointers: function(enable) {
			this.flags.hidePointers = !enable;
			return this;
		},
		enableTagNames: function(enable) {
			this.flags.resolveTagNames = !!enable;
			return this;
		},
		enableImageSize: function(enable) {
			this.flags.imageSize = !!enable;
			return this;
		},
		enableReturnTags: function(enable) {
			this.flags.returnTags = !!enable;
			return this;
		},
		enableSimpleValues: function(enable) {
			this.flags.simplifyValues = !!enable;
			return this;
		},
		parse: function() {
			var start = this.stream.mark(),
				stream = start.openWithOffset(0),
				flags = this.flags,
				tags,
				imageSize,
				thumbnailOffset,
				thumbnailLength,
				thumbnailType,
				app1Offset,
				tagNames,
				getTagValue, setTagValue;
			if(flags.resolveTagNames) {
				tagNames = requireExifTags();
			}
			if(flags.resolveTagNames) {
				tags = {};
				getTagValue = function(t) {
					return tags[t.name];
				};
				setTagValue = function(t, value) {
					tags[t.name] = value;
				};
			} else {
				tags = [];
				getTagValue = function(t) {
					var i;
					for(i = 0; i < tags.length; ++i) {
						if(tags[i].type === t.type && tags[i].section === t.section) {
							return tags.value;
						}
					}
				};
				setTagValue = function(t, value) {
					var i;
					for(i = 0; i < tags.length; ++i) {
						if(tags[i].type === t.type && tags[i].section === t.section) {
							tags.value = value;
							return;
						}
					}
				};
			}

			jpeg.parseSections(stream, function(sectionType, sectionStream) {
				var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
				if(sectionType === 0xE1) {
					validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format) {
						//ignore binary fields if disabled
						if(!flags.readBinaryTags && format === 7) {
							return;
						}

						if(tagType === 0x0201) {
							thumbnailOffset = value[0];
							if(flags.hidePointers) {return;}
						} else if(tagType === 0x0202) {
							thumbnailLength = value[0];
							if(flags.hidePointers) {return;}
						} else if(tagType === 0x0103) {
							thumbnailType = value[0];
							if(flags.hidePointers) {return;}
						}
						//if flag is set to not store tags, return here after storing pointers
						if(!flags.returnTags) {
							return;
						}

						if(flags.simplifyValues) {
							value = simplify.simplifyValue(value, format);
						}
						if(flags.resolveTagNames) {
							var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
							var name = sectionTagNames[tagType];
							if(!name) {
								name = tagNames.exif[tagType];
							}
							if (!tags.hasOwnProperty(name)) {
								tags[name] = value;
							}
						} else {
							tags.push({
								section: ifdSection,
								type: tagType,
								value: value
							});
						}
					});
					if(validExifHeaders) {
						app1Offset = sectionOffset;
					}
				}
				else if(flags.imageSize && jpeg.getSectionName(sectionType).name === 'SOF') {
					imageSize = jpeg.getSizeFromSOFSection(sectionStream);
				}
			});

			if(flags.simplifyValues) {
				simplify.castDegreeValues(getTagValue, setTagValue);
				simplify.castDateValues(getTagValue, setTagValue);
			}

			return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
		}
	};



	parser = Parser;
	return parser;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var domBufferstream;
var hasRequiredDomBufferstream;

function requireDomBufferstream () {
	if (hasRequiredDomBufferstream) return domBufferstream;
	hasRequiredDomBufferstream = 1;
	function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
		this.global = global;
		offset = offset || 0;
		length = length || (arrayBuffer.byteLength - offset);
		this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
		this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
		this.setBigEndian(bigEndian);
		this.offset = 0;
		this.parentOffset = (parentOffset || 0) + offset;
	}

	DOMBufferStream.prototype = {
		setBigEndian: function(bigEndian) {
			this.littleEndian = !bigEndian;
		},
		nextUInt8: function() {
			var value = this.view.getUint8(this.offset);
			this.offset += 1;
			return value;
		},
		nextInt8: function() {
			var value = this.view.getInt8(this.offset);
			this.offset += 1;
			return value;
		},
		nextUInt16: function() {
			var value = this.view.getUint16(this.offset, this.littleEndian);
			this.offset += 2;
			return value;
		},
		nextUInt32: function() {
			var value = this.view.getUint32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},
		nextInt16: function() {
			var value = this.view.getInt16(this.offset, this.littleEndian);
			this.offset += 2;
			return value;
		},
		nextInt32: function() {
			var value = this.view.getInt32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},
		nextFloat: function() {
			var value = this.view.getFloat32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},
		nextDouble: function() {
			var value = this.view.getFloat64(this.offset, this.littleEndian);
			this.offset += 8;
			return value;
		},
		nextBuffer: function(length) {
			//this won't work in IE10
			var value = this.arrayBuffer.slice(this.offset, this.offset + length);
			this.offset += length;
			return value;
		},
		remainingLength: function() {
			return this.arrayBuffer.byteLength - this.offset;
		},
		nextString: function(length) {
			var value = this.arrayBuffer.slice(this.offset, this.offset + length);
			value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
			this.offset += length;
			return value;
		},
		mark: function() {
			var self = this;
			return {
				openWithOffset: function(offset) {
					offset = (offset || 0) + this.offset;
					return new DOMBufferStream(self.arrayBuffer, offset, self.arrayBuffer.byteLength - offset, !self.littleEndian, self.global, self.parentOffset);
				},
				offset: this.offset,
				getParentOffset: function() {
					return self.parentOffset;
				}
			};
		},
		offsetFrom: function(marker) {
			return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
		},
		skip: function(amount) {
			this.offset += amount;
		},
		branch: function(offset, length) {
			length = typeof length === 'number' ? length : this.arrayBuffer.byteLength - (this.offset + offset);
			return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
		}
	};

	domBufferstream = DOMBufferStream;
	return domBufferstream;
}

var bufferstream;
var hasRequiredBufferstream;

function requireBufferstream () {
	if (hasRequiredBufferstream) return bufferstream;
	hasRequiredBufferstream = 1;
	function BufferStream(buffer, offset, length, bigEndian) {
		this.buffer = buffer;
		this.offset = offset || 0;
		length = typeof length === 'number' ? length : buffer.length;
		this.endPosition = this.offset + length;
		this.setBigEndian(bigEndian);
	}

	BufferStream.prototype = {
		setBigEndian: function(bigEndian) {
			this.bigEndian = !!bigEndian;
		},
		nextUInt8: function() {
			var value = this.buffer.readUInt8(this.offset);
			this.offset += 1;
			return value;
		},
		nextInt8: function() {
			var value = this.buffer.readInt8(this.offset);
			this.offset += 1;
			return value;
		},
		nextUInt16: function() {
			var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
			this.offset += 2;
			return value;
		},
		nextUInt32: function() {
			var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
			this.offset += 4;
			return value;
		},
		nextInt16: function() {
			var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
			this.offset += 2;
			return value;
		},
		nextInt32: function() {
			var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
			this.offset += 4;
			return value;
		},
		nextFloat: function() {
			var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
			this.offset += 4;
			return value;
		},
		nextDouble: function() {
			var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
			this.offset += 8;
			return value;
		},
		nextBuffer: function(length) {
			var value = this.buffer.slice(this.offset, this.offset + length);
			this.offset += length;
			return value;
		},
		remainingLength: function() {
			return this.endPosition - this.offset;
		},
		nextString: function(length) {
			var value = this.buffer.toString('utf8', this.offset, this.offset + length);
			this.offset += length;
			return value;
		},
		mark: function() {
			var self = this;
			return {
				openWithOffset: function(offset) {
					offset = (offset || 0) + this.offset;
					return new BufferStream(self.buffer, offset, self.endPosition - offset, self.bigEndian);
				},
				offset: this.offset
			};
		},
		offsetFrom: function(marker) {
			return this.offset - marker.offset;
		},
		skip: function(amount) {
			this.offset += amount;
		},
		branch: function(offset, length) {
			length = typeof length === 'number' ? length : this.endPosition - (this.offset + offset);
			return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
		}
	};

	bufferstream = BufferStream;
	return bufferstream;
}

var exifParser;
var hasRequiredExifParser;

function requireExifParser () {
	if (hasRequiredExifParser) return exifParser;
	hasRequiredExifParser = 1;
	var Parser = requireParser();

	function getGlobal() {
		return (0, eval)('this');
	}

	exifParser = {
		create: function(buffer, global) {
			global = global || getGlobal();
			if(buffer instanceof global.ArrayBuffer) {
				var DOMBufferStream = requireDomBufferstream();
				return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));
			} else {
				var NodeBufferStream = requireBufferstream();
				return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
			}
		}
	};
	return exifParser;
}

var exifParserExports = requireExifParser();
const EXIFParser = /*@__PURE__*/getDefaultExportFromCjs(exifParserExports);

/**
 * Obtains image orientation from EXIF metadata.
 *
 * @param img a Jimp image object
 * @returns a number 1-8 representing EXIF orientation,
 *          in particular 1 if orientation tag is missing
 */
function getExifOrientation(img) {
    const _exif = img._exif;
    return (_exif && _exif.tags && _exif.tags.Orientation) || 1;
}
/**
 * Returns a function which translates EXIF-rotated coordinates into
 * non-rotated ones.
 *
 * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.
 *
 * @param img a Jimp image object
 * @returns transformation function for transformBitmap().
 */
function getExifOrientationTransformation(img) {
    const w = img.bitmap.width;
    const h = img.bitmap.height;
    switch (getExifOrientation(img)) {
        case 1: // Horizontal (normal)
            // does not need to be supported here
            return null;
        case 2: // Mirror horizontal
            return function (x, y) {
                return [w - x - 1, y];
            };
        case 3: // Rotate 180
            return function (x, y) {
                return [w - x - 1, h - y - 1];
            };
        case 4: // Mirror vertical
            return function (x, y) {
                return [x, h - y - 1];
            };
        case 5: // Mirror horizontal and rotate 270 CW
            return function (x, y) {
                return [y, x];
            };
        case 6: // Rotate 90 CW
            return function (x, y) {
                return [y, h - x - 1];
            };
        case 7: // Mirror horizontal and rotate 90 CW
            return function (x, y) {
                return [w - y - 1, h - x - 1];
            };
        case 8: // Rotate 270 CW
            return function (x, y) {
                return [w - y - 1, x];
            };
        default:
            return null;
    }
}
/**
 * Transforms bitmap in place (moves pixels around) according to given
 * transformation function.
 *
 * @param img a Jimp image object, which bitmap is supposed to
 *        be transformed
 * @param width bitmap width after the transformation
 * @param height bitmap height after the transformation
 * @param transformation transformation function which defines pixel
 *        mapping between new and source bitmap. It takes a pair of coordinates
 *        in the target, and returns a respective pair of coordinates in
 *        the source bitmap, i.e. has following form:
 *        `function(new_x, new_y) { return [src_x, src_y] }`.
 */
function transformBitmap(img, width, height, transformation) {
    // Underscore-prefixed values are related to the source bitmap
    // Their counterparts with no prefix are related to the target bitmap
    const _data = img.bitmap.data;
    const _width = img.bitmap.width;
    const data = Buffer.alloc(_data.length);
    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            const [_x, _y] = transformation(x, y);
            const idx = (width * y + x) << 2;
            const _idx = (_width * _y + _x) << 2;
            const pixel = _data.readUInt32BE(_idx);
            data.writeUInt32BE(pixel, idx);
        }
    }
    img.bitmap.data = data;
    img.bitmap.width = width;
    img.bitmap.height = height;
    // @ts-expect-error Accessing private property
    img._exif.tags.Orientation = 1;
}
/**
 * Automagically rotates an image based on its EXIF data (if present).
 * @param img  a Jimp image object
 */
function exifRotate(img) {
    if (getExifOrientation(img) < 2) {
        return;
    }
    const transformation = getExifOrientationTransformation(img);
    const swapDimensions = getExifOrientation(img) > 4;
    const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
    const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
    if (transformation) {
        transformBitmap(img, newWidth, newHeight, transformation);
    }
}
async function attemptExifRotate(image, buffer) {
    try {
        image._exif =
            EXIFParser.create(buffer).parse();
        exifRotate(image); // EXIF data
    }
    catch {
        // do nothing
    }
}

const emptyBitmap = {
    data: Buffer.alloc(0),
    width: 0,
    height: 0,
};
/**
 * Prepare a Buffer object from the arrayBuffer.
 */
function bufferFromArrayBuffer(arrayBuffer) {
    const buffer = Buffer.alloc(arrayBuffer.byteLength);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }
    return buffer;
}
/**
 * Create a Jimp class that support the given image formats and methods
 */
function createJimp({ plugins: pluginsArg, formats: formatsArg, } = {}) {
    const plugins = pluginsArg || [];
    const formats = (formatsArg || []).map((format) => format());
    const CustomJimp = class Jimp {
        /**
         * The bitmap data of the image
         */
        bitmap = emptyBitmap;
        /**  Default color to use for new pixels */
        background = 0x00000000;
        /** Formats that can be used with Jimp */
        formats = [];
        /** The original MIME type of the image */
        mime;
        constructor(options = emptyBitmap) {
            // Add the formats
            this.formats = formats;
            if ("data" in options) {
                this.bitmap = options;
            }
            else {
                this.bitmap = {
                    data: Buffer.alloc(options.width * options.height * 4),
                    width: options.width,
                    height: options.height,
                };
                if (options.color) {
                    this.background =
                        typeof options.color === "string"
                            ? cssColorToHex(options.color)
                            : options.color;
                    for (let i = 0; i < this.bitmap.data.length; i += 4) {
                        this.bitmap.data.writeUInt32BE(this.background, i);
                    }
                }
            }
            // Add the plugins
            for (const methods of plugins) {
                for (const key in methods) {
                    this[key] = (...args) => {
                        const result = methods[key]?.(this, ...args);
                        if (typeof result === "object" && "bitmap" in result) {
                            this.bitmap = result.bitmap;
                            return this;
                        }
                        return result;
                    };
                }
            }
        }
        /**
         * Create a Jimp instance from a URL, a file path, or a Buffer
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * // Read from a file path
         * const image = await Jimp.read("test/image.png");
         *
         * // Read from a URL
         * const image = await Jimp.read("https://upload.wikimedia.org/wikipedia/commons/0/01/Bot-Test.jpg");
         * ```
         */
        static async read(url, options) {
            if (Buffer.isBuffer(url) || url instanceof ArrayBuffer) {
                return this.fromBuffer(url);
            }
            if (existsSync(url)) {
                return this.fromBuffer(await readFile(url));
            }
            const [fetchErr, response] = await to(fetch(url));
            if (fetchErr) {
                throw new Error(`Could not load Buffer from URL: ${url}`);
            }
            if (!response.ok) {
                throw new Error(`HTTP Status ${response.status} for url ${url}`);
            }
            const [arrayBufferErr, data] = await to(response.arrayBuffer());
            if (arrayBufferErr) {
                throw new Error(`Could not load Buffer from ${url}`);
            }
            const buffer = bufferFromArrayBuffer(data);
            return this.fromBuffer(buffer, options);
        }
        /**
         * Create a Jimp instance from a bitmap.
         * The difference between this and just using the constructor is that this will
         * convert raw image data into the bitmap format that Jimp uses.
         *
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = Jimp.fromBitmap({
         *   data: Buffer.from([
         *     0xffffffff, 0xffffffff, 0xffffffff,
         *     0xffffffff, 0xffffffff, 0xffffffff,
         *     0xffffffff, 0xffffffff, 0xffffffff,
         *   ]),
         *   width: 3,
         *   height: 3,
         * });
         * ```
         */
        static fromBitmap(bitmap) {
            let data;
            if (bitmap.data instanceof Buffer) {
                data = Buffer.from(bitmap.data);
            }
            if (bitmap.data instanceof Uint8Array ||
                bitmap.data instanceof Uint8ClampedArray) {
                data = Buffer.from(bitmap.data.buffer);
            }
            if (Array.isArray(bitmap.data)) {
                data = Buffer.concat(bitmap.data.map((hex) => Buffer.from(hex.toString(16).padStart(8, "0"), "hex")));
            }
            if (!data) {
                throw new Error("data must be a Buffer");
            }
            if (typeof bitmap.height !== "number" ||
                typeof bitmap.width !== "number") {
                throw new Error("bitmap must have width and height");
            }
            return new CustomJimp({
                height: bitmap.height,
                width: bitmap.width,
                data,
            });
        }
        /**
         * Parse a bitmap with the loaded image types.
         *
         * @param buffer Raw image data
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const buffer = await fs.readFile("test/image.png");
         * const image = await Jimp.fromBuffer(buffer);
         * ```
         */
        static async fromBuffer(buffer, options) {
            const actualBuffer = buffer instanceof ArrayBuffer ? bufferFromArrayBuffer(buffer) : buffer;
            const mime = await fileType.fromBuffer(actualBuffer);
            if (!mime || !mime.mime) {
                throw new Error("Could not find MIME for Buffer");
            }
            const format = formats.find((format) => format.mime === mime.mime);
            if (!format || !format.decode) {
                throw new Error(`Mime type ${mime.mime} does not support decoding`);
            }
            const image = new CustomJimp(await format.decode(actualBuffer, options?.[format.mime]));
            image.mime = mime.mime;
            attemptExifRotate(image, actualBuffer);
            return image;
        }
        /**
         * Nicely format Jimp object when sent to the console e.g. console.log(image)
         * @returns Pretty printed jimp object
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = await Jimp.read("test/image.png");
         *
         * console.log(image);
         * ```
         */
        inspect() {
            return ("<Jimp " +
                (this.bitmap === emptyBitmap
                    ? "pending..."
                    : this.bitmap.width + "x" + this.bitmap.height) +
                ">");
        }
        /**
         * Nicely format Jimp object when converted to a string
         * @returns pretty printed
         */
        toString() {
            return "[object Jimp]";
        }
        /** Get the width of the image */
        get width() {
            return this.bitmap.width;
        }
        /** Get the height of the image */
        get height() {
            return this.bitmap.height;
        }
        /**
         * Converts the Jimp instance to an image buffer
         * @param mime The mime type to export to
         * @param options The options to use when exporting
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         * import { promises as fs } from "fs";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * await image.write("test/output.jpeg", {
         *   quality: 50,
         * });
         * ```
         */
        async getBuffer(mime, options) {
            const format = this.formats.find((format) => format.mime === mime);
            if (!format || !format.encode) {
                throw new Error(`Unsupported MIME type: ${mime}`);
            }
            let outputImage;
            if (format.hasAlpha) {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                outputImage = this;
            }
            else {
                outputImage = new CustomJimp({
                    width: this.bitmap.width,
                    height: this.bitmap.height,
                    color: this.background,
                });
                composite(outputImage, this);
            }
            return format.encode(outputImage.bitmap, options);
        }
        /**
         * Converts the image to a base 64 string
         *
         * @param mime The mime type to export to
         * @param options The options to use when exporting
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = Jimp.fromBuffer(Buffer.from([
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         * ]));
         *
         * const base64 = image.getBase64("image/jpeg", {
         *   quality: 50,
         * });
         * ```
         */
        async getBase64(mime, options) {
            const data = await this.getBuffer(mime, options);
            return "data:" + mime + ";base64," + data.toString("base64");
        }
        /**
         * Write the image to a file
         * @param path the path to write the image to
         * @param options the options to use when writing the image
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = Jimp.fromBuffer(Buffer.from([
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         * ]));
         *
         * await image.write("test/output.png");
         * ```
         */
        async write(path, options) {
            const mimeType = mime.getType(path);
            await writeFile(path, await this.getBuffer(mimeType, options));
        }
        /**
         * Clone the image into a new Jimp instance.
         * @param this
         * @returns A new Jimp instance
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * const clone = image.clone();
         * ```
         */
        clone() {
            return new CustomJimp({
                ...this.bitmap,
                data: Buffer.from(this.bitmap.data),
            });
        }
        /**
         * Returns the offset of a pixel in the bitmap buffer
         * @param x the x coordinate
         * @param y the y coordinate
         * @param edgeHandling (optional) define how to sum pixels from outside the border
         * @returns the index of the pixel or -1 if not found
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * image.getPixelIndex(1, 1); // 2
         * ```
         */
        getPixelIndex(x, y, edgeHandling) {
            let xi;
            let yi;
            if (!edgeHandling) {
                edgeHandling = Edge.EXTEND;
            }
            if (typeof x !== "number" || typeof y !== "number") {
                throw new Error("x and y must be numbers");
            }
            // round input
            x = Math.round(x);
            y = Math.round(y);
            xi = x;
            yi = y;
            if (edgeHandling === Edge.EXTEND) {
                if (x < 0)
                    xi = 0;
                if (x >= this.bitmap.width)
                    xi = this.bitmap.width - 1;
                if (y < 0)
                    yi = 0;
                if (y >= this.bitmap.height)
                    yi = this.bitmap.height - 1;
            }
            if (edgeHandling === Edge.WRAP) {
                if (x < 0) {
                    xi = this.bitmap.width + x;
                }
                if (x >= this.bitmap.width) {
                    xi = x % this.bitmap.width;
                }
                if (y < 0) {
                    yi = this.bitmap.height + y;
                }
                if (y >= this.bitmap.height) {
                    yi = y % this.bitmap.height;
                }
            }
            let i = (this.bitmap.width * yi + xi) << 2;
            // if out of bounds index is -1
            if (xi < 0 || xi >= this.bitmap.width) {
                i = -1;
            }
            if (yi < 0 || yi >= this.bitmap.height) {
                i = -1;
            }
            return i;
        }
        /**
         * Returns the hex color value of a pixel
         * @param x the x coordinate
         * @param y the y coordinate
         * @returns the color of the pixel
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * image.getPixelColor(1, 1); // 0xffffffff
         * ```
         */
        getPixelColor(x, y) {
            if (typeof x !== "number" || typeof y !== "number") {
                throw new Error("x and y must be numbers");
            }
            const idx = this.getPixelIndex(x, y);
            return this.bitmap.data.readUInt32BE(idx);
        }
        /**
         * Sets the hex colour value of a pixel
         *
         * @param hex color to set
         * @param x the x coordinate
         * @param y the y coordinate
         *
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * image.setPixelColor(0xff0000ff, 0, 0);
         * ```
         */
        setPixelColor(hex, x, y) {
            if (typeof hex !== "number" ||
                typeof x !== "number" ||
                typeof y !== "number") {
                throw new Error("hex, x and y must be numbers");
            }
            const idx = this.getPixelIndex(x, y);
            this.bitmap.data.writeUInt32BE(hex, idx);
            return this;
        }
        /**
         * Determine if the image contains opaque pixels.
         *
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffaa });
         * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });
         *
         * image.hasAlpha(); // false
         * image2.hasAlpha(); // true
         * ```
         */
        hasAlpha() {
            const { width, height, data } = this.bitmap;
            const byteLen = (width * height) << 2;
            for (let idx = 3; idx < byteLen; idx += 4) {
                if (data[idx] !== 0xff) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Composites a source image over to this image respecting alpha channels
         * @param src the source Jimp instance
         * @param x the x position to blit the image
         * @param y the y position to blit the image
         * @param options determine what mode to use
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 10, height: 10, color: 0xffffffff });
         * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });
         *
         * image.composite(image2, 3, 3);
         * ```
         */
        composite(src, x = 0, y = 0, options = {}) {
            return composite(this, src, x, y, options);
        }
        scan(x, y, w, h, f) {
            return scan(this, x, y, w, h, f);
        }
        /**
         * Iterate scan through a region of the bitmap
         * @param x the x coordinate to begin the scan at
         * @param y the y coordinate to begin the scan at
         * @param w the width of the scan region
         * @param h the height of the scan region
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * for (const { x, y, idx, image } of j.scanIterator()) {
         *   // do something with the pixel
         * }
         * ```
         */
        scanIterator(x = 0, y = 0, w = this.bitmap.width, h = this.bitmap.height) {
            if (typeof x !== "number" || typeof y !== "number") {
                throw new Error("x and y must be numbers");
            }
            if (typeof w !== "number" || typeof h !== "number") {
                throw new Error("w and h must be numbers");
            }
            return scanIterator(this, x, y, w, h);
        }
    };
    return CustomJimp;
}

/**
 * What resizing algorithm to use.
 */
var ResizeStrategy;
(function (ResizeStrategy) {
    /**
     * Nearest Neighbor resizing is a method used in image processing that assigns the value of the nearest pixel to the output pixel when resizing an image.
     * While fast, it can lead to lower quality outputs with noticeable pixelation, especially at larger scaling factors.
     */
    ResizeStrategy["NEAREST_NEIGHBOR"] = "nearestNeighbor";
    /**
     * Bilinear resizing is an image scaling method that uses the weighted average of the four nearest pixel values, providing smoother gradients than nearest neighbor resizing.
     * It's computationally more intense than nearest neighbor but results in images of higher quality and fewer artifacts.
     */
    ResizeStrategy["BILINEAR"] = "bilinearInterpolation";
    /**
     * Bicubic resizing is an image interpolation method that uses the values of the nearest 16 pixels in the input image to calculate the output pixel value, providing even more smoothness and sharpness than bilinear resizing.
     * Although it's computationally more expensive than bilinear and nearest neighbor, it produces higher quality images, making it ideal for photographic image scaling.
     */
    ResizeStrategy["BICUBIC"] = "bicubicInterpolation";
    /**
     * Hermite resizing is an image resizing method that uses Hermite interpolation, a mathematical formula, to determine the values of output pixels based on a weighted average of the surrounding pixels.
     * Although slower than some simpler techniques like bilinear or nearest neighbor, Hermite resizing can produce higher quality visuals and detailed renderings with less blurring.
     */
    ResizeStrategy["HERMITE"] = "hermiteInterpolation";
    ResizeStrategy["BEZIER"] = "bezierInterpolation";
})(ResizeStrategy || (ResizeStrategy = {}));

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
// JavaScript Image Resizer (c) 2012 - Grant Galitz
// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4
function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
    this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
    this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
    this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
    this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
    this.colorChannels = blendAlpha ? 4 : 3;
    this.interpolationPass = Boolean(interpolationPass);
    this.resizeCallback =
        typeof resizeCallback === "function" ? resizeCallback : function () { };
    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
    this.originalWidthMultipliedByChannels =
        this.widthOriginal * this.colorChannels;
    this.originalHeightMultipliedByChannels =
        this.heightOriginal * this.colorChannels;
    this.widthPassResultSize =
        this.targetWidthMultipliedByChannels * this.heightOriginal;
    this.finalResultSize =
        this.targetWidthMultipliedByChannels * this.targetHeight;
    this.initialize();
}
Resize.prototype.initialize = function () {
    // Perform some checks:
    if (this.widthOriginal > 0 &&
        this.heightOriginal > 0 &&
        this.targetWidth > 0 &&
        this.targetHeight > 0) {
        this.configurePasses();
    }
    else {
        console.log(this);
        throw new Error("Invalid settings specified for the resizer.");
    }
};
Resize.prototype.configurePasses = function () {
    if (this.widthOriginal === this.targetWidth) {
        // Bypass the width resizer pass:
        this.resizeWidth = this.bypassResizer;
    }
    else {
        // Setup the width resizer pass:
        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
        if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
            this.initializeFirstPassBuffers(true);
            this.resizeWidth =
                this.colorChannels === 4
                    ? this.resizeWidthInterpolatedRGBA
                    : this.resizeWidthInterpolatedRGB;
        }
        else {
            this.initializeFirstPassBuffers(false);
            this.resizeWidth =
                this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
        }
    }
    if (this.heightOriginal === this.targetHeight) {
        // Bypass the height resizer pass:
        this.resizeHeight = this.bypassResizer;
    }
    else {
        // Setup the height resizer pass:
        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
        if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
            this.initializeSecondPassBuffers(true);
            this.resizeHeight = this.resizeHeightInterpolated;
        }
        else {
            this.initializeSecondPassBuffers(false);
            this.resizeHeight =
                this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
        }
    }
};
Resize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {
    const channelsNum = fourthChannel ? 4 : 3;
    const ratioWeight = this.ratioWeightWidthPass;
    const outputBuffer = this.widthBuffer;
    let weight = 0;
    let finalOffset = 0;
    let pixelOffset = 0;
    let firstWeight = 0;
    let secondWeight = 0;
    let targetPosition;
    // Handle for only one interpolation input being valid for start calculation:
    for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,
            finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
            if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
    }
    // Adjust for overshoot of the last pass's counter:
    weight -= 1 / 3;
    let interpolationWidthSourceReadStop;
    for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
        // Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        // Interpolate:
        for (finalOffset = targetPosition,
            pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,
            finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset + 0] =
                buffer[pixelOffset + 0] * firstWeight +
                    buffer[pixelOffset + channelsNum + 0] * secondWeight;
            outputBuffer[finalOffset + 1] =
                buffer[pixelOffset + 1] * firstWeight +
                    buffer[pixelOffset + channelsNum + 1] * secondWeight;
            outputBuffer[finalOffset + 2] =
                buffer[pixelOffset + 2] * firstWeight +
                    buffer[pixelOffset + channelsNum + 2] * secondWeight;
            if (fourthChannel)
                outputBuffer[finalOffset + 3] =
                    buffer[pixelOffset + 3] * firstWeight +
                        buffer[pixelOffset + channelsNum + 3] * secondWeight;
        }
    }
    // Handle for only one interpolation input being valid for end calculation:
    for (interpolationWidthSourceReadStop =
        this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
        for (finalOffset = targetPosition,
            pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,
            finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
            if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
    }
    return outputBuffer;
};
Resize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {
    const channelsNum = fourthChannel ? 4 : 3;
    const ratioWeight = this.ratioWeightWidthPass;
    const ratioWeightDivisor = 1 / ratioWeight;
    const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
    const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
    const output = this.outputWidthWorkBench;
    const outputBuffer = this.widthBuffer;
    const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
    let weight = 0;
    let amountToNext = 0;
    let actualPosition = 0;
    let currentPosition = 0;
    let line = 0;
    let pixelOffset = 0;
    let outputOffset = 0;
    let multiplier = 1;
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    do {
        for (line = 0; line < this.originalHeightMultipliedByChannels;) {
            output[line++] = 0;
            output[line++] = 0;
            output[line++] = 0;
            if (fourthChannel) {
                output[line++] = 0;
                trustworthyColorsCount[line / channelsNum - 1] = 0;
            }
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            multiplier = Math.min(weight, amountToNext);
            for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
                r = buffer[pixelOffset];
                g = buffer[++pixelOffset];
                b = buffer[++pixelOffset];
                a = fourthChannel ? buffer[++pixelOffset] : 255;
                // Ignore RGB values if pixel is completely transparent
                output[line++] += (a ? r : 0) * multiplier;
                output[line++] += (a ? g : 0) * multiplier;
                output[line++] += (a ? b : 0) * multiplier;
                if (fourthChannel) {
                    output[line++] += a * multiplier;
                    trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
                }
            }
            if (weight >= amountToNext) {
                actualPosition += channelsNum;
                currentPosition = actualPosition;
                weight -= amountToNext;
            }
            else {
                currentPosition += weight;
                break;
            }
        } while (weight > 0 &&
            actualPosition < this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
            weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
            multiplier = fourthChannel
                ? weight
                    ? 1 / weight
                    : 0
                : ratioWeightDivisor;
            outputBuffer[pixelOffset] = output[line++] * multiplier;
            outputBuffer[++pixelOffset] = output[line++] * multiplier;
            outputBuffer[++pixelOffset] = output[line++] * multiplier;
            if (fourthChannel)
                outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
        }
        outputOffset += channelsNum;
    } while (outputOffset < this.targetWidthMultipliedByChannels);
    return outputBuffer;
};
Resize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {
    const ratioWeight = this.ratioWeightHeightPass;
    const ratioWeightDivisor = 1 / ratioWeight;
    const output = this.outputHeightWorkBench;
    const outputBuffer = this.heightBuffer;
    const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
    let weight = 0;
    let amountToNext = 0;
    let actualPosition = 0;
    let currentPosition = 0;
    let pixelOffset = 0;
    let outputOffset = 0;
    let caret = 0;
    let multiplier = 1;
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    do {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            if (fourthChannel) {
                output[pixelOffset++] = 0;
                trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
            }
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            multiplier = Math.min(weight, amountToNext);
            caret = actualPosition;
            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
                r = buffer[caret++];
                g = buffer[caret++];
                b = buffer[caret++];
                a = fourthChannel ? buffer[caret++] : 255;
                // Ignore RGB values if pixel is completely transparent
                output[pixelOffset++] += (a ? r : 0) * multiplier;
                output[pixelOffset++] += (a ? g : 0) * multiplier;
                output[pixelOffset++] += (a ? b : 0) * multiplier;
                if (fourthChannel) {
                    output[pixelOffset++] += a * multiplier;
                    trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
                }
            }
            if (weight >= amountToNext) {
                actualPosition = caret;
                currentPosition = actualPosition;
                weight -= amountToNext;
            }
            else {
                currentPosition += weight;
                break;
            }
        } while (weight > 0 && actualPosition < this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
            weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
            multiplier = fourthChannel
                ? weight
                    ? 1 / weight
                    : 0
                : ratioWeightDivisor;
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
            if (fourthChannel) {
                outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            }
        }
    } while (outputOffset < this.finalResultSize);
    return outputBuffer;
};
Resize.prototype.resizeWidthInterpolatedRGB = function (buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, true);
};
Resize.prototype.resizeWidthRGB = function (buffer) {
    return this._resizeWidthRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthRGBA = function (buffer) {
    return this._resizeWidthRGBChannels(buffer, true);
};
Resize.prototype.resizeHeightInterpolated = function (buffer) {
    const ratioWeight = this.ratioWeightHeightPass;
    const outputBuffer = this.heightBuffer;
    let weight = 0;
    let finalOffset = 0;
    let pixelOffset = 0;
    let pixelOffsetAccumulated = 0;
    let pixelOffsetAccumulated2 = 0;
    let firstWeight = 0;
    let secondWeight = 0;
    let interpolationHeightSourceReadStop;
    // Handle for only one interpolation input being valid for start calculation:
    for (; weight < 1 / 3; weight += ratioWeight) {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
        }
    }
    // Adjust for overshoot of the last pass's counter:
    weight -= 1 / 3;
    for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
        // Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        // Interpolate:
        pixelOffsetAccumulated =
            Math.floor(weight) * this.targetWidthMultipliedByChannels;
        pixelOffsetAccumulated2 =
            pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight +
                buffer[pixelOffsetAccumulated2++] * secondWeight);
        }
    }
    // Handle for only one interpolation input being valid for end calculation:
    while (finalOffset < this.finalResultSize) {
        for (pixelOffset = 0,
            pixelOffsetAccumulated =
                interpolationHeightSourceReadStop *
                    this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
        }
    }
    return outputBuffer;
};
Resize.prototype.resizeHeightRGB = function (buffer) {
    return this._resizeHeightRGBChannels(buffer, false);
};
Resize.prototype.resizeHeightRGBA = function (buffer) {
    return this._resizeHeightRGBChannels(buffer, true);
};
Resize.prototype.resize = function (buffer) {
    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
};
Resize.prototype.bypassResizer = function (buffer) {
    // Just return the buffer passed:
    return buffer;
};
Resize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {
    // Initialize the internal width pass buffers:
    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
    if (!BILINEARAlgo) {
        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
        if (this.colorChannels > 3) {
            this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
        }
    }
};
Resize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {
    // Initialize the internal height pass buffers:
    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
    if (!BILINEARAlgo) {
        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
        if (this.colorChannels > 3) {
            this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
        }
    }
};
Resize.prototype.generateFloatBuffer = function (bufferLength) {
    // Generate a float32 typed array buffer:
    try {
        return new Float32Array(bufferLength);
    }
    catch (error) {
        console.error(error);
        return [];
    }
};
Resize.prototype.generateFloat64Buffer = function (bufferLength) {
    // Generate a float64 typed array buffer:
    try {
        return new Float64Array(bufferLength);
    }
    catch (error) {
        console.error(error);
        return [];
    }
};
Resize.prototype.generateUint8Buffer = function (bufferLength) {
    // Generate a uint8 typed array buffer:
    try {
        return new Uint8Array(bufferLength);
    }
    catch (error) {
        console.error(error);
        return [];
    }
};

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Copyright (c) 2015 Guyon Roche
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const operations = {
    nearestNeighbor(src, dst) {
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const bufSrc = src.data;
        const bufDst = dst.data;
        for (let i = 0; i < hDst; i++) {
            for (let j = 0; j < wDst; j++) {
                let posDst = (i * wDst + j) * 4;
                const iSrc = Math.floor((i * hSrc) / hDst);
                const jSrc = Math.floor((j * wSrc) / wDst);
                let posSrc = (iSrc * wSrc + jSrc) * 4;
                bufDst[posDst++] = bufSrc[posSrc++];
                bufDst[posDst++] = bufSrc[posSrc++];
                bufDst[posDst++] = bufSrc[posSrc++];
                bufDst[posDst++] = bufSrc[posSrc++];
            }
        }
    },
    bilinearInterpolation(src, dst) {
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const bufSrc = src.data;
        const bufDst = dst.data;
        const interpolate = function (k, kMin, vMin, kMax, vMax) {
            // special case - k is integer
            if (kMin === kMax) {
                return vMin;
            }
            return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
        };
        const assign = function (pos, offset, x, xMin, xMax, y, yMin, yMax) {
            let posMin = (yMin * wSrc + xMin) * 4 + offset;
            let posMax = (yMin * wSrc + xMax) * 4 + offset;
            const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
            // special case, y is integer
            if (yMax === yMin) {
                bufDst[pos + offset] = vMin;
            }
            else {
                posMin = (yMax * wSrc + xMin) * 4 + offset;
                posMax = (yMax * wSrc + xMax) * 4 + offset;
                const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
                bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
            }
        };
        for (let i = 0; i < hDst; i++) {
            for (let j = 0; j < wDst; j++) {
                const posDst = (i * wDst + j) * 4;
                // x & y in src coordinates
                const x = (j * wSrc) / wDst;
                const xMin = Math.floor(x);
                const xMax = Math.min(Math.ceil(x), wSrc - 1);
                const y = (i * hSrc) / hDst;
                const yMin = Math.floor(y);
                const yMax = Math.min(Math.ceil(y), hSrc - 1);
                assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
                assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
                assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
                assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
            }
        }
    },
    _interpolate2D(src, dst, options, interpolate) {
        const bufSrc = src.data;
        const bufDst = dst.data;
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares
        const wM = Math.max(1, Math.floor(wSrc / wDst));
        const wDst2 = wDst * wM;
        const hM = Math.max(1, Math.floor(hSrc / hDst));
        const hDst2 = hDst * hM;
        // ===========================================================
        // Pass 1 - interpolate rows
        // buf1 has width of dst2 and height of src
        const buf1 = Buffer.alloc(wDst2 * hSrc * 4);
        for (let i = 0; i < hSrc; i++) {
            for (let j = 0; j < wDst2; j++) {
                // i in src coords, j in dst coords
                // calculate x in src coords
                // this interpolation requires 4 sample points and the two inner ones must be real
                // the outer points can be fudged for the edges.
                // therefore (wSrc-1)/wDst2
                const x = (j * (wSrc - 1)) / wDst2;
                const xPos = Math.floor(x);
                const t = x - xPos;
                const srcPos = (i * wSrc + xPos) * 4;
                const buf1Pos = (i * wDst2 + j) * 4;
                for (let k = 0; k < 4; k++) {
                    const kPos = srcPos + k;
                    const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
                    const x1 = bufSrc[kPos];
                    const x2 = bufSrc[kPos + 4];
                    const x3 = xPos < wSrc - 2
                        ? bufSrc[kPos + 8]
                        : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
                    buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
                }
            }
        }
        // this._writeFile(wDst2, hSrc, buf1, "out/buf1.jpg");
        // ===========================================================
        // Pass 2 - interpolate columns
        // buf2 has width and height of dst2
        const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
        for (let i = 0; i < hDst2; i++) {
            for (let j = 0; j < wDst2; j++) {
                // i&j in dst2 coords
                // calculate y in buf1 coords
                // this interpolation requires 4 sample points and the two inner ones must be real
                // the outer points can be fudged for the edges.
                // therefore (hSrc-1)/hDst2
                const y = (i * (hSrc - 1)) / hDst2;
                const yPos = Math.floor(y);
                const t = y - yPos;
                const buf1Pos = (yPos * wDst2 + j) * 4;
                const buf2Pos = (i * wDst2 + j) * 4;
                for (let k = 0; k < 4; k++) {
                    const kPos = buf1Pos + k;
                    const y0 = yPos > 0
                        ? buf1[kPos - wDst2 * 4]
                        : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];
                    const y1 = buf1[kPos];
                    const y2 = buf1[kPos + wDst2 * 4];
                    const y3 = yPos < hSrc - 2
                        ? buf1[kPos + wDst2 * 8]
                        : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];
                    buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);
                }
            }
        }
        // this._writeFile(wDst2, hDst2, buf2, "out/buf2.jpg");
        // ===========================================================
        // Pass 3 - scale to dst
        const m = wM * hM;
        if (m > 1) {
            for (let i = 0; i < hDst; i++) {
                for (let j = 0; j < wDst; j++) {
                    // i&j in dst bounded coords
                    let r = 0;
                    let g = 0;
                    let b = 0;
                    let a = 0;
                    let realColors = 0;
                    for (let y = 0; y < hM; y++) {
                        const yPos = i * hM + y;
                        for (let x = 0; x < wM; x++) {
                            const xPos = j * wM + x;
                            const xyPos = (yPos * wDst2 + xPos) * 4;
                            const pixelAlpha = buf2[xyPos + 3];
                            if (pixelAlpha) {
                                r += buf2[xyPos];
                                g += buf2[xyPos + 1];
                                b += buf2[xyPos + 2];
                                realColors++;
                            }
                            a += pixelAlpha;
                        }
                    }
                    const pos = (i * wDst + j) * 4;
                    bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
                    bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
                    bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
                    bufDst[pos + 3] = Math.round(a / m);
                }
            }
        }
        else {
            // replace dst buffer with buf2
            dst.data = buf2;
        }
    },
    bicubicInterpolation(src, dst, options) {
        const interpolateCubic = function (x0, x1, x2, x3, t) {
            const a0 = x3 - x2 - x0 + x1;
            const a1 = x0 - x1 - a0;
            const a2 = x2 - x0;
            const a3 = x1;
            return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
        };
        return this._interpolate2D(src, dst, options, interpolateCubic);
    },
    hermiteInterpolation(src, dst, options) {
        const interpolateHermite = function (x0, x1, x2, x3, t) {
            const c0 = x1;
            const c1 = 0.5 * (x2 - x0);
            const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
            const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
            return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
        };
        return this._interpolate2D(src, dst, options, interpolateHermite);
    },
    bezierInterpolation(src, dst, options) {
        // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)
        // to predict control points (a & b) to be placed at n+0.5
        //  ya(n) = y(n) + (y(n+1)-y(n-1))/4
        //  yb(n) = y(n+1) - (y(n+2)-y(n))/4
        // then use std bezier to interpolate [n,n+1)
        //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3
        //  note the 3* factor for the two control points
        // for edge cases, can choose:
        //  y(-1) = y(0) - 2*(y(1)-y(0))
        //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))
        // but can go with y(-1) = y(0) and y(w) = y(w-1)
        const interpolateBezier = function (x0, x1, x2, x3, t) {
            // x1, x2 are the knots, use x0 and x3 to calculate control points
            const cp1 = x1 + (x2 - x0) / 4;
            const cp2 = x2 - (x3 - x1) / 4;
            const nt = 1 - t;
            const c0 = x1 * nt * nt * nt;
            const c1 = 3 * cp1 * nt * nt * t;
            const c2 = 3 * cp2 * nt * t * t;
            const c3 = x2 * t * t * t;
            return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
        };
        return this._interpolate2D(src, dst, options, interpolateBezier);
    },
};

const ResizeOptionsSchema = unionType([
    objectType({
        /** the width to resize the image to */
        w: numberType().min(0),
        /** the height to resize the image to */
        h: numberType().min(0).optional(),
        /** a scaling method (e.g. ResizeStrategy.BEZIER) */
        mode: nativeEnumType(ResizeStrategy).optional(),
    }),
    objectType({
        /** the width to resize the image to */
        w: numberType().min(0).optional(),
        /** the height to resize the image to */
        h: numberType().min(0),
        /** a scaling method (e.g. ResizeStrategy.BEZIER) */
        mode: nativeEnumType(ResizeStrategy).optional(),
    }),
]);
const ScaleToFitOptionsSchema = objectType({
    /** the width to resize the image to */
    w: numberType().min(0),
    /** the height to resize the image to */
    h: numberType().min(0),
    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const ScaleComplexOptionsSchema = objectType({
    /** the width to resize the image to */
    f: numberType().min(0),
    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const methods$d = {
    /**
     * Resizes the image to a set width and height using a 2-pass bilinear algorithm
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.resize({ w: 150 });
     * ```
     */
    resize(image, options) {
        const { mode } = ResizeOptionsSchema.parse(options);
        let w;
        let h;
        if (typeof options.w === "number") {
            w = options.w;
            h = options.h ?? image.bitmap.height * (w / image.bitmap.width);
        }
        else if (typeof options.h === "number") {
            h = options.h;
            w = options.w ?? image.bitmap.width * (h / image.bitmap.height);
        }
        else {
            throw new Error("w must be a number");
        }
        // round inputs
        w = Math.round(w) || 1;
        h = Math.round(h) || 1;
        if (mode && typeof operations[mode] === "function") {
            const dst = {
                data: Buffer.alloc(w * h * 4),
                width: w,
                height: h,
            };
            operations[mode](image.bitmap, dst);
            image.bitmap = dst;
        }
        else {
            const resize = new Resize(image.bitmap.width, image.bitmap.height, w, h, true, true, (buffer) => {
                image.bitmap.data = Buffer.from(buffer);
                image.bitmap.width = w;
                image.bitmap.height = h;
            });
            resize.resize(image.bitmap.data);
        }
        return image;
    },
    /**
     * Uniformly scales the image by a factor.
     * @param f the factor to scale the image by
     * @param mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.scale(0.5);
     * ```
     */
    scale(image, options) {
        const { f, mode } = typeof options === "number"
            ? { f: options }
            : ScaleComplexOptionsSchema.parse(options);
        const w = image.bitmap.width * f;
        const h = image.bitmap.height * f;
        return this.resize(image, { w, h, mode: mode });
    },
    /**
     * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
     * @param w the width to resize the image to
     * @param h the height to resize the image to
     * @param mode a scaling method (e.g. ResizeStrategy.BEZIER)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.scaleToFit(100, 100);
     * ```
     */
    scaleToFit(image, options) {
        const { h, w, mode } = ScaleToFitOptionsSchema.parse(options);
        const f = w / h > image.bitmap.width / image.bitmap.height
            ? h / image.bitmap.height
            : w / image.bitmap.width;
        return this.scale(image, { f, mode: mode });
    },
};

const ContainOptionsSchema = objectType({
    /** the width to resize the image to */
    w: numberType(),
    /** the height to resize the image to */
    h: numberType(),
    /** A bitmask for horizontal and vertical alignment */
    align: numberType().optional(),
    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const methods$c = {
    /**
     * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.
     * @param w the width to resize the image to
     * @param h the height to resize the image to
     * @param align A bitmask for horizontal and vertical alignment
     * @param mode a scaling method (e.g. Jimp.RESIZE_BEZIER)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.contain({ w: 150, h: 100 });
     * ```
     */
    contain(image, options) {
        const { w, h, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode, } = ContainOptionsSchema.parse(options);
        const hbits = align & ((1 << 3) - 1);
        const vbits = align >> 3;
        // check if more flags than one is in the bit sets
        if (!((hbits !== 0 && !(hbits & (hbits - 1))) ||
            (vbits !== 0 && !(vbits & (vbits - 1))))) {
            throw new Error("only use one flag per alignment direction");
        }
        const alignH = hbits >> 1; // 0, 1, 2
        const alignV = vbits >> 1; // 0, 1, 2
        const f = w / h > image.bitmap.width / image.bitmap.height
            ? h / image.bitmap.height
            : w / image.bitmap.width;
        const c = methods$d.scale(clone(image), { f, mode });
        image = methods$d.resize(image, { w, h, mode });
        image.scan((_, __, idx) => {
            image.bitmap.data.writeUInt32BE(image.background, idx);
        });
        image = methods$h.blit(image, {
            src: c,
            x: ((image.bitmap.width - c.bitmap.width) / 2) * alignH,
            y: ((image.bitmap.height - c.bitmap.height) / 2) * alignV,
        });
        return image;
    },
};

const CropOptionsSchema = objectType({
    /** the x position to crop form */
    x: numberType(),
    /** the y position to crop form */
    y: numberType(),
    /** the width to crop form */
    w: numberType(),
    /** the height to crop form */
    h: numberType(),
});
const AutocropComplexOptionsSchema = objectType({
    /** percent of color difference tolerance (default value) */
    tolerance: numberType().min(0).max(1).optional(),
    /** flag to force cropping only if the image has a real "frame" i.e. all 4 sides have some border (default value) */
    cropOnlyFrames: booleanType().optional(),
    /** force cropping top be symmetric */
    cropSymmetric: booleanType().optional(),
    /** Amount of pixels in border to leave */
    leaveBorder: numberType().optional(),
    ignoreSides: objectType({
        north: booleanType().optional(),
        south: booleanType().optional(),
        east: booleanType().optional(),
        west: booleanType().optional(),
    })
        .optional(),
});
const methods$b = {
    /**
     * Crops the image at a given point to a give size.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const cropped = image.crop(150, 100);
     * ```
     */
    crop(image, options) {
        let { x, y, w, h } = CropOptionsSchema.parse(options);
        // round input
        x = Math.round(x);
        y = Math.round(y);
        w = Math.round(w);
        h = Math.round(h);
        if (x === 0 && w === image.bitmap.width) {
            // shortcut
            const start = (w * y + x) << 2;
            const end = start + ((h * w) << 2);
            image.bitmap.data = image.bitmap.data.slice(start, end);
        }
        else {
            const bitmap = Buffer.allocUnsafe(w * h * 4);
            let offset = 0;
            scan(image, x, y, w, h, function (_, __, idx) {
                const data = image.bitmap.data.readUInt32BE(idx);
                bitmap.writeUInt32BE(data, offset);
                offset += 4;
            });
            image.bitmap.data = bitmap;
        }
        image.bitmap.width = w;
        image.bitmap.height = h;
        return image;
    },
    /**
     * Autocrop same color borders from this image.
     * This function will attempt to crop out transparent pixels from the image.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const cropped = image.autocrop();
     * ```
     */
    autocrop(image, options = {}) {
        const { tolerance = 0.0002, cropOnlyFrames = true, cropSymmetric = false, leaveBorder = 0, ignoreSides: ignoreSidesArg, } = typeof options === "number"
            ? { tolerance: options }
            : AutocropComplexOptionsSchema.parse(options);
        const w = image.bitmap.width;
        const h = image.bitmap.height;
        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image
        // i.e. north and south / east and west are cropped by the same value
        const ignoreSides = {
            north: false,
            south: false,
            east: false,
            west: false,
            ...ignoreSidesArg,
        };
        /**
         * All borders must be of the same color as the top left pixel, to be cropped.
         * It should be possible to crop borders each with a different color,
         * but since there are many ways for corners to intersect, it would
         * introduce unnecessary complexity to the algorithm.
         */
        // scan each side for same color borders
        let colorTarget = image.getPixelColor(0, 0); // top left pixel color is the target color
        const rgba1 = intToRGBA$1(colorTarget);
        // for north and east sides
        let northPixelsToCrop = 0;
        let eastPixelsToCrop = 0;
        let southPixelsToCrop = 0;
        let westPixelsToCrop = 0;
        // north side (scan rows from north to south)
        colorTarget = image.getPixelColor(0, 0);
        if (!ignoreSides.north) {
            north: for (let y = 0; y < h - minPixelsPerSide; y++) {
                for (let x = 0; x < w; x++) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break north;
                    }
                }
                // this row contains all pixels with the same color: increment this side pixels to crop
                northPixelsToCrop++;
            }
        }
        // west side (scan columns from west to east)
        colorTarget = image.getPixelColor(w, 0);
        if (!ignoreSides.west) {
            west: for (let x = 0; x < w - minPixelsPerSide; x++) {
                for (let y = 0 + northPixelsToCrop; y < h; y++) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break west;
                    }
                }
                // this column contains all pixels with the same color: increment this side pixels to crop
                westPixelsToCrop++;
            }
        }
        // south side (scan rows from south to north)
        colorTarget = image.getPixelColor(0, h);
        if (!ignoreSides.south) {
            south: for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {
                for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break south;
                    }
                }
                // this row contains all pixels with the same color: increment this side pixels to crop
                southPixelsToCrop++;
            }
        }
        // east side (scan columns from east to west)
        colorTarget = image.getPixelColor(w, h);
        if (!ignoreSides.east) {
            east: for (let x = w - 1; x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {
                for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break east;
                    }
                }
                // this column contains all pixels with the same color: increment this side pixels to crop
                eastPixelsToCrop++;
            }
        }
        // decide if a crop is needed
        let doCrop = false;
        // apply leaveBorder
        westPixelsToCrop -= leaveBorder;
        eastPixelsToCrop -= leaveBorder;
        northPixelsToCrop -= leaveBorder;
        southPixelsToCrop -= leaveBorder;
        if (cropSymmetric) {
            const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
            const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
            westPixelsToCrop = horizontal;
            eastPixelsToCrop = horizontal;
            northPixelsToCrop = vertical;
            southPixelsToCrop = vertical;
        }
        // make sure that crops are >= 0
        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
        // safety checks
        const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
        const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
        if (cropOnlyFrames) {
            // crop image if all sides should be cropped
            doCrop =
                eastPixelsToCrop !== 0 &&
                    northPixelsToCrop !== 0 &&
                    westPixelsToCrop !== 0 &&
                    southPixelsToCrop !== 0;
        }
        else {
            // crop image if at least one side should be cropped
            doCrop =
                eastPixelsToCrop !== 0 ||
                    northPixelsToCrop !== 0 ||
                    westPixelsToCrop !== 0 ||
                    southPixelsToCrop !== 0;
        }
        if (doCrop) {
            // do the real crop
            this.crop(image, {
                x: westPixelsToCrop,
                y: northPixelsToCrop,
                w: widthOfRemainingPixels,
                h: heightOfRemainingPixels,
            });
        }
        return image;
    },
};

const CoverOptionsSchema = objectType({
    /** the width to resize the image to */
    w: numberType(),
    /** the height to resize the image to */
    h: numberType(),
    /** A bitmask for horizontal and vertical alignment */
    align: numberType().optional(),
    /** a scaling method (e.g. ResizeStrategy.BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const methods$a = {
    /**
     * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.cover(150, 100);
     * ```
     */
    cover(image, options) {
        const { w, h, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode, } = CoverOptionsSchema.parse(options);
        const hbits = align & ((1 << 3) - 1);
        const vbits = align >> 3;
        // check if more flags than one is in the bit sets
        if (!((hbits !== 0 && !(hbits & (hbits - 1))) ||
            (vbits !== 0 && !(vbits & (vbits - 1))))) {
            throw new Error("only use one flag per alignment direction");
        }
        const alignH = hbits >> 1; // 0, 1, 2
        const alignV = vbits >> 1; // 0, 1, 2
        const f = w / h > image.bitmap.width / image.bitmap.height
            ? w / image.bitmap.width
            : h / image.bitmap.height;
        image = methods$d.scale(image, {
            f,
            mode,
        });
        image = methods$b.crop(image, {
            x: ((image.bitmap.width - w) / 2) * alignH,
            y: ((image.bitmap.height - h) / 2) * alignV,
            w,
            h,
        });
        return image;
    },
};

const DisplaceOptionsSchema = objectType({
    /** the source Jimp instance */
    map: JimpClassSchema,
    /** the maximum displacement value */
    offset: numberType(),
});
const methods$9 = {
    /**
     * Displaces the image based on the provided displacement map
     * @param map the source Jimp instance
     * @param offset
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const map = await Jimp.read("test/map.png");
     *
     * image.displace(map, 10);
     * ```
     */
    displace(image, options) {
        const { map, offset } = DisplaceOptionsSchema.parse(options);
        const source = clone(image);
        image.scan((x, y, idx) => {
            let displacement = (map.bitmap.data[idx] / 256) * offset;
            displacement = Math.round(displacement);
            const ids = image.getPixelIndex(x + displacement, y);
            image.bitmap.data[ids] = source.bitmap.data[idx];
            image.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
            image.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
        });
        return image;
    },
};

const methods$8 = {
    /**
     * Apply a ordered dithering effect.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.dither();
     * ```
     */
    dither(image) {
        const rgb565Matrix = [
            1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6,
        ];
        image.scan((x, y, idx) => {
            const thresholdId = ((y & 3) << 2) + (x % 4);
            const dither = rgb565Matrix[thresholdId];
            image.bitmap.data[idx] = Math.min(image.bitmap.data[idx] + dither, 0xff);
            image.bitmap.data[idx + 1] = Math.min(image.bitmap.data[idx + 1] + dither, 0xff);
            image.bitmap.data[idx + 2] = Math.min(image.bitmap.data[idx + 2] + dither, 0xff);
        });
        return image;
    },
};

const FisheyeOptionsSchema = objectType({
    /** the radius of the circle */
    radius: numberType().min(0).optional(),
});
const methods$7 = {
    /**
     * Adds a fisheye effect to the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.fisheye();
     * ```
     */
    fisheye(image, options = {}) {
        const { radius = 2.5 } = FisheyeOptionsSchema.parse(options);
        const source = clone(image);
        const { width, height } = source.bitmap;
        source.scan((x, y) => {
            const hx = x / width;
            const hy = y / height;
            const rActual = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
            const rn = 2 * Math.pow(rActual, radius);
            const cosA = (hx - 0.5) / rActual;
            const sinA = (hy - 0.5) / rActual;
            const newX = Math.round((rn * cosA + 0.5) * width);
            const newY = Math.round((rn * sinA + 0.5) * height);
            const color = source.getPixelColor(newX, newY);
            image.setPixelColor(color, x, y);
        });
        /* Set center pixel color, otherwise it will be transparent */
        image.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
        return image;
    },
};

const FlipOptionsSchema = objectType({
    /** if true the image will be flipped horizontally */
    horizontal: booleanType().optional(),
    /** if true the image will be flipped vertically */
    vertical: booleanType().optional(),
});
const methods$6 = {
    /**
     * Flip the image.
     * @param horizontal a Boolean, if true the image will be flipped horizontally
     * @param vertical a Boolean, if true the image will be flipped vertically
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.flip(true, false);
     * ```
     */
    flip(image, options) {
        const { horizontal, vertical } = FlipOptionsSchema.parse(options);
        const bitmap = Buffer.alloc(image.bitmap.data.length);
        image.scan((x, y, idx) => {
            const _x = horizontal ? image.bitmap.width - 1 - x : x;
            const _y = vertical ? image.bitmap.height - 1 - y : y;
            const _idx = (image.bitmap.width * _y + _x) << 2;
            const data = image.bitmap.data.readUInt32BE(idx);
            bitmap.writeUInt32BE(data, _idx);
        });
        image.bitmap.data = Buffer.from(bitmap);
        return image;
    },
};

var converter;
var hasRequiredConverter;

function requireConverter () {
	if (hasRequiredConverter) return converter;
	hasRequiredConverter = 1;

	/**
	 * Converter
	 *
	 * @param {string|Array} srcAlphabet
	 * @param {string|Array} dstAlphabet
	 * @constructor
	 */
	function Converter(srcAlphabet, dstAlphabet) {
	    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
	        throw new Error('Bad alphabet');
	    }
	    this.srcAlphabet = srcAlphabet;
	    this.dstAlphabet = dstAlphabet;
	}

	/**
	 * Convert number from source alphabet to destination alphabet
	 *
	 * @param {string|Array} number - number represented as a string or array of points
	 *
	 * @returns {string|Array}
	 */
	Converter.prototype.convert = function(number) {
	    var i, divide, newlen,
	    numberMap = {},
	    fromBase = this.srcAlphabet.length,
	    toBase = this.dstAlphabet.length,
	    length = number.length,
	    result = typeof number === 'string' ? '' : [];

	    if (!this.isValid(number)) {
	        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
	    }

	    if (this.srcAlphabet === this.dstAlphabet) {
	        return number;
	    }

	    for (i = 0; i < length; i++) {
	        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
	    }
	    do {
	        divide = 0;
	        newlen = 0;
	        for (i = 0; i < length; i++) {
	            divide = divide * fromBase + numberMap[i];
	            if (divide >= toBase) {
	                numberMap[newlen++] = parseInt(divide / toBase, 10);
	                divide = divide % toBase;
	            } else if (newlen > 0) {
	                numberMap[newlen++] = 0;
	            }
	        }
	        length = newlen;
	        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
	    } while (newlen !== 0);

	    return result;
	};

	/**
	 * Valid number with source alphabet
	 *
	 * @param {number} number
	 *
	 * @returns {boolean}
	 */
	Converter.prototype.isValid = function(number) {
	    var i = 0;
	    for (; i < number.length; ++i) {
	        if (this.srcAlphabet.indexOf(number[i]) === -1) {
	            return false;
	        }
	    }
	    return true;
	};

	converter = Converter;
	return converter;
}

var anyBase_1;
var hasRequiredAnyBase;

function requireAnyBase () {
	if (hasRequiredAnyBase) return anyBase_1;
	hasRequiredAnyBase = 1;
	var Converter = requireConverter();

	/**
	 * Function get source and destination alphabet and return convert function
	 *
	 * @param {string|Array} srcAlphabet
	 * @param {string|Array} dstAlphabet
	 *
	 * @returns {function(number|Array)}
	 */
	function anyBase(srcAlphabet, dstAlphabet) {
	    var converter = new Converter(srcAlphabet, dstAlphabet);
	    /**
	     * Convert function
	     *
	     * @param {string|Array} number
	     *
	     * @return {string|Array} number
	     */
	    return function (number) {
	        return converter.convert(number);
	    }
	}
	anyBase.BIN = '01';
	anyBase.OCT = '01234567';
	anyBase.DEC = '0123456789';
	anyBase.HEX = '0123456789abcdef';

	anyBase_1 = anyBase;
	return anyBase_1;
}

var anyBaseExports = requireAnyBase();
const anyBase = /*@__PURE__*/getDefaultExportFromCjs(anyBaseExports);

/*
Copyright (c) 2011 Elliot Shepherd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
// https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java
/*
 * pHash-like image hash.
 * Author: Elliot Shepherd (elliot@jarofworms.com
 * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html
 */
class ImagePHash {
    size;
    smallerSize;
    constructor(size, smallerSize) {
        this.size = size || 32;
        this.smallerSize = smallerSize || 8;
        initCoefficients(this.size);
    }
    distance(s1, s2) {
        let counter = 0;
        for (let k = 0; k < s1.length; k++) {
            if (s1[k] !== s2[k]) {
                counter++;
            }
        }
        return counter / s1.length;
    }
    /**
     * Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.
     */
    getHash(img) {
        /* 1. Reduce size.
         * Like Average Hash, pHash starts with a small image.
         * However, the image is larger than 8x8; 32x32 is a good size.
         * This is really done to simplify the DCT computation and not
         * because it is needed to reduce the high frequencies.
         */
        img = methods$d.resize(clone(img), { w: this.size, h: this.size });
        /* 2. Reduce color.
         * The image is reduced to a grayscale just to further simplify
         * the number of computations.
         */
        img = methods$e.greyscale(img);
        const vals = [];
        for (let x = 0; x < img.bitmap.width; x++) {
            const row = [];
            for (let y = 0; y < img.bitmap.height; y++) {
                row[y] = intToRGBA(img.getPixelColor(x, y)).b;
            }
            vals[x] = row;
        }
        /* 3. Compute the DCT.
         * The DCT separates the image into a collection of frequencies
         * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses
         * a 32x32 DCT.
         */
        const dctVals = applyDCT(vals, this.size);
        /* 4. Reduce the DCT.
         * This is the magic step. While the DCT is 32x32, just keep the
         * top-left 8x8. Those represent the lowest frequencies in the
         * picture.
         */
        /* 5. Compute the average value.
         * Like the Average Hash, compute the mean DCT value (using only
         * the 8x8 DCT low-frequency values and excluding the first term
         * since the DC coefficient can be significantly different from
         * the other values and will throw off the average).
         */
        let total = 0;
        for (let x = 0; x < this.smallerSize; x++) {
            for (let y = 0; y < this.smallerSize; y++) {
                total += dctVals[x][y];
            }
        }
        const avg = total / (this.smallerSize * this.smallerSize);
        /* 6. Further reduce the DCT.
         * This is the magic step. Set the 64 hash bits to 0 or 1
         * depending on whether each of the 64 DCT values is above or
         * below the average value. The result doesn't tell us the
         * actual low frequencies; it just tells us the very-rough
         * relative scale of the frequencies to the mean. The result
         * will not vary as long as the overall structure of the image
         * remains the same; this can survive gamma and color histogram
         * adjustments without a problem.
         */
        let hash = "";
        for (let x = 0; x < this.smallerSize; x++) {
            for (let y = 0; y < this.smallerSize; y++) {
                hash += dctVals[x][y] > avg ? "1" : "0";
            }
        }
        return hash;
    }
}
// DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java
/**
 Convert a 32-bit integer color value to an RGBA object.
 */
function intToRGBA(i) {
    const a = i & 0xff;
    i >>>= 8;
    const b = i & 0xff;
    i >>>= 8;
    const g = i & 0xff;
    i >>>= 8;
    const r = i & 0xff;
    return { r, g, b, a };
}
const c = [];
function initCoefficients(size) {
    for (let i = 1; i < size; i++) {
        c[i] = 1;
    }
    c[0] = 1 / Math.sqrt(2.0);
}
function applyDCT(f, size) {
    const N = size;
    const F = [];
    for (let u = 0; u < N; u++) {
        const row = [];
        for (let v = 0; v < N; v++) {
            let sum = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    sum +=
                        Math.cos(((2 * i + 1) / (2.0 * N)) * u * Math.PI) *
                            Math.cos(((2 * j + 1) / (2.0 * N)) * v * Math.PI) *
                            f[i][j];
                }
            }
            sum *= (c[u] * c[v]) / 4;
            row[v] = sum;
            F[u] = row;
        }
    }
    return F;
}

// an array storing the maximum string length of hashes at various bases
// 0 and 1 do not exist as possible hash lengths
// prettier-ignore
const alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
// an array storing the maximum string length of hashes at various bases
// 0 and 1 do not exist as possible hash lengths
const maxHashLength = [NaN, NaN];
for (let i = 2; i < 65; i++) {
    const maxHash = anyBase(anyBase.BIN, alphabet.slice(0, i))(new Array(64 + 1).join("1"));
    maxHashLength.push(maxHash.length);
}
const methods$5 = {
    /**
     * Calculates the perceptual hash
     * @returns the perceptual hash
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.hash();
     * ```
     */
    pHash(image) {
        const pHash = new ImagePHash();
        return pHash.getHash(image);
    },
    /**
     * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
     * @param base A number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.hash(2); // binary
     * image.hash(64); // base 64
     * ```
     */
    hash(image, base = 64) {
        if (base < 2 || base > 64) {
            throw new Error("base must be a number between 2 and 64");
        }
        const subAlphabet = alphabet.slice(0, base);
        const pHash = this.pHash(image);
        const maxLength = maxHashLength[base];
        return anyBase(anyBase.BIN, subAlphabet)(pHash).padStart(maxLength, "0");
    },
    /**
     * Calculates the hamming distance of the current image and a hash based on their perceptual hash
     * @param compareHash hash to compare to
     * @returns  a number ranging from 0 to 1, 0 means they are believed to be identical
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.distanceFromHash(image.pHash());
     * ```
     */
    distanceFromHash(image, compareHash) {
        const pHash = new ImagePHash();
        const currentHash = pHash.getHash(image);
        return pHash.distance(currentHash, compareHash);
    },
};

const MaskOptionsObjectSchema = objectType({
    src: JimpClassSchema,
    /** the x position to draw the image */
    x: numberType().optional(),
    /** the y position to draw the image */
    y: numberType().optional(),
});
const MaskOptionsSchema = unionType([JimpClassSchema, MaskOptionsObjectSchema]);
const methods$4 = {
    /**
     * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.
     * @param src the source Jimp instance
     * @param x the horizontal position to blit the image
     * @param y the vertical position to blit the image
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const mask = await Jimp.read("test/mask.png");
     *
     * image.mask(mask);
     * ```
     */
    mask(image, options) {
        MaskOptionsSchema.parse(options);
        let src;
        let x;
        let y;
        if ("bitmap" in options) {
            src = options;
            x = 0;
            y = 0;
        }
        else {
            src = options.src;
            x = options.x ?? 0;
            y = options.y ?? 0;
        }
        // round input
        x = Math.round(x);
        y = Math.round(y);
        const w = image.bitmap.width;
        const h = image.bitmap.height;
        src.scan(function (sx, sy, idx) {
            const destX = x + sx;
            const destY = y + sy;
            if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
                const dstIdx = image.getPixelIndex(destX, destY);
                const { data } = src.bitmap;
                const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
                image.bitmap.data[dstIdx + 3] *= avg / 255;
            }
        });
        return image;
    },
};

function measureText(font, text) {
    let x = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const fontChar = font.chars[char];
        if (fontChar) {
            const fontKerning = font.kernings[char];
            const nextChar = text[i + 1];
            const kerning = fontKerning && nextChar && fontKerning[nextChar]
                ? fontKerning[nextChar] || 0
                : 0;
            x += (fontChar.xadvance || 0) + kerning;
        }
    }
    return x;
}
function splitLines(font, text, maxWidth) {
    const words = text.replace(/[\r\n]+/g, " \n").split(" ");
    const lines = [];
    let currentLine = [];
    let longestLine = 0;
    words.forEach((word) => {
        const wordWidth = measureText(font, word + (words.length > 1 ? " " : ""));
        // If a word is longer than the allowable width we need to split it across lines.
        if (wordWidth > maxWidth) {
            const characterIterator = word[Symbol.iterator]();
            let current = "";
            for (const char of characterIterator) {
                const nextLine = [...currentLine, current + char].join(" ");
                const length = measureText(font, nextLine);
                if (length < maxWidth) {
                    current += char;
                }
                else if (length > maxWidth) {
                    lines.push([...currentLine, current]);
                    currentLine = [];
                    current = char;
                }
                else {
                    lines.push([...currentLine, current + char]);
                    currentLine = [];
                    current = "";
                }
            }
            return;
        }
        const line = [...currentLine, word].join(" ");
        const length = measureText(font, line);
        if (length <= maxWidth && !word.includes("\n")) {
            if (length > longestLine) {
                longestLine = length;
            }
            currentLine.push(word);
        }
        else {
            lines.push(currentLine);
            currentLine = [word.replace("\n", "")];
        }
    });
    lines.push(currentLine);
    return {
        lines,
        longestLine,
    };
}
function measureTextHeight(font, text, maxWidth) {
    const { lines } = splitLines(font, text, maxWidth);
    return lines.length * font.common.lineHeight;
}

const PrintOptionsSchema = objectType({
    /** the x position to draw the image */
    x: numberType(),
    /** the y position to draw the image */
    y: numberType(),
    /** the text to print */
    text: unionType([
        unionType([stringType(), numberType()]),
        objectType({
            text: unionType([stringType(), numberType()]),
            alignmentX: nativeEnumType(HorizontalAlign).optional(),
            alignmentY: nativeEnumType(VerticalAlign).optional(),
        }),
    ]),
    /** the boundary width to draw in */
    maxWidth: numberType().optional(),
    /** the boundary height to draw in */
    maxHeight: numberType().optional(),
    /** a callback for when complete that ahs the end co-ordinates of the text */
    cb: functionType(tupleType([objectType({ x: numberType(), y: numberType() })]))
        .optional(),
});
function xOffsetBasedOnAlignment(font, line, maxWidth, alignment) {
    if (alignment === HorizontalAlign.LEFT) {
        return 0;
    }
    if (alignment === HorizontalAlign.CENTER) {
        return (maxWidth - measureText(font, line)) / 2;
    }
    return maxWidth - measureText(font, line);
}
function drawCharacter(image, font, x, y, char) {
    if (char.width > 0 && char.height > 0) {
        const characterPage = font.pages[char.page];
        if (characterPage) {
            image = methods$h.blit(image, {
                src: characterPage,
                x: x + char.xoffset,
                y: y + char.yoffset,
                srcX: char.x,
                srcY: char.y,
                srcW: char.width,
                srcH: char.height,
            });
        }
    }
    return image;
}
function printText(image, font, x, y, text, defaultCharWidth) {
    for (let i = 0; i < text.length; i++) {
        const stringChar = text[i];
        let char;
        if (font.chars[stringChar]) {
            char = stringChar;
        }
        else if (/\s/.test(stringChar)) {
            char = "";
        }
        else {
            char = "?";
        }
        const fontChar = font.chars[char] || { xadvance: undefined };
        const fontKerning = font.kernings[char];
        if (fontChar) {
            drawCharacter(image, font, x, y, fontChar);
        }
        const nextChar = text[i + 1];
        const kerning = fontKerning && nextChar && fontKerning[nextChar]
            ? fontKerning[nextChar] || 0
            : 0;
        x += kerning + (fontChar.xadvance || defaultCharWidth);
    }
}
const methods$3 = {
    /**
     * Draws a text on a image on a given boundary
     * @param font a bitmap font loaded from `Jimp.loadFont` command
     * @param x the x position to start drawing the text
     * @param y the y position to start drawing the text
     * @param text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const font = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK);
     *
     * image.print({ font, x: 10, y: 10, text: "Hello world!" });
     * ```
     */
    print(image, { font, ...options }) {
        let { 
        // eslint-disable-next-line prefer-const
        x, y, text, 
        // eslint-disable-next-line prefer-const
        maxWidth = Infinity, 
        // eslint-disable-next-line prefer-const
        maxHeight = Infinity, 
        // eslint-disable-next-line prefer-const
        cb = () => { }, } = PrintOptionsSchema.parse(options);
        let alignmentX;
        let alignmentY;
        if (typeof text === "object" &&
            text.text !== null &&
            text.text !== undefined) {
            alignmentX = text.alignmentX || HorizontalAlign.LEFT;
            alignmentY = text.alignmentY || VerticalAlign.TOP;
            ({ text } = text);
        }
        else {
            alignmentX = HorizontalAlign.LEFT;
            alignmentY = VerticalAlign.TOP;
            text = text.toString();
        }
        if (typeof text === "number") {
            text = text.toString();
        }
        if (maxHeight !== Infinity && alignmentY === VerticalAlign.BOTTOM) {
            y += maxHeight - measureTextHeight(font, text, maxWidth);
        }
        else if (maxHeight !== Infinity && alignmentY === VerticalAlign.MIDDLE) {
            y += maxHeight / 2 - measureTextHeight(font, text, maxWidth) / 2;
        }
        const defaultCharWidth = Object.entries(font.chars).find((c) => c[1].xadvance)?.[1].xadvance;
        if (typeof defaultCharWidth !== "number") {
            throw new Error("Could not find default character width");
        }
        const { lines, longestLine } = splitLines(font, text, maxWidth);
        lines.forEach((line) => {
            const lineString = line.join(" ");
            const alignmentWidth = xOffsetBasedOnAlignment(font, lineString, maxWidth, alignmentX);
            printText(image, font, x + alignmentWidth, y, lineString, defaultCharWidth);
            y += font.common.lineHeight;
        });
        cb.bind(image)({ x: x + longestLine, y });
        return image;
    },
};

const RotateOptionsSchema = unionType([
    numberType(),
    objectType({
        /** the number of degrees to rotate the image by */
        deg: numberType(),
        /** resize mode or a boolean, if false then the width and height of the image will not be changed */
        mode: unionType([booleanType(), nativeEnumType(ResizeStrategy)]).optional(),
    }),
]);
/** function to translate the x, y coordinate to the index of the pixel in the buffer */
function createIdxTranslationFunction(w) {
    return function (x, y) {
        return (y * w + x) << 2;
    };
}
/**
 * Rotates an image counter-clockwise by multiple of 90 degrees. NB: 'this' must be a Jimp object.
 *
 * This function is based on matrix rotation. Check this to get an initial idea how it works: https://stackoverflow.com/a/8664879/10561909
 *
 * @param deg the number of degrees to rotate the image by, it should be a multiple of 90
 */
function matrixRotate(image, deg) {
    if (Math.abs(deg) % 90 !== 0) {
        throw new Error("Unsupported matrix rotation degree");
    }
    const w = image.bitmap.width;
    const h = image.bitmap.height;
    // decide which rotation angle to use
    let angle;
    switch (deg) {
        // 90 degree & -270 degree are same
        case 90:
        case -270:
            angle = 90;
            break;
        case 180:
        case -180:
            angle = 180;
            break;
        case 270:
        case -90:
            angle = -90;
            break;
        default:
            throw new Error("Unsupported matrix rotation degree");
    }
    // After this switch block, angle will be 90, 180 or -90
    // calculate the new width and height
    const nW = angle === 180 ? w : h;
    const nH = angle === 180 ? h : w;
    const dstBuffer = Buffer.alloc(image.bitmap.data.length);
    const srcIdxFunction = createIdxTranslationFunction(w);
    const dstIdxFunction = createIdxTranslationFunction(nW);
    for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
            const srcIdx = srcIdxFunction(x, y);
            const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);
            let dstIdx;
            switch (angle) {
                case 90:
                    dstIdx = dstIdxFunction(y, w - x - 1);
                    break;
                case -90:
                    dstIdx = dstIdxFunction(h - y - 1, x);
                    break;
                case 180:
                    dstIdx = dstIdxFunction(w - x - 1, h - y - 1);
                    break;
                default:
                    throw new Error("Unsupported matrix rotation angle");
            }
            dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
        }
    }
    image.bitmap.data = dstBuffer;
    image.bitmap.width = nW;
    image.bitmap.height = nH;
}
function createTranslationFunction(deltaX, deltaY) {
    return function (x, y) {
        return {
            x: x + deltaX,
            y: y + deltaY,
        };
    };
}
/**
 * Rotates an image counter-clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.
 * @param {number} deg the number of degrees to rotate the image by
 */
function advancedRotate(image, deg, mode) {
    const rad = (deg * Math.PI) / 180;
    const cosine = Math.cos(rad);
    const sine = Math.sin(rad);
    // the final width and height will change if resize == true
    let w = image.bitmap.width;
    let h = image.bitmap.height;
    if (mode === true || typeof mode === "string") {
        // resize the image to it maximum dimension and blit the existing image
        // onto the center so that when it is rotated the image is kept in bounds
        // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle
        // Plus 1 border pixel to ensure to show all rotated result for some cases.
        w =
            Math.ceil(Math.abs(image.bitmap.width * cosine) +
                Math.abs(image.bitmap.height * sine)) + 1;
        h =
            Math.ceil(Math.abs(image.bitmap.width * sine) +
                Math.abs(image.bitmap.height * cosine)) + 1;
        // Ensure destination to have even size to a better result.
        if (w % 2 !== 0) {
            w++;
        }
        if (h % 2 !== 0) {
            h++;
        }
        const c = clone(image);
        image.scan((_, __, idx) => {
            image.bitmap.data.writeUInt32BE(image.background, idx);
        });
        const max = Math.max(w, h, image.bitmap.width, image.bitmap.height);
        image = methods$d.resize(image, {
            h: max,
            w: max,
            mode: mode === true ? undefined : mode,
        });
        image = composite(image, c, image.bitmap.width / 2 - c.bitmap.width / 2, image.bitmap.height / 2 - c.bitmap.height / 2);
    }
    const bW = image.bitmap.width;
    const bH = image.bitmap.height;
    const dstBuffer = Buffer.alloc(image.bitmap.data.length);
    const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
    const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
    for (let y = 1; y <= bH; y++) {
        for (let x = 1; x <= bW; x++) {
            const cartesian = translate2Cartesian(x, y);
            const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
            const dstIdx = (bW * (y - 1) + x - 1) << 2;
            if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
                const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;
                const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);
                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
            }
            else {
                // reset off-image pixels
                dstBuffer.writeUInt32BE(image.background, dstIdx);
            }
        }
    }
    image.bitmap.data = dstBuffer;
    if (mode === true || typeof mode === "string") {
        // now crop the image to the final size
        const x = Math.max(bW / 2 - w / 2, 0);
        const y = Math.max(bH / 2 - h / 2, 0);
        image = methods$b.crop(image, { x, y, w, h });
    }
}
const methods$2 = {
    /**
     * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.rotate(90);
     * ```
     */
    rotate(image, options) {
        const parsed = RotateOptionsSchema.parse(options);
        const actualOptions = typeof parsed === "number" ? { deg: parsed } : parsed;
        const { mode = true } = actualOptions;
        let { deg } = actualOptions;
        // No need to do extra rotation
        deg %= 360;
        // no rotation for 0, 360, -360, 720, -720, ...
        if (deg % 360 === 0) {
            return image;
        }
        // use matrixRotate if the angle is a multiple of 90 degrees (eg: 180 or -90) and resize is allowed or not needed.
        const matrixRotateAllowed = deg % 90 === 0 &&
            (mode || image.bitmap.width === image.bitmap.height || deg % 180 === 0);
        if (matrixRotateAllowed) {
            matrixRotate(image, deg);
        }
        else {
            advancedRotate(image, deg, mode);
        }
        return image;
    },
};

const ThresholdOptionsSchema = objectType({
    /** A number auto limited between 0 - 255 */
    max: numberType().min(0).max(255),
    /** A number auto limited between 0 - 255 (default 255)  */
    replace: numberType().min(0).max(255).optional(),
    /** A boolean whether to apply greyscale beforehand (default true)  */
    autoGreyscale: booleanType().optional(),
});
const methods$1 = {
    /**
     * Applies a minimum color threshold to a grayscale image.
     * Converts image to grayscale by default.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.threshold({ max: 150 });
     * ```
     */
    threshold(image, options) {
        let { max, replace = 255, 
        // eslint-disable-next-line prefer-const
        autoGreyscale = true, } = ThresholdOptionsSchema.parse(options);
        max = limit255(max);
        replace = limit255(replace);
        if (autoGreyscale) {
            methods$e.greyscale(image);
        }
        image.scan((_, __, idx) => {
            const grey = image.bitmap.data[idx] < max ? image.bitmap.data[idx] : replace;
            image.bitmap.data[idx] = grey;
            image.bitmap.data[idx + 1] = grey;
            image.bitmap.data[idx + 2] = grey;
        });
        return image;
    },
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/constants/index.ts
var constants_exports = {};
__export(constants_exports, {
  bt709: () => bt709_exports
});

// src/constants/bt709.ts
var bt709_exports = {};
__export(bt709_exports, {
  Y: () => Y,
  x: () => x,
  y: () => y
});
var Y = /* @__PURE__ */ ((Y2) => {
  Y2[Y2["RED"] = 0.2126] = "RED";
  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
  Y2[Y2["WHITE"] = 1] = "WHITE";
  return Y2;
})(Y || {});
var x = /* @__PURE__ */ ((x2) => {
  x2[x2["RED"] = 0.64] = "RED";
  x2[x2["GREEN"] = 0.3] = "GREEN";
  x2[x2["BLUE"] = 0.15] = "BLUE";
  x2[x2["WHITE"] = 0.3127] = "WHITE";
  return x2;
})(x || {});
var y = /* @__PURE__ */ ((y2) => {
  y2[y2["RED"] = 0.33] = "RED";
  y2[y2["GREEN"] = 0.6] = "GREEN";
  y2[y2["BLUE"] = 0.06] = "BLUE";
  y2[y2["WHITE"] = 0.329] = "WHITE";
  return y2;
})(y || {});

// src/conversion/index.ts
var conversion_exports = {};
__export(conversion_exports, {
  lab2rgb: () => lab2rgb,
  lab2xyz: () => lab2xyz,
  rgb2hsl: () => rgb2hsl,
  rgb2lab: () => rgb2lab,
  rgb2xyz: () => rgb2xyz,
  xyz2lab: () => xyz2lab,
  xyz2rgb: () => xyz2rgb
});

// src/conversion/rgb2xyz.ts
function correctGamma(n) {
  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
}
function rgb2xyz(r, g, b) {
  r = correctGamma(r / 255);
  g = correctGamma(g / 255);
  b = correctGamma(b / 255);
  return {
    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
    z: r * 0.0193 + g * 0.1192 + b * 0.9505
  };
}

// src/utils/arithmetic.ts
var arithmetic_exports = {};
__export(arithmetic_exports, {
  degrees2radians: () => degrees2radians,
  inRange0to255: () => inRange0to255,
  inRange0to255Rounded: () => inRange0to255Rounded,
  intInRange: () => intInRange,
  max3: () => max3,
  min3: () => min3,
  stableSort: () => stableSort
});
function degrees2radians(n) {
  return n * (Math.PI / 180);
}
function max3(a, b, c) {
  let m = a;
  if (m < b)
    m = b;
  if (m < c)
    m = c;
  return m;
}
function min3(a, b, c) {
  let m = a;
  if (m > b)
    m = b;
  if (m > c)
    m = c;
  return m;
}
function intInRange(value, low, high) {
  if (value > high)
    value = high;
  if (value < low)
    value = low;
  return value | 0;
}
function inRange0to255Rounded(n) {
  n = Math.round(n);
  if (n > 255)
    n = 255;
  else if (n < 0)
    n = 0;
  return n;
}
function inRange0to255(n) {
  if (n > 255)
    n = 255;
  else if (n < 0)
    n = 0;
  return n;
}
function stableSort(arrayToSort, callback) {
  const type = typeof arrayToSort[0];
  let sorted;
  if (type === "number" || type === "string") {
    const ord = /* @__PURE__ */ Object.create(null);
    for (let i = 0, l = arrayToSort.length; i < l; i++) {
      const val = arrayToSort[i];
      if (ord[val] || ord[val] === 0)
        continue;
      ord[val] = i;
    }
    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
  } else {
    const ord2 = arrayToSort.slice(0);
    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
  }
  return sorted;
}

// src/conversion/rgb2hsl.ts
function rgb2hsl(r, g, b) {
  const min = min3(r, g, b);
  const max = max3(r, g, b);
  const delta = max - min;
  const l = (min + max) / 510;
  let s = 0;
  if (l > 0 && l < 1)
    s = delta / (l < 0.5 ? max + min : 510 - max - min);
  let h = 0;
  if (delta > 0) {
    if (max === r) {
      h = (g - b) / delta;
    } else if (max === g) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h *= 60;
    if (h < 0)
      h += 360;
  }
  return { h, s, l };
}

// src/conversion/xyz2lab.ts
var refX = 0.95047;
var refY = 1;
var refZ = 1.08883;
function pivot(n) {
  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
}
function xyz2lab(x2, y2, z) {
  x2 = pivot(x2 / refX);
  y2 = pivot(y2 / refY);
  z = pivot(z / refZ);
  if (116 * y2 - 16 < 0)
    throw new Error("xxx");
  return {
    L: Math.max(0, 116 * y2 - 16),
    a: 500 * (x2 - y2),
    b: 200 * (y2 - z)
  };
}

// src/conversion/rgb2lab.ts
function rgb2lab(r, g, b) {
  const xyz = rgb2xyz(r, g, b);
  return xyz2lab(xyz.x, xyz.y, xyz.z);
}

// src/conversion/lab2xyz.ts
var refX2 = 0.95047;
var refY2 = 1;
var refZ2 = 1.08883;
function pivot2(n) {
  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
}
function lab2xyz(L, a, b) {
  const y2 = (L + 16) / 116;
  const x2 = a / 500 + y2;
  const z = y2 - b / 200;
  return {
    x: refX2 * pivot2(x2),
    y: refY2 * pivot2(y2),
    z: refZ2 * pivot2(z)
  };
}

// src/conversion/xyz2rgb.ts
function correctGamma2(n) {
  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
}
function xyz2rgb(x2, y2, z) {
  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
  return {
    r: inRange0to255Rounded(r * 255),
    g: inRange0to255Rounded(g * 255),
    b: inRange0to255Rounded(b * 255)
  };
}

// src/conversion/lab2rgb.ts
function lab2rgb(L, a, b) {
  const xyz = lab2xyz(L, a, b);
  return xyz2rgb(xyz.x, xyz.y, xyz.z);
}

// src/distance/index.ts
var distance_exports = {};
__export(distance_exports, {
  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
  AbstractEuclidean: () => AbstractEuclidean,
  AbstractManhattan: () => AbstractManhattan,
  CIE94GraphicArts: () => CIE94GraphicArts,
  CIE94Textiles: () => CIE94Textiles,
  CIEDE2000: () => CIEDE2000,
  CMetric: () => CMetric,
  Euclidean: () => Euclidean,
  EuclideanBT709: () => EuclideanBT709,
  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
  Manhattan: () => Manhattan,
  ManhattanBT709: () => ManhattanBT709,
  ManhattanNommyde: () => ManhattanNommyde,
  PNGQuant: () => PNGQuant
});

// src/distance/distanceCalculator.ts
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField(this, "_maxDistance");
    __publicField(this, "_whitePoint");
    this._setDefaults();
    this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(r, g, b, a) {
    this._whitePoint = {
      r: r > 0 ? 255 / r : 0,
      g: g > 0 ? 255 / g : 0,
      b: b > 0 ? 255 / b : 0,
      a: a > 0 ? 255 / a : 0
    };
    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
  }
  calculateNormalized(colorA, colorB) {
    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
  }
};

// src/distance/cie94.ts
var AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dL = lab1.L - lab2.L;
    const dA = lab1.a - lab2.a;
    const dB = lab1.b - lab2.b;
    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
    const dC = c1 - c2;
    let deltaH = dA * dA + dB * dB - dC * dC;
    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
  }
};
var CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2;
    this._K1 = 0.048;
    this._K2 = 0.014;
    this._kA = 0.25 * 50 / 255;
  }
};
var CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1;
    this._K1 = 0.045;
    this._K2 = 0.015;
    this._kA = 0.25 * 100 / 255;
  }
};

// src/distance/ciede2000.ts
var _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {
  }
  static _calculatehp(b, ap) {
    const hp = Math.atan2(b, ap);
    if (hp >= 0)
      return hp;
    return hp + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(ahp, aCp) {
    const aCp_to_7 = aCp ** 7;
    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * delta_theta) * R_C;
  }
  static _calculateT(ahp) {
    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
    const hpSum = h1p + h2p;
    if (C1pC2p === 0)
      return hpSum;
    if (h_bar <= _CIEDE2000._deg180InRad)
      return hpSum / 2;
    if (hpSum < _CIEDE2000._deg360InRad) {
      return (hpSum + _CIEDE2000._deg360InRad) / 2;
    }
    return (hpSum - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
    let dhp;
    if (C1pC2p === 0) {
      dhp = 0;
    } else if (h_bar <= _CIEDE2000._deg180InRad) {
      dhp = h2p - h1p;
    } else if (h2p <= h1p) {
      dhp = h2p - h1p + _CIEDE2000._deg360InRad;
    } else {
      dhp = h2p - h1p - _CIEDE2000._deg360InRad;
    }
    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
  }
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
    const dE2 = this.calculateRawInLab(lab1, lab2);
    return Math.sqrt(dE2 + dA * dA);
  }
  calculateRawInLab(Lab1, Lab2) {
    const L1 = Lab1.L;
    const a1 = Lab1.a;
    const b1 = Lab1.b;
    const L2 = Lab2.L;
    const a2 = Lab2.a;
    const b2 = Lab2.b;
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
    const a1p = (1 + G) * a1;
    const a2p = (1 + G) * a2;
    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
    const C2p = Math.sqrt(a2p * a2p + b2 * b2);
    const C1pC2p = C1p * C2p;
    const h1p = _CIEDE2000._calculatehp(b1, a1p);
    const h2p = _CIEDE2000._calculatehp(b2, a2p);
    const h_bar = Math.abs(h1p - h2p);
    const dLp = L2 - L1;
    const dCp = C2p - C1p;
    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
    const T = _CIEDE2000._calculateT(ahp);
    const aCp = (C1p + C2p) / 2;
    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
    const S_C = 1 + 0.045 * aCp;
    const S_H = 1 + 0.015 * T * aCp;
    const R_T = _CIEDE2000._calculateRT(ahp, aCp);
    const dLpSL = dLp / S_L;
    const dCpSC = dCp / S_C;
    const dHpSH = dHp / S_H;
    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
  }
};
var CIEDE2000 = _CIEDE2000;
__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));

// src/distance/cmetric.ts
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const rmean = (r1 + r2) / 2 * this._whitePoint.r;
    const r = (r1 - r2) * this._whitePoint.r;
    const g = (g1 - g2) * this._whitePoint.g;
    const b = (b1 - b2) * this._whitePoint.b;
    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
    const dA = (a2 - a1) * this._whitePoint.a;
    return Math.sqrt(dE + dA * dA);
  }
  _setDefaults() {
  }
};

// src/distance/euclidean.ts
var AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const dR = r2 - r1;
    const dG = g2 - g1;
    const dB = b2 - b1;
    const dA = a2 - a1;
    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
  }
};
var Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126 /* RED */;
    this._kG = 0.7152 /* GREEN */;
    this._kB = 0.0722 /* BLUE */;
    this._kA = 1;
  }
};
var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126 /* RED */;
    this._kG = 0.7152 /* GREEN */;
    this._kB = 0.0722 /* BLUE */;
    this._kA = 0;
  }
};

// src/distance/manhattan.ts
var AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    let dR = r2 - r1;
    let dG = g2 - g1;
    let dB = b2 - b1;
    let dA = a2 - a1;
    if (dR < 0)
      dR = 0 - dR;
    if (dG < 0)
      dG = 0 - dG;
    if (dB < 0)
      dB = 0 - dB;
    if (dA < 0)
      dA = 0 - dA;
    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
  }
};
var Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984;
    this._kG = 0.8625;
    this._kB = 0.2979;
    this._kA = 1;
  }
};
var ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126 /* RED */;
    this._kG = 0.7152 /* GREEN */;
    this._kB = 0.0722 /* BLUE */;
    this._kA = 1;
  }
};

// src/distance/pngQuant.ts
var PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const alphas = (a2 - a1) * this._whitePoint.a;
    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
  }
  _colordifferenceCh(x2, y2, alphas) {
    const black = x2 - y2;
    const white = black + alphas;
    return black * black + white * white;
  }
  _setDefaults() {
  }
};

// src/palette/index.ts
var palette_exports = {};
__export(palette_exports, {
  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
  ColorHistogram: () => ColorHistogram,
  NeuQuant: () => NeuQuant,
  NeuQuantFloat: () => NeuQuantFloat,
  RGBQuant: () => RGBQuant,
  WuColorCube: () => WuColorCube,
  WuQuant: () => WuQuant
});

// src/palette/paletteQuantizer.ts
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const value of this.quantize()) {
      if (value.palette) {
        return value.palette;
      }
    }
    throw new Error("unreachable");
  }
};

// src/utils/point.ts
var Point = class {
  constructor() {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    __publicField(this, "uint32");
    __publicField(this, "rgba");
    this.uint32 = -1 >>> 0;
    this.r = this.g = this.b = this.a = 0;
    this.rgba = new Array(4);
    this.rgba[0] = 0;
    this.rgba[1] = 0;
    this.rgba[2] = 0;
    this.rgba[3] = 0;
  }
  static createByQuadruplet(quadruplet) {
    const point = new Point();
    point.r = quadruplet[0] | 0;
    point.g = quadruplet[1] | 0;
    point.b = quadruplet[2] | 0;
    point.a = quadruplet[3] | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByRGBA(red, green, blue, alpha) {
    const point = new Point();
    point.r = red | 0;
    point.g = green | 0;
    point.b = blue | 0;
    point.a = alpha | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByUint32(uint32) {
    const point = new Point();
    point.uint32 = uint32 >>> 0;
    point._loadRGBA();
    point._loadQuadruplet();
    return point;
  }
  from(point) {
    this.r = point.r;
    this.g = point.g;
    this.b = point.b;
    this.a = point.a;
    this.uint32 = point.uint32;
    this.rgba[0] = point.r;
    this.rgba[1] = point.g;
    this.rgba[2] = point.b;
    this.rgba[3] = point.a;
  }
  getLuminosity(useAlphaChannel) {
    let r = this.r;
    let g = this.g;
    let b = this.b;
    if (useAlphaChannel) {
      r = Math.min(255, 255 - this.a + this.a * r / 255);
      g = Math.min(255, 255 - this.a + this.a * g / 255);
      b = Math.min(255, 255 - this.a + this.a * b / 255);
    }
    return r * 0.2126 /* RED */ + g * 0.7152 /* GREEN */ + b * 0.0722 /* BLUE */;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = this.uint32 & 255;
    this.g = this.uint32 >>> 8 & 255;
    this.b = this.uint32 >>> 16 & 255;
    this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r;
    this.rgba[1] = this.g;
    this.rgba[2] = this.b;
    this.rgba[3] = this.a;
  }
};

// src/utils/pointContainer.ts
var PointContainer = class {
  constructor() {
    __publicField(this, "_pointArray");
    __publicField(this, "_width");
    __publicField(this, "_height");
    this._width = 0;
    this._height = 0;
    this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(width) {
    this._width = width;
  }
  setHeight(height) {
    this._height = height;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const clone = new PointContainer();
    clone._width = this._width;
    clone._height = this._height;
    for (let i = 0, l = this._pointArray.length; i < l; i++) {
      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);
    }
    return clone;
  }
  toUint32Array() {
    const l = this._pointArray.length;
    const uint32Array = new Uint32Array(l);
    for (let i = 0; i < l; i++) {
      uint32Array[i] = this._pointArray[i].uint32;
    }
    return uint32Array;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(img) {
    const width = img.naturalWidth;
    const height = img.naturalHeight;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
    return PointContainer.fromHTMLCanvasElement(canvas);
  }
  static fromHTMLCanvasElement(canvas) {
    const width = canvas.width;
    const height = canvas.height;
    const ctx = canvas.getContext("2d");
    const imgData = ctx.getImageData(0, 0, width, height);
    return PointContainer.fromImageData(imgData);
  }
  static fromImageData(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    return PointContainer.fromUint8Array(imageData.data, width, height);
  }
  static fromUint8Array(uint8Array, width, height) {
    switch (Object.prototype.toString.call(uint8Array)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        uint8Array = new Uint8Array(uint8Array);
    }
    const uint32Array = new Uint32Array(uint8Array.buffer);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
  static fromUint32Array(uint32Array, width, height) {
    const container = new PointContainer();
    container._width = width;
    container._height = height;
    for (let i = 0, l = uint32Array.length; i < l; i++) {
      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);
    }
    return container;
  }
  static fromBuffer(buffer, width, height) {
    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
};

// src/utils/palette.ts
var hueGroups = 10;
function hueGroup(hue, segmentsNumber) {
  const maxHue = 360;
  const seg = maxHue / segmentsNumber;
  const half = seg / 2;
  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
    if (hue >= mid && hue < mid + seg)
      return i;
  }
  return 0;
}
var Palette = class {
  constructor() {
    __publicField(this, "_pointContainer");
    __publicField(this, "_pointArray", []);
    __publicField(this, "_i32idx", {});
    this._pointContainer = new PointContainer();
    this._pointContainer.setHeight(1);
    this._pointArray = this._pointContainer.getPointArray();
  }
  add(color) {
    this._pointArray.push(color);
    this._pointContainer.setWidth(this._pointArray.length);
  }
  has(color) {
    for (let i = this._pointArray.length - 1; i >= 0; i--) {
      if (color.uint32 === this._pointArray[i].uint32)
        return true;
    }
    return false;
  }
  getNearestColor(colorDistanceCalculator, color) {
    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(key) {
    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
  }
  _getNearestIndex(colorDistanceCalculator, point) {
    let idx = this._nearestPointFromCache("" + point.uint32);
    if (idx >= 0)
      return idx;
    let minimalDistance = Number.MAX_VALUE;
    idx = 0;
    for (let i = 0, l = this._pointArray.length; i < l; i++) {
      const p = this._pointArray[i];
      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
      if (distance < minimalDistance) {
        minimalDistance = distance;
        idx = i;
      }
    }
    this._i32idx[point.uint32] = idx;
    return idx;
  }
  sort() {
    this._i32idx = {};
    this._pointArray.sort((a, b) => {
      const hslA = rgb2hsl(a.r, a.g, a.b);
      const hslB = rgb2hsl(b.r, b.g, b.b);
      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
      const hueDiff = hueB - hueA;
      if (hueDiff)
        return -hueDiff;
      const lA = a.getLuminosity(true);
      const lB = b.getLuminosity(true);
      if (lB - lA !== 0)
        return lB - lA;
      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
      if (satDiff)
        return -satDiff;
      return 0;
    });
  }
};

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  HueStatistics: () => HueStatistics,
  Palette: () => Palette,
  Point: () => Point,
  PointContainer: () => PointContainer,
  ProgressTracker: () => ProgressTracker,
  arithmetic: () => arithmetic_exports
});

// src/utils/hueStatistics.ts
var HueGroup = class {
  constructor() {
    __publicField(this, "num", 0);
    __publicField(this, "cols", []);
  }
};
var HueStatistics = class {
  constructor(numGroups, minCols) {
    __publicField(this, "_numGroups");
    __publicField(this, "_minCols");
    __publicField(this, "_stats");
    __publicField(this, "_groupsFull");
    this._numGroups = numGroups;
    this._minCols = minCols;
    this._stats = [];
    for (let i = 0; i <= numGroups; i++) {
      this._stats[i] = new HueGroup();
    }
    this._groupsFull = 0;
  }
  check(i32) {
    if (this._groupsFull === this._numGroups + 1) {
      this.check = () => {
      };
    }
    const r = i32 & 255;
    const g = i32 >>> 8 & 255;
    const b = i32 >>> 16 & 255;
    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
    const gr = this._stats[hg];
    const min = this._minCols;
    gr.num++;
    if (gr.num > min) {
      return;
    }
    if (gr.num === min) {
      this._groupsFull++;
    }
    if (gr.num <= min) {
      this._stats[hg].cols.push(i32);
    }
  }
  injectIntoDictionary(histG) {
    for (let i = 0; i <= this._numGroups; i++) {
      if (this._stats[i].num <= this._minCols) {
        this._stats[i].cols.forEach((col) => {
          if (!histG[col]) {
            histG[col] = 1;
          } else {
            histG[col]++;
          }
        });
      }
    }
  }
  injectIntoArray(histG) {
    for (let i = 0; i <= this._numGroups; i++) {
      if (this._stats[i].num <= this._minCols) {
        this._stats[i].cols.forEach((col) => {
          if (histG.indexOf(col) === -1) {
            histG.push(col);
          }
        });
      }
    }
  }
};

// src/utils/progressTracker.ts
var _ProgressTracker = class {
  constructor(valueRange, progressRange) {
    __publicField(this, "progress");
    __publicField(this, "_step");
    __publicField(this, "_range");
    __publicField(this, "_last");
    __publicField(this, "_progressRange");
    this._range = valueRange;
    this._progressRange = progressRange;
    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
    this._last = -this._step;
    this.progress = 0;
  }
  shouldNotify(current) {
    if (current - this._last >= this._step) {
      this._last = current;
      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
      return true;
    }
    return false;
  }
};
var ProgressTracker = _ProgressTracker;
__publicField(ProgressTracker, "steps", 100);

// src/palette/neuquant/neuquant.ts
var networkBiasShift = 3;
var Neuron = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(r, g, b, a) {
    this.r -= r | 0;
    this.g -= g | 0;
    this.b -= b | 0;
    this.a -= a | 0;
  }
};
var _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i = 0; i < this._networkSize; i++) {
      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;
      this._bias[i] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuant._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
    const pointsToSample = pointsNumber / sampleFactor | 0;
    let delta = pointsToSample / _NeuQuant._nCycles | 0;
    let alpha = _NeuQuant._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
    let rad = radius >> _NeuQuant._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i = 0; i < rad; i++) {
      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
    }
    let step;
    if (pointsNumber < _NeuQuant._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
      step = _NeuQuant._prime1;
    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
      step = _NeuQuant._prime2;
    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
      step = _NeuQuant._prime3;
    } else {
      step = _NeuQuant._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
      if (tracker.shouldNotify(i)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift;
      const g = point.g << networkBiasShift;
      const r = point.r << networkBiasShift;
      const a = point.a << networkBiasShift;
      const neuronIndex = this._contest(b, g, r, a);
      this._alterSingle(alpha, neuronIndex, b, g, r, a);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i++;
      if (delta === 0)
        delta = 1;
      if (i % delta === 0) {
        alpha -= alpha / alphadec | 0;
        radius -= radius / _NeuQuant._radiusDecrease | 0;
        rad = radius >> _NeuQuant._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0; j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        }
      }
    }
  }
  _buildPalette() {
    const palette = new Palette();
    this._network.forEach((neuron) => {
      palette.add(neuron.toPoint());
    });
    palette.sort();
    return palette;
  }
  _alterNeighbour(rad, i, b, g, r, al) {
    let lo = i - rad;
    if (lo < -1)
      lo = -1;
    let hi = i + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i + 1;
    let k = i - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i, b, g, r, a) {
    alpha /= _NeuQuant._initAlpha;
    const n = this._network[i];
    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
  }
  _contest(b, g, r, a) {
    const multiplier = 255 * 4 << networkBiasShift;
    let bestd = 2147483647;
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i = 0; i < this._networkSize; i++) {
      const n = this._network[i];
      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      const betafreq = this._freq[i] >> _NeuQuant._betaShift;
      this._freq[i] -= betafreq;
      this._bias[i] += betafreq << _NeuQuant._gammaShift;
    }
    this._freq[bestpos] += _NeuQuant._beta;
    this._bias[bestpos] -= _NeuQuant._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuant = _NeuQuant;
__publicField(NeuQuant, "_prime1", 499);
__publicField(NeuQuant, "_prime2", 491);
__publicField(NeuQuant, "_prime3", 487);
__publicField(NeuQuant, "_prime4", 503);
__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
__publicField(NeuQuant, "_nCycles", 100);
__publicField(NeuQuant, "_initialBiasShift", 16);
__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
__publicField(NeuQuant, "_gammaShift", 10);
__publicField(NeuQuant, "_betaShift", 10);
__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
__publicField(NeuQuant, "_radiusBiasShift", 6);
__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
__publicField(NeuQuant, "_radiusDecrease", 30);
__publicField(NeuQuant, "_alphaBiasShift", 10);
__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
__publicField(NeuQuant, "_radBiasShift", 8);
__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);

// src/palette/neuquant/neuquantFloat.ts
var networkBiasShift2 = 3;
var NeuronFloat = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(r, g, b, a) {
    this.r -= r;
    this.g -= g;
    this.b -= b;
    this.a -= a;
  }
};
var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i = 0; i < this._networkSize; i++) {
      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);
      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;
      this._bias[i] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3;
    const pointsToSample = pointsNumber / sampleFactor;
    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
    let alpha = _NeuQuantFloat._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
    let rad = radius >> _NeuQuantFloat._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i = 0; i < rad; i++) {
      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
    }
    let step;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
      step = _NeuQuantFloat._prime1;
    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
      step = _NeuQuantFloat._prime2;
    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
      step = _NeuQuantFloat._prime3;
    } else {
      step = _NeuQuantFloat._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
      if (tracker.shouldNotify(i)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift2;
      const g = point.g << networkBiasShift2;
      const r = point.r << networkBiasShift2;
      const a = point.a << networkBiasShift2;
      const neuronIndex = this._contest(b, g, r, a);
      this._alterSingle(alpha, neuronIndex, b, g, r, a);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i++;
      if (delta === 0)
        delta = 1;
      if (i % delta === 0) {
        alpha -= alpha / alphadec;
        radius -= radius / _NeuQuantFloat._radiusDecrease;
        rad = radius >> _NeuQuantFloat._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0; j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
        }
      }
    }
  }
  _buildPalette() {
    const palette = new Palette();
    this._network.forEach((neuron) => {
      palette.add(neuron.toPoint());
    });
    palette.sort();
    return palette;
  }
  _alterNeighbour(rad, i, b, g, r, al) {
    let lo = i - rad;
    if (lo < -1)
      lo = -1;
    let hi = i + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i + 1;
    let k = i - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i, b, g, r, a) {
    alpha /= _NeuQuantFloat._initAlpha;
    const n = this._network[i];
    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
  }
  _contest(b, g, r, al) {
    const multiplier = 255 * 4 << networkBiasShift2;
    let bestd = 2147483647;
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i = 0; i < this._networkSize; i++) {
      const n = this._network[i];
      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
      this._freq[i] -= betafreq;
      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
    }
    this._freq[bestpos] += _NeuQuantFloat._beta;
    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuantFloat = _NeuQuantFloat;
__publicField(NeuQuantFloat, "_prime1", 499);
__publicField(NeuQuantFloat, "_prime2", 491);
__publicField(NeuQuantFloat, "_prime3", 487);
__publicField(NeuQuantFloat, "_prime4", 503);
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
__publicField(NeuQuantFloat, "_nCycles", 100);
__publicField(NeuQuantFloat, "_initialBiasShift", 16);
__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
__publicField(NeuQuantFloat, "_gammaShift", 10);
__publicField(NeuQuantFloat, "_betaShift", 10);
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
__publicField(NeuQuantFloat, "_radiusDecrease", 30);
__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
__publicField(NeuQuantFloat, "_radBiasShift", 8);
__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);

// src/palette/rgbquant/colorHistogram.ts
var _ColorHistogram = class {
  constructor(method, colors) {
    __publicField(this, "_method");
    __publicField(this, "_hueStats");
    __publicField(this, "_histogram");
    __publicField(this, "_initColors");
    __publicField(this, "_minHueCols");
    this._method = method;
    this._minHueCols = colors << 2;
    this._initColors = colors << 2;
    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
    this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(pointContainer) {
    switch (this._method) {
      case 1:
        this._colorStats1D(pointContainer);
        break;
      case 2:
        this._colorStats2D(pointContainer);
        break;
    }
  }
  getImportanceSortedColorsIDXI32() {
    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
    if (sorted.length === 0) {
      return [];
    }
    let idxi32;
    switch (this._method) {
      case 1:
        const initialColorsLimit = Math.min(sorted.length, this._initColors);
        const last = sorted[initialColorsLimit - 1];
        const freq = this._histogram[last];
        idxi32 = sorted.slice(0, initialColorsLimit);
        let pos = initialColorsLimit;
        const len = sorted.length;
        while (pos < len && this._histogram[sorted[pos]] === freq) {
          idxi32.push(sorted[pos++]);
        }
        this._hueStats.injectIntoArray(idxi32);
        break;
      case 2:
        idxi32 = sorted;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return idxi32.map((v) => +v);
  }
  _colorStats1D(pointContainer) {
    const histG = this._histogram;
    const pointArray = pointContainer.getPointArray();
    const len = pointArray.length;
    for (let i = 0; i < len; i++) {
      const col = pointArray[i].uint32;
      this._hueStats.check(col);
      if (col in histG) {
        histG[col]++;
      } else {
        histG[col] = 1;
      }
    }
  }
  _colorStats2D(pointContainer) {
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const pointArray = pointContainer.getPointArray();
    const boxW = _ColorHistogram._boxSize[0];
    const boxH = _ColorHistogram._boxSize[1];
    const area = boxW * boxH;
    const boxes = this._makeBoxes(width, height, boxW, boxH);
    const histG = this._histogram;
    boxes.forEach((box) => {
      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
      if (effc < 2)
        effc = 2;
      const histL = {};
      this._iterateBox(box, width, (i) => {
        const col = pointArray[i].uint32;
        this._hueStats.check(col);
        if (col in histG) {
          histG[col]++;
        } else if (col in histL) {
          if (++histL[col] >= effc) {
            histG[col] = histL[col];
          }
        } else {
          histL[col] = 1;
        }
      });
    });
    this._hueStats.injectIntoDictionary(histG);
  }
  _iterateBox(bbox, wid, fn) {
    const b = bbox;
    const i0 = b.y * wid + b.x;
    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
    const incr = wid - b.w + 1;
    let cnt = 0;
    let i = i0;
    do {
      fn.call(this, i);
      i += ++cnt % b.w === 0 ? incr : 1;
    } while (i <= i1);
  }
  _makeBoxes(width, height, stepX, stepY) {
    const wrem = width % stepX;
    const hrem = height % stepY;
    const xend = width - wrem;
    const yend = height - hrem;
    const boxesArray = [];
    for (let y2 = 0; y2 < height; y2 += stepY) {
      for (let x2 = 0; x2 < width; x2 += stepX) {
        boxesArray.push({
          x: x2,
          y: y2,
          w: x2 === xend ? wrem : stepX,
          h: y2 === yend ? hrem : stepY
        });
      }
    }
    return boxesArray;
  }
};
var ColorHistogram = _ColorHistogram;
__publicField(ColorHistogram, "_boxSize", [64, 64]);
__publicField(ColorHistogram, "_boxPixels", 2);
__publicField(ColorHistogram, "_hueGroups", 10);

// src/palette/rgbquant/rgbquant.ts
var RemovedColor = class {
  constructor(index, color, distance) {
    __publicField(this, "index");
    __publicField(this, "color");
    __publicField(this, "distance");
    this.index = index;
    this.color = color;
    this.distance = distance;
  }
};
var RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, method = 2) {
    super();
    __publicField(this, "_colors");
    __publicField(this, "_initialDistance");
    __publicField(this, "_distanceIncrement");
    __publicField(this, "_histogram");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._colors = colors;
    this._histogram = new ColorHistogram(method, colors);
    this._initialDistance = 0.01;
    this._distanceIncrement = 5e-3;
  }
  sample(image) {
    this._histogram.sample(image);
  }
  *quantize() {
    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
    if (idxi32.length === 0) {
      throw new Error("No colors in image");
    }
    yield* this._buildPalette(idxi32);
  }
  *_buildPalette(idxi32) {
    const palette = new Palette();
    const colorArray = palette.getPointContainer().getPointArray();
    const usageArray = new Array(idxi32.length);
    for (let i = 0; i < idxi32.length; i++) {
      colorArray.push(Point.createByUint32(idxi32[i]));
      usageArray[i] = 1;
    }
    const len = colorArray.length;
    const memDist = [];
    let palLen = len;
    let thold = this._initialDistance;
    const tracker = new ProgressTracker(palLen - this._colors, 99);
    while (palLen > this._colors) {
      memDist.length = 0;
      for (let i = 0; i < len; i++) {
        if (tracker.shouldNotify(len - palLen)) {
          yield {
            progress: tracker.progress
          };
        }
        if (usageArray[i] === 0)
          continue;
        const pxi = colorArray[i];
        for (let j = i + 1; j < len; j++) {
          if (usageArray[j] === 0)
            continue;
          const pxj = colorArray[j];
          const dist = this._distance.calculateNormalized(pxi, pxj);
          if (dist < thold) {
            memDist.push(new RemovedColor(j, pxj, dist));
            usageArray[j] = 0;
            palLen--;
          }
        }
      }
      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
    }
    if (palLen < this._colors) {
      stableSort(memDist, (a, b) => b.distance - a.distance);
      let k = 0;
      while (palLen < this._colors && k < memDist.length) {
        const removedColor = memDist[k];
        usageArray[removedColor.index] = 1;
        palLen++;
        k++;
      }
    }
    let colors = colorArray.length;
    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
      if (usageArray[colorIndex] === 0) {
        if (colorIndex !== colors - 1) {
          colorArray[colorIndex] = colorArray[colors - 1];
        }
        --colors;
      }
    }
    colorArray.length = colors;
    palette.sort();
    yield {
      palette,
      progress: 100
    };
  }
};

// src/palette/wu/wuQuant.ts
function createArray1D(dimension1) {
  const a = [];
  for (let k = 0; k < dimension1; k++) {
    a[k] = 0;
  }
  return a;
}
function createArray4D(dimension1, dimension2, dimension3, dimension4) {
  const a = new Array(dimension1);
  for (let i = 0; i < dimension1; i++) {
    a[i] = new Array(dimension2);
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = new Array(dimension3);
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = new Array(dimension4);
        for (let l = 0; l < dimension4; l++) {
          a[i][j][k][l] = 0;
        }
      }
    }
  }
  return a;
}
function createArray3D(dimension1, dimension2, dimension3) {
  const a = new Array(dimension1);
  for (let i = 0; i < dimension1; i++) {
    a[i] = new Array(dimension2);
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = new Array(dimension3);
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = 0;
      }
    }
  }
  return a;
}
function fillArray3D(a, dimension1, dimension2, dimension3, value) {
  for (let i = 0; i < dimension1; i++) {
    a[i] = [];
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = [];
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = value;
      }
    }
  }
}
function fillArray1D(a, dimension1, value) {
  for (let i = 0; i < dimension1; i++) {
    a[i] = value;
  }
}
var WuColorCube = class {
  constructor() {
    __publicField(this, "redMinimum");
    __publicField(this, "redMaximum");
    __publicField(this, "greenMinimum");
    __publicField(this, "greenMaximum");
    __publicField(this, "blueMinimum");
    __publicField(this, "blueMaximum");
    __publicField(this, "volume");
    __publicField(this, "alphaMinimum");
    __publicField(this, "alphaMaximum");
  }
};
var _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
    super();
    __publicField(this, "_reds");
    __publicField(this, "_greens");
    __publicField(this, "_blues");
    __publicField(this, "_alphas");
    __publicField(this, "_sums");
    __publicField(this, "_weights");
    __publicField(this, "_momentsRed");
    __publicField(this, "_momentsGreen");
    __publicField(this, "_momentsBlue");
    __publicField(this, "_momentsAlpha");
    __publicField(this, "_moments");
    __publicField(this, "_table");
    __publicField(this, "_pixels");
    __publicField(this, "_cubes");
    __publicField(this, "_colors");
    __publicField(this, "_significantBitsPerChannel");
    __publicField(this, "_maxSideIndex");
    __publicField(this, "_alphaMaxSideIndex");
    __publicField(this, "_sideSize");
    __publicField(this, "_alphaSideSize");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._setQuality(significantBitsPerChannel);
    this._initialize(colors);
  }
  sample(image) {
    const pointArray = image.getPointArray();
    for (let i = 0, l = pointArray.length; i < l; i++) {
      this._addColor(pointArray[i]);
    }
    this._pixels = this._pixels.concat(pointArray);
  }
  *quantize() {
    yield* this._preparePalette();
    const palette = new Palette();
    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
      if (this._sums[paletteIndex] > 0) {
        const sum = this._sums[paletteIndex];
        const r = this._reds[paletteIndex] / sum;
        const g = this._greens[paletteIndex] / sum;
        const b = this._blues[paletteIndex] / sum;
        const a = this._alphas[paletteIndex] / sum;
        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
        palette.add(color);
      }
    }
    palette.sort();
    yield {
      palette,
      progress: 100
    };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let next = 0;
    const volumeVariance = createArray1D(this._colors);
    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
      } else {
        volumeVariance[next] = 0;
        cubeIndex--;
      }
      next = 0;
      let temp = volumeVariance[0];
      for (let index = 1; index <= cubeIndex; ++index) {
        if (volumeVariance[index] > temp) {
          temp = volumeVariance[index];
          next = index;
        }
      }
      if (temp <= 0) {
        this._colors = cubeIndex + 1;
        break;
      }
    }
    const lookupRed = [];
    const lookupGreen = [];
    const lookupBlue = [];
    const lookupAlpha = [];
    for (let k = 0; k < this._colors; ++k) {
      const weight = _WuQuant._volume(this._cubes[k], this._weights);
      if (weight > 0) {
        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
      } else {
        lookupRed[k] = 0;
        lookupGreen[k] = 0;
        lookupBlue[k] = 0;
        lookupAlpha[k] = 0;
      }
    }
    this._reds = createArray1D(this._colors + 1);
    this._greens = createArray1D(this._colors + 1);
    this._blues = createArray1D(this._colors + 1);
    this._alphas = createArray1D(this._colors + 1);
    this._sums = createArray1D(this._colors + 1);
    for (let index = 0, l = this._pixels.length; index < l; index++) {
      const color = this._pixels[index];
      const match = -1;
      let bestMatch = match;
      let bestDistance = Number.MAX_VALUE;
      for (let lookup = 0; lookup < this._colors; lookup++) {
        const foundRed = lookupRed[lookup];
        const foundGreen = lookupGreen[lookup];
        const foundBlue = lookupBlue[lookup];
        const foundAlpha = lookupAlpha[lookup];
        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestMatch = lookup;
        }
      }
      this._reds[bestMatch] += color.r;
      this._greens[bestMatch] += color.g;
      this._blues[bestMatch] += color.b;
      this._alphas[bestMatch] += color.a;
      this._sums[bestMatch]++;
    }
  }
  _addColor(color) {
    const bitsToRemove = 8 - this._significantBitsPerChannel;
    const indexRed = (color.r >> bitsToRemove) + 1;
    const indexGreen = (color.g >> bitsToRemove) + 1;
    const indexBlue = (color.b >> bitsToRemove) + 1;
    const indexAlpha = (color.a >> bitsToRemove) + 1;
    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
  }
  *_calculateMoments() {
    const area = [];
    const areaRed = [];
    const areaGreen = [];
    const areaBlue = [];
    const areaAlpha = [];
    const area2 = [];
    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let trackerProgress = 0;
    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
        if (tracker.shouldNotify(trackerProgress)) {
          yield {
            progress: tracker.progress
          };
        }
        fillArray1D(area, this._sideSize, 0);
        fillArray1D(areaRed, this._sideSize, 0);
        fillArray1D(areaGreen, this._sideSize, 0);
        fillArray1D(areaBlue, this._sideSize, 0);
        fillArray1D(areaAlpha, this._sideSize, 0);
        fillArray1D(area2, this._sideSize, 0);
        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
          let line = 0;
          let lineRed = 0;
          let lineGreen = 0;
          let lineBlue = 0;
          let lineAlpha = 0;
          let line2 = 0;
          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
            area[blueIndex] += line;
            areaRed[blueIndex] += lineRed;
            areaGreen[blueIndex] += lineGreen;
            areaBlue[blueIndex] += lineBlue;
            areaAlpha[blueIndex] += lineAlpha;
            area2[blueIndex] += line2;
            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
          }
        }
      }
    }
  }
  static _volumeFloat(cube, moment) {
    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
  }
  static _volume(cube, moment) {
    return _WuQuant._volumeFloat(cube, moment) | 0;
  }
  static _top(cube, direction, position, moment) {
    let result;
    switch (direction) {
      case _WuQuant._alpha:
        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._red:
        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._green:
        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
        break;
      case _WuQuant._blue:
        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
        break;
      default:
        throw new Error("impossible");
    }
    return result | 0;
  }
  static _bottom(cube, direction, moment) {
    switch (direction) {
      case _WuQuant._alpha:
        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._red:
        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._green:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._blue:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(cube) {
    const volumeRed = _WuQuant._volume(cube, this._momentsRed);
    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
    const volumeWeight = _WuQuant._volume(cube, this._weights);
    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
    return volumeMoment - distance / volumeWeight;
  }
  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
    let result = 0;
    let cutPosition = -1;
    for (let position = first; position < last; ++position) {
      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
      if (halfWeight !== 0) {
        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
        let temp = halfDistance / halfWeight;
        halfRed = wholeRed - halfRed;
        halfGreen = wholeGreen - halfGreen;
        halfBlue = wholeBlue - halfBlue;
        halfAlpha = wholeAlpha - halfAlpha;
        halfWeight = wholeWeight - halfWeight;
        if (halfWeight !== 0) {
          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
          temp += halfDistance / halfWeight;
          if (temp > result) {
            result = temp;
            cutPosition = position;
          }
        }
      }
    }
    return { max: result, position: cutPosition };
  }
  _cut(first, second) {
    let direction;
    const wholeRed = _WuQuant._volume(first, this._momentsRed);
    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
    const wholeWeight = _WuQuant._volume(first, this._weights);
    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
      direction = _WuQuant._alpha;
      if (alpha.position < 0)
        return false;
    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
      direction = _WuQuant._red;
    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
      direction = _WuQuant._green;
    } else {
      direction = _WuQuant._blue;
    }
    second.redMaximum = first.redMaximum;
    second.greenMaximum = first.greenMaximum;
    second.blueMaximum = first.blueMaximum;
    second.alphaMaximum = first.alphaMaximum;
    switch (direction) {
      case _WuQuant._red:
        second.redMinimum = first.redMaximum = red.position;
        second.greenMinimum = first.greenMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._green:
        second.greenMinimum = first.greenMaximum = green.position;
        second.redMinimum = first.redMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._blue:
        second.blueMinimum = first.blueMaximum = blue.position;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._alpha:
        second.alphaMinimum = first.alphaMaximum = alpha.position;
        second.blueMinimum = first.blueMinimum;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        break;
    }
    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
    return true;
  }
  _initialize(colors) {
    this._colors = colors;
    this._cubes = [];
    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
      this._cubes[cubeIndex] = new WuColorCube();
    }
    this._cubes[0].redMinimum = 0;
    this._cubes[0].greenMinimum = 0;
    this._cubes[0].blueMinimum = 0;
    this._cubes[0].alphaMinimum = 0;
    this._cubes[0].redMaximum = this._maxSideIndex;
    this._cubes[0].greenMaximum = this._maxSideIndex;
    this._cubes[0].blueMaximum = this._maxSideIndex;
    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._table = [];
    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
      this._table[tableIndex] = tableIndex * tableIndex;
    }
    this._pixels = [];
  }
  _setQuality(significantBitsPerChannel = 5) {
    this._significantBitsPerChannel = significantBitsPerChannel;
    this._maxSideIndex = 1 << this._significantBitsPerChannel;
    this._alphaMaxSideIndex = this._maxSideIndex;
    this._sideSize = this._maxSideIndex + 1;
    this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
};
var WuQuant = _WuQuant;
__publicField(WuQuant, "_alpha", 3);
__publicField(WuQuant, "_red", 2);
__publicField(WuQuant, "_green", 1);
__publicField(WuQuant, "_blue", 0);

// src/image/index.ts
var image_exports = {};
__export(image_exports, {
  AbstractImageQuantizer: () => AbstractImageQuantizer,
  ErrorDiffusionArray: () => ErrorDiffusionArray,
  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
  NearestColor: () => NearestColor
});

// src/image/imageQuantizer.ts
var AbstractImageQuantizer = class {
  quantizeSync(pointContainer, palette) {
    for (const value of this.quantize(pointContainer, palette)) {
      if (value.pointContainer) {
        return value.pointContainer;
      }
    }
    throw new Error("unreachable");
  }
};

// src/image/nearestColor.ts
var NearestColor = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator) {
    super();
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0; y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
        const point = pointArray[idx];
        point.from(palette.getNearestColor(this._distance, point));
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
};

// src/image/array.ts
var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
  return ErrorDiffusionArrayKernel2;
})(ErrorDiffusionArrayKernel || {});
var ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
    super();
    __publicField(this, "_minColorDistance");
    __publicField(this, "_serpentine");
    __publicField(this, "_kernel");
    __publicField(this, "_calculateErrorLikeGIMP");
    __publicField(this, "_distance");
    this._setKernel(kernel);
    this._distance = colorDistanceCalculator;
    this._minColorDistance = minimumColorDistanceToDither;
    this._serpentine = serpentine;
    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const originalPoint = new Point();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorLines = [];
    let dir = 1;
    let maxErrorLines = 1;
    for (const kernel of this._kernel) {
      const kernelErrorLines = kernel[2] + 1;
      if (maxErrorLines < kernelErrorLines)
        maxErrorLines = kernelErrorLines;
    }
    for (let i = 0; i < maxErrorLines; i++) {
      this._fillErrorLine(errorLines[i] = [], width);
    }
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0; y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      if (this._serpentine)
        dir *= -1;
      const lni = y2 * width;
      const xStart = dir === 1 ? 0 : width - 1;
      const xEnd = dir === 1 ? width : -1;
      this._fillErrorLine(errorLines[0], width);
      errorLines.push(errorLines.shift());
      const errorLine = errorLines[0];
      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
        const point = pointArray[idx];
        const error = errorLine[x2];
        originalPoint.from(point);
        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);
        point.from(palettePoint);
        if (this._minColorDistance) {
          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
          if (dist < this._minColorDistance)
            continue;
        }
        let er;
        let eg;
        let eb;
        let ea;
        if (this._calculateErrorLikeGIMP) {
          er = correctedPoint.r - palettePoint.r;
          eg = correctedPoint.g - palettePoint.g;
          eb = correctedPoint.b - palettePoint.b;
          ea = correctedPoint.a - palettePoint.a;
        } else {
          er = originalPoint.r - palettePoint.r;
          eg = originalPoint.g - palettePoint.g;
          eb = originalPoint.b - palettePoint.b;
          ea = originalPoint.a - palettePoint.a;
        }
        const dStart = dir === 1 ? 0 : this._kernel.length - 1;
        const dEnd = dir === 1 ? this._kernel.length : -1;
        for (let i = dStart; i !== dEnd; i += dir) {
          const x1 = this._kernel[i][1] * dir;
          const y1 = this._kernel[i][2];
          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
            const d = this._kernel[i][0];
            const e = errorLines[y1][x1 + x2];
            e[0] += er * d;
            e[1] += eg * d;
            e[2] += eb * d;
            e[3] += ea * d;
          }
        }
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
  _fillErrorLine(errorLine, width) {
    if (errorLine.length > width) {
      errorLine.length = width;
    }
    const l = errorLine.length;
    for (let i = 0; i < l; i++) {
      const error = errorLine[i];
      error[0] = error[1] = error[2] = error[3] = 0;
    }
    for (let i = l; i < width; i++) {
      errorLine[i] = [0, 0, 0, 0];
    }
  }
  _setKernel(kernel) {
    switch (kernel) {
      case 0 /* FloydSteinberg */:
        this._kernel = [
          [7 / 16, 1, 0],
          [3 / 16, -1, 1],
          [5 / 16, 0, 1],
          [1 / 16, 1, 1]
        ];
        break;
      case 1 /* FalseFloydSteinberg */:
        this._kernel = [
          [3 / 8, 1, 0],
          [3 / 8, 0, 1],
          [2 / 8, 1, 1]
        ];
        break;
      case 2 /* Stucki */:
        this._kernel = [
          [8 / 42, 1, 0],
          [4 / 42, 2, 0],
          [2 / 42, -2, 1],
          [4 / 42, -1, 1],
          [8 / 42, 0, 1],
          [4 / 42, 1, 1],
          [2 / 42, 2, 1],
          [1 / 42, -2, 2],
          [2 / 42, -1, 2],
          [4 / 42, 0, 2],
          [2 / 42, 1, 2],
          [1 / 42, 2, 2]
        ];
        break;
      case 3 /* Atkinson */:
        this._kernel = [
          [1 / 8, 1, 0],
          [1 / 8, 2, 0],
          [1 / 8, -1, 1],
          [1 / 8, 0, 1],
          [1 / 8, 1, 1],
          [1 / 8, 0, 2]
        ];
        break;
      case 4 /* Jarvis */:
        this._kernel = [
          [7 / 48, 1, 0],
          [5 / 48, 2, 0],
          [3 / 48, -2, 1],
          [5 / 48, -1, 1],
          [7 / 48, 0, 1],
          [5 / 48, 1, 1],
          [3 / 48, 2, 1],
          [1 / 48, -2, 2],
          [3 / 48, -1, 2],
          [5 / 48, 0, 2],
          [3 / 48, 1, 2],
          [1 / 48, 2, 2]
        ];
        break;
      case 5 /* Burkes */:
        this._kernel = [
          [8 / 32, 1, 0],
          [4 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [8 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1]
        ];
        break;
      case 6 /* Sierra */:
        this._kernel = [
          [5 / 32, 1, 0],
          [3 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [5 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1],
          [2 / 32, -1, 2],
          [3 / 32, 0, 2],
          [2 / 32, 1, 2]
        ];
        break;
      case 7 /* TwoSierra */:
        this._kernel = [
          [4 / 16, 1, 0],
          [3 / 16, 2, 0],
          [1 / 16, -2, 1],
          [2 / 16, -1, 1],
          [3 / 16, 0, 1],
          [2 / 16, 1, 1],
          [1 / 16, 2, 1]
        ];
        break;
      case 8 /* SierraLite */:
        this._kernel = [
          [2 / 4, 1, 0],
          [1 / 4, -1, 1],
          [1 / 4, 0, 1]
        ];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
    }
  }
};

// src/image/spaceFillingCurves/hilbertCurve.ts
function* hilbertCurve(width, height, callback) {
  const maxBound = Math.max(width, height);
  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
  const tracker = new ProgressTracker(width * height, 99);
  const data = {
    width,
    height,
    level,
    callback,
    tracker,
    index: 0,
    x: 0,
    y: 0
  };
  yield* walkHilbert(data, 1 /* UP */);
  visit(data, 0 /* NONE */);
}
function* walkHilbert(data, direction) {
  if (data.level < 1)
    return;
  if (data.tracker.shouldNotify(data.index)) {
    yield { progress: data.tracker.progress };
  }
  data.level--;
  switch (direction) {
    case 2 /* LEFT */:
      yield* walkHilbert(data, 1 /* UP */);
      visit(data, 3 /* RIGHT */);
      yield* walkHilbert(data, 2 /* LEFT */);
      visit(data, 4 /* DOWN */);
      yield* walkHilbert(data, 2 /* LEFT */);
      visit(data, 2 /* LEFT */);
      yield* walkHilbert(data, 4 /* DOWN */);
      break;
    case 3 /* RIGHT */:
      yield* walkHilbert(data, 4 /* DOWN */);
      visit(data, 2 /* LEFT */);
      yield* walkHilbert(data, 3 /* RIGHT */);
      visit(data, 1 /* UP */);
      yield* walkHilbert(data, 3 /* RIGHT */);
      visit(data, 3 /* RIGHT */);
      yield* walkHilbert(data, 1 /* UP */);
      break;
    case 1 /* UP */:
      yield* walkHilbert(data, 2 /* LEFT */);
      visit(data, 4 /* DOWN */);
      yield* walkHilbert(data, 1 /* UP */);
      visit(data, 3 /* RIGHT */);
      yield* walkHilbert(data, 1 /* UP */);
      visit(data, 1 /* UP */);
      yield* walkHilbert(data, 3 /* RIGHT */);
      break;
    case 4 /* DOWN */:
      yield* walkHilbert(data, 3 /* RIGHT */);
      visit(data, 1 /* UP */);
      yield* walkHilbert(data, 4 /* DOWN */);
      visit(data, 2 /* LEFT */);
      yield* walkHilbert(data, 4 /* DOWN */);
      visit(data, 4 /* DOWN */);
      yield* walkHilbert(data, 2 /* LEFT */);
      break;
  }
  data.level++;
}
function visit(data, direction) {
  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
    data.callback(data.x, data.y);
    data.index++;
  }
  switch (direction) {
    case 2 /* LEFT */:
      data.x--;
      break;
    case 3 /* RIGHT */:
      data.x++;
      break;
    case 1 /* UP */:
      data.y--;
      break;
    case 4 /* DOWN */:
      data.y++;
      break;
  }
}

// src/image/riemersma.ts
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
    super();
    __publicField(this, "_distance");
    __publicField(this, "_weights");
    __publicField(this, "_errorQueueSize");
    this._distance = colorDistanceCalculator;
    this._errorQueueSize = errorQueueSize;
    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorQueue = [];
    let head = 0;
    for (let i = 0; i < this._errorQueueSize; i++) {
      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
    }
    yield* hilbertCurve(width, height, (x2, y2) => {
      const p = pointArray[x2 + y2 * width];
      let { r, g, b, a } = p;
      for (let i = 0; i < this._errorQueueSize; i++) {
        const weight = this._weights[i];
        const e = errorQueue[(i + head) % this._errorQueueSize];
        r += e.r * weight;
        g += e.g * weight;
        b += e.b * weight;
        a += e.a * weight;
      }
      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
      head = (head + 1) % this._errorQueueSize;
      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
      errorQueue[tail].r = p.r - quantizedPoint.r;
      errorQueue[tail].g = p.g - quantizedPoint.g;
      errorQueue[tail].b = p.b - quantizedPoint.b;
      errorQueue[tail].a = p.a - quantizedPoint.a;
      p.from(quantizedPoint);
    });
    yield {
      pointContainer,
      progress: 100
    };
  }
  static _createWeights(errorPropagation, errorQueueSize) {
    const weights = [];
    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
    for (let i = 0, next = 1; i < errorQueueSize; i++) {
      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
      next *= multiplier;
    }
    return weights;
  }
};

// src/quality/index.ts
var quality_exports = {};
__export(quality_exports, {
  ssim: () => ssim
});

// src/quality/ssim.ts
var K1 = 0.01;
var K2 = 0.03;
function ssim(image1, image2) {
  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
    throw new Error("Images have different sizes!");
  }
  const bitsPerComponent = 8;
  const L = (1 << bitsPerComponent) - 1;
  const c1 = (K1 * L) ** 2;
  const c2 = (K2 * L) ** 2;
  let numWindows = 0;
  let mssim = 0;
  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
    let sigxy = 0;
    let sigsqx = 0;
    let sigsqy = 0;
    for (let i = 0; i < lumaValues1.length; i++) {
      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;
      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;
      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
    }
    const numPixelsInWin = lumaValues1.length - 1;
    sigsqx /= numPixelsInWin;
    sigsqy /= numPixelsInWin;
    sigxy /= numPixelsInWin;
    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
    const ssim2 = numerator / denominator;
    mssim += ssim2;
    numWindows++;
  });
  return mssim / numWindows;
}
function iterate(image1, image2, callback) {
  const windowSize = 8;
  const width = image1.getWidth();
  const height = image1.getHeight();
  for (let y2 = 0; y2 < height; y2 += windowSize) {
    for (let x2 = 0; x2 < width; x2 += windowSize) {
      const windowWidth = Math.min(windowSize, width - x2);
      const windowHeight = Math.min(windowSize, height - y2);
      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
      const averageLuma1 = calculateAverageLuma(lumaValues1);
      const averageLuma2 = calculateAverageLuma(lumaValues2);
      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
    }
  }
}
function calculateLumaValuesForWindow(image, x2, y2, width, height) {
  const pointArray = image.getPointArray();
  const lumaValues = [];
  let counter = 0;
  for (let j = y2; j < y2 + height; j++) {
    const offset = j * image.getWidth();
    for (let i = x2; i < x2 + width; i++) {
      const point = pointArray[offset + i];
      lumaValues[counter] = point.r * 0.2126 /* RED */ + point.g * 0.7152 /* GREEN */ + point.b * 0.0722 /* BLUE */;
      counter++;
    }
  }
  return lumaValues;
}
function calculateAverageLuma(lumaValues) {
  let sumLuma = 0;
  for (const luma of lumaValues) {
    sumLuma += luma;
  }
  return sumLuma / lumaValues.length;
}

// src/basicAPI.ts
typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? void 0 : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
function buildPaletteSync(images, {
  colorDistanceFormula,
  paletteQuantization,
  colors
} = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
  images.forEach((image) => paletteQuantizer.sample(image));
  return paletteQuantizer.quantizeSync();
}
function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
  return imageQuantizer.quantizeSync(image, palette);
}
function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
  switch (colorDistanceFormula) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
  }
}
function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
  switch (imageQuantization) {
    case "nearest":
      return new NearestColor(distanceCalculator);
    case "riemersma":
      return new ErrorDiffusionRiemersma(distanceCalculator);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(distanceCalculator, 0 /* FloydSteinberg */);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(distanceCalculator, 1 /* FalseFloydSteinberg */);
    case "stucki":
      return new ErrorDiffusionArray(distanceCalculator, 2 /* Stucki */);
    case "atkinson":
      return new ErrorDiffusionArray(distanceCalculator, 3 /* Atkinson */);
    case "jarvis":
      return new ErrorDiffusionArray(distanceCalculator, 4 /* Jarvis */);
    case "burkes":
      return new ErrorDiffusionArray(distanceCalculator, 5 /* Burkes */);
    case "sierra":
      return new ErrorDiffusionArray(distanceCalculator, 6 /* Sierra */);
    case "two-sierra":
      return new ErrorDiffusionArray(distanceCalculator, 7 /* TwoSierra */);
    case "sierra-lite":
      return new ErrorDiffusionArray(distanceCalculator, 8 /* SierraLite */);
    default:
      throw new Error(`Unknown imageQuantization ${imageQuantization}`);
  }
}
function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
  switch (paletteQuantization) {
    case "neuquant":
      return new NeuQuant(distanceCalculator, colors);
    case "rgbquant":
      return new RGBQuant(distanceCalculator, colors);
    case "wuquant":
      return new WuQuant(distanceCalculator, colors);
    case "neuquant-float":
      return new NeuQuantFloat(distanceCalculator, colors);
    default:
      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
  }
}
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */

const QuantizeOptionsSchema = z.object({
    colors: z.number().optional(),
    colorDistanceFormula: z
        .union([
        z.literal("cie94-textiles"),
        z.literal("cie94-graphic-arts"),
        z.literal("ciede2000"),
        z.literal("color-metric"),
        z.literal("euclidean"),
        z.literal("euclidean-bt709-noalpha"),
        z.literal("euclidean-bt709"),
        z.literal("manhattan"),
        z.literal("manhattan-bt709"),
        z.literal("manhattan-nommyde"),
        z.literal("pngquant"),
    ])
        .optional(),
    paletteQuantization: z
        .union([
        z.literal("neuquant"),
        z.literal("neuquant-float"),
        z.literal("rgbquant"),
        z.literal("wuquant"),
    ])
        .optional(),
    imageQuantization: z
        .union([
        z.literal("nearest"),
        z.literal("riemersma"),
        z.literal("floyd-steinberg"),
        z.literal("false-floyd-steinberg"),
        z.literal("stucki"),
        z.literal("atkinson"),
        z.literal("jarvis"),
        z.literal("burkes"),
        z.literal("sierra"),
        z.literal("two-sierra"),
        z.literal("sierra-lite"),
    ])
        .optional(),
});
const methods = {
    /**
     * Image color number reduction.
     */
    quantize(image, options) {
        const { colors, colorDistanceFormula, paletteQuantization, imageQuantization, } = QuantizeOptionsSchema.parse(options);
        const inPointContainer = utils_exports.PointContainer.fromUint8Array(image.bitmap.data, image.bitmap.width, image.bitmap.height);
        const palette = buildPaletteSync([inPointContainer], {
            colors,
            colorDistanceFormula,
            paletteQuantization,
        });
        const outPointContainer = applyPaletteSync(inPointContainer, palette, {
            colorDistanceFormula,
            imageQuantization,
        });
        image.bitmap.data = Buffer.from(outPointContainer.toUint8Array());
        return image;
    },
};

/**
 * @module jimp
 */
// import { Jimp } from "@jimp/core";
const defaultPlugins = [
    methods$h,
    methods$g,
    methods$f,
    methods$e,
    methods$c,
    methods$a,
    methods$b,
    methods$9,
    methods$8,
    methods$7,
    methods$6,
    methods$5,
    methods$4,
    methods$3,
    methods$d,
    methods$2,
    methods$1,
    methods,
];
const defaultFormats = [bmp, msBmp, gif, jpeg$1, png, tiff];
/** Convenience object for getting the MIME types of the default formats */
({
    bmp: bmp().mime,
    gif: gif().mime,
    jpeg: jpeg$1().mime,
    png: png().mime,
    tiff: tiff().mime,
});
// TODO: This doesn't document the constructor of the class
/**
 * @class
 *
 * A `Jimp` class enables you to:class
 *
 * - Read an image into a "bit map" (a collection of pixels)
 * - Modify the bit map through methods that change the pixels
 * - Write the bit map back to an image buffer
 *
 * @example
 *
 * #### Basic
 *
 * You can use the Jimp class to make empty images.
 * This is useful for when you want to create an image that composed of other images on top of a background.
 *
 * ```ts
 * import { Jimp } from "jimp";
 *
 * const image = new Jimp({ width: 256, height: 256, color: 0xffffffff });
 * const image2 = new Jimp({ width: 100, height: 100, color: 0xff0000ff });
 *
 * image.composite(image2, 50, 50);
 * ```
 *
 * #### Node
 *
 * You can use jimp in Node.js.
 * For example you can read an image from a file and resize it and
 * then write it back to a file.
 *
 * ```ts
 * import { Jimp } from "jimp";
 * import { promises as fs } from "fs";
 *
 * const image = await Jimp.read("test/image.png");
 *
 * image.resize(256, 100);
 * image.greyscale();
 *
 * await image.write('test/output.png');
 * ```
 *
 * #### Browser
 *
 * You can use jimp in the browser by reading files from URLs
 *
 * ```ts
 * import { Jimp } from "jimp";
 *
 * const image = await Jimp.read("https://upload.wikimedia.org/wikipedia/commons/0/01/Bot-Test.jpg");
 *
 * image.resize(256, 100);
 * image.greyscale();
 *
 * const output = await image.getBuffer("test/image.png");
 *
 * const canvas = document.createElement("canvas");
 *
 * canvas.width = image.bitmap.width;
 * canvas.height = image.bitmap.height;
 *
 * const ctx = canvas.getContext("2d");
 * ctx.putImageData(image.bitmap, 0, 0);
 *
 * document.body.appendChild(canvas);
 * ```
 */
const Jimp = createJimp({
    formats: defaultFormats,
    plugins: defaultPlugins,
});

var jsQR$2 = {exports: {}};

var jsQR$1 = jsQR$2.exports;

var hasRequiredJsQR;

function requireJsQR () {
	if (hasRequiredJsQR) return jsQR$2.exports;
	hasRequiredJsQR = 1;
	(function (module, exports$1) {
		(function webpackUniversalModuleDefinition(root, factory) {
			module.exports = factory();
		})(typeof self !== 'undefined' ? self : jsQR$1, function() {
		return /******/ (function(modules) { // webpackBootstrap
		/******/ 	// The module cache
		/******/ 	var installedModules = {};
		/******/
		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {
		/******/
		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId]) {
		/******/ 			return installedModules[moduleId].exports;
		/******/ 		}
		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
		/******/ 			i: moduleId,
		/******/ 			l: false,
		/******/ 			exports: {}
		/******/ 		};
		/******/
		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ 		// Flag the module as loaded
		/******/ 		module.l = true;
		/******/
		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}
		/******/
		/******/
		/******/ 	// expose the modules object (__webpack_modules__)
		/******/ 	__webpack_require__.m = modules;
		/******/
		/******/ 	// expose the module cache
		/******/ 	__webpack_require__.c = installedModules;
		/******/
		/******/ 	// define getter function for harmony exports
		/******/ 	__webpack_require__.d = function(exports$1, name, getter) {
		/******/ 		if(!__webpack_require__.o(exports$1, name)) {
		/******/ 			Object.defineProperty(exports$1, name, {
		/******/ 				configurable: false,
		/******/ 				enumerable: true,
		/******/ 				get: getter
		/******/ 			});
		/******/ 		}
		/******/ 	};
		/******/
		/******/ 	// getDefaultExport function for compatibility with non-harmony modules
		/******/ 	__webpack_require__.n = function(module) {
		/******/ 		var getter = module && module.__esModule ?
		/******/ 			function getDefault() { return module['default']; } :
		/******/ 			function getModuleExports() { return module; };
		/******/ 		__webpack_require__.d(getter, 'a', getter);
		/******/ 		return getter;
		/******/ 	};
		/******/
		/******/ 	// Object.prototype.hasOwnProperty.call
		/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
		/******/
		/******/ 	// __webpack_public_path__
		/******/ 	__webpack_require__.p = "";
		/******/
		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(__webpack_require__.s = 3);
		/******/ })
		/************************************************************************/
		/******/ ([
		/* 0 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var BitMatrix = /** @class */ (function () {
		    function BitMatrix(data, width) {
		        this.width = width;
		        this.height = data.length / width;
		        this.data = data;
		    }
		    BitMatrix.createEmpty = function (width, height) {
		        return new BitMatrix(new Uint8ClampedArray(width * height), width);
		    };
		    BitMatrix.prototype.get = function (x, y) {
		        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
		            return false;
		        }
		        return !!this.data[y * this.width + x];
		    };
		    BitMatrix.prototype.set = function (x, y, v) {
		        this.data[y * this.width + x] = v ? 1 : 0;
		    };
		    BitMatrix.prototype.setRegion = function (left, top, width, height, v) {
		        for (var y = top; y < top + height; y++) {
		            for (var x = left; x < left + width; x++) {
		                this.set(x, y, !!v);
		            }
		        }
		    };
		    return BitMatrix;
		}());
		exports$1.BitMatrix = BitMatrix;


		/***/ }),
		/* 1 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var GenericGFPoly_1 = __webpack_require__(2);
		function addOrSubtractGF(a, b) {
		    return a ^ b; // tslint:disable-line:no-bitwise
		}
		exports$1.addOrSubtractGF = addOrSubtractGF;
		var GenericGF = /** @class */ (function () {
		    function GenericGF(primitive, size, genBase) {
		        this.primitive = primitive;
		        this.size = size;
		        this.generatorBase = genBase;
		        this.expTable = new Array(this.size);
		        this.logTable = new Array(this.size);
		        var x = 1;
		        for (var i = 0; i < this.size; i++) {
		            this.expTable[i] = x;
		            x = x * 2;
		            if (x >= this.size) {
		                x = (x ^ this.primitive) & (this.size - 1); // tslint:disable-line:no-bitwise
		            }
		        }
		        for (var i = 0; i < this.size - 1; i++) {
		            this.logTable[this.expTable[i]] = i;
		        }
		        this.zero = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([0]));
		        this.one = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([1]));
		    }
		    GenericGF.prototype.multiply = function (a, b) {
		        if (a === 0 || b === 0) {
		            return 0;
		        }
		        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
		    };
		    GenericGF.prototype.inverse = function (a) {
		        if (a === 0) {
		            throw new Error("Can't invert 0");
		        }
		        return this.expTable[this.size - this.logTable[a] - 1];
		    };
		    GenericGF.prototype.buildMonomial = function (degree, coefficient) {
		        if (degree < 0) {
		            throw new Error("Invalid monomial degree less than 0");
		        }
		        if (coefficient === 0) {
		            return this.zero;
		        }
		        var coefficients = new Uint8ClampedArray(degree + 1);
		        coefficients[0] = coefficient;
		        return new GenericGFPoly_1.default(this, coefficients);
		    };
		    GenericGF.prototype.log = function (a) {
		        if (a === 0) {
		            throw new Error("Can't take log(0)");
		        }
		        return this.logTable[a];
		    };
		    GenericGF.prototype.exp = function (a) {
		        return this.expTable[a];
		    };
		    return GenericGF;
		}());
		exports$1.default = GenericGF;


		/***/ }),
		/* 2 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var GenericGF_1 = __webpack_require__(1);
		var GenericGFPoly = /** @class */ (function () {
		    function GenericGFPoly(field, coefficients) {
		        if (coefficients.length === 0) {
		            throw new Error("No coefficients.");
		        }
		        this.field = field;
		        var coefficientsLength = coefficients.length;
		        if (coefficientsLength > 1 && coefficients[0] === 0) {
		            // Leading term must be non-zero for anything except the constant polynomial "0"
		            var firstNonZero = 1;
		            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
		                firstNonZero++;
		            }
		            if (firstNonZero === coefficientsLength) {
		                this.coefficients = field.zero.coefficients;
		            }
		            else {
		                this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);
		                for (var i = 0; i < this.coefficients.length; i++) {
		                    this.coefficients[i] = coefficients[firstNonZero + i];
		                }
		            }
		        }
		        else {
		            this.coefficients = coefficients;
		        }
		    }
		    GenericGFPoly.prototype.degree = function () {
		        return this.coefficients.length - 1;
		    };
		    GenericGFPoly.prototype.isZero = function () {
		        return this.coefficients[0] === 0;
		    };
		    GenericGFPoly.prototype.getCoefficient = function (degree) {
		        return this.coefficients[this.coefficients.length - 1 - degree];
		    };
		    GenericGFPoly.prototype.addOrSubtract = function (other) {
		        var _a;
		        if (this.isZero()) {
		            return other;
		        }
		        if (other.isZero()) {
		            return this;
		        }
		        var smallerCoefficients = this.coefficients;
		        var largerCoefficients = other.coefficients;
		        if (smallerCoefficients.length > largerCoefficients.length) {
		            _a = [largerCoefficients, smallerCoefficients], smallerCoefficients = _a[0], largerCoefficients = _a[1];
		        }
		        var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
		        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
		        for (var i = 0; i < lengthDiff; i++) {
		            sumDiff[i] = largerCoefficients[i];
		        }
		        for (var i = lengthDiff; i < largerCoefficients.length; i++) {
		            sumDiff[i] = GenericGF_1.addOrSubtractGF(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
		        }
		        return new GenericGFPoly(this.field, sumDiff);
		    };
		    GenericGFPoly.prototype.multiply = function (scalar) {
		        if (scalar === 0) {
		            return this.field.zero;
		        }
		        if (scalar === 1) {
		            return this;
		        }
		        var size = this.coefficients.length;
		        var product = new Uint8ClampedArray(size);
		        for (var i = 0; i < size; i++) {
		            product[i] = this.field.multiply(this.coefficients[i], scalar);
		        }
		        return new GenericGFPoly(this.field, product);
		    };
		    GenericGFPoly.prototype.multiplyPoly = function (other) {
		        if (this.isZero() || other.isZero()) {
		            return this.field.zero;
		        }
		        var aCoefficients = this.coefficients;
		        var aLength = aCoefficients.length;
		        var bCoefficients = other.coefficients;
		        var bLength = bCoefficients.length;
		        var product = new Uint8ClampedArray(aLength + bLength - 1);
		        for (var i = 0; i < aLength; i++) {
		            var aCoeff = aCoefficients[i];
		            for (var j = 0; j < bLength; j++) {
		                product[i + j] = GenericGF_1.addOrSubtractGF(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
		            }
		        }
		        return new GenericGFPoly(this.field, product);
		    };
		    GenericGFPoly.prototype.multiplyByMonomial = function (degree, coefficient) {
		        if (degree < 0) {
		            throw new Error("Invalid degree less than 0");
		        }
		        if (coefficient === 0) {
		            return this.field.zero;
		        }
		        var size = this.coefficients.length;
		        var product = new Uint8ClampedArray(size + degree);
		        for (var i = 0; i < size; i++) {
		            product[i] = this.field.multiply(this.coefficients[i], coefficient);
		        }
		        return new GenericGFPoly(this.field, product);
		    };
		    GenericGFPoly.prototype.evaluateAt = function (a) {
		        var result = 0;
		        if (a === 0) {
		            // Just return the x^0 coefficient
		            return this.getCoefficient(0);
		        }
		        var size = this.coefficients.length;
		        if (a === 1) {
		            // Just the sum of the coefficients
		            this.coefficients.forEach(function (coefficient) {
		                result = GenericGF_1.addOrSubtractGF(result, coefficient);
		            });
		            return result;
		        }
		        result = this.coefficients[0];
		        for (var i = 1; i < size; i++) {
		            result = GenericGF_1.addOrSubtractGF(this.field.multiply(a, result), this.coefficients[i]);
		        }
		        return result;
		    };
		    return GenericGFPoly;
		}());
		exports$1.default = GenericGFPoly;


		/***/ }),
		/* 3 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var binarizer_1 = __webpack_require__(4);
		var decoder_1 = __webpack_require__(5);
		var extractor_1 = __webpack_require__(11);
		var locator_1 = __webpack_require__(12);
		function scan(matrix) {
		    var locations = locator_1.locate(matrix);
		    if (!locations) {
		        return null;
		    }
		    for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
		        var location_1 = locations_1[_i];
		        var extracted = extractor_1.extract(matrix, location_1);
		        var decoded = decoder_1.decode(extracted.matrix);
		        if (decoded) {
		            return {
		                binaryData: decoded.bytes,
		                data: decoded.text,
		                chunks: decoded.chunks,
		                version: decoded.version,
		                location: {
		                    topRightCorner: extracted.mappingFunction(location_1.dimension, 0),
		                    topLeftCorner: extracted.mappingFunction(0, 0),
		                    bottomRightCorner: extracted.mappingFunction(location_1.dimension, location_1.dimension),
		                    bottomLeftCorner: extracted.mappingFunction(0, location_1.dimension),
		                    topRightFinderPattern: location_1.topRight,
		                    topLeftFinderPattern: location_1.topLeft,
		                    bottomLeftFinderPattern: location_1.bottomLeft,
		                    bottomRightAlignmentPattern: location_1.alignmentPattern,
		                },
		            };
		        }
		    }
		    return null;
		}
		var defaultOptions = {
		    inversionAttempts: "attemptBoth",
		};
		function jsQR(data, width, height, providedOptions) {
		    if (providedOptions === void 0) { providedOptions = {}; }
		    var options = defaultOptions;
		    Object.keys(options || {}).forEach(function (opt) {
		        options[opt] = providedOptions[opt] || options[opt];
		    });
		    var shouldInvert = options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst";
		    var tryInvertedFirst = options.inversionAttempts === "onlyInvert" || options.inversionAttempts === "invertFirst";
		    var _a = binarizer_1.binarize(data, width, height, shouldInvert), binarized = _a.binarized, inverted = _a.inverted;
		    var result = scan(tryInvertedFirst ? inverted : binarized);
		    if (!result && (options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst")) {
		        result = scan(tryInvertedFirst ? binarized : inverted);
		    }
		    return result;
		}
		jsQR.default = jsQR;
		exports$1.default = jsQR;


		/***/ }),
		/* 4 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var BitMatrix_1 = __webpack_require__(0);
		var REGION_SIZE = 8;
		var MIN_DYNAMIC_RANGE = 24;
		function numBetween(value, min, max) {
		    return value < min ? min : value > max ? max : value;
		}
		// Like BitMatrix but accepts arbitry Uint8 values
		var Matrix = /** @class */ (function () {
		    function Matrix(width, height) {
		        this.width = width;
		        this.data = new Uint8ClampedArray(width * height);
		    }
		    Matrix.prototype.get = function (x, y) {
		        return this.data[y * this.width + x];
		    };
		    Matrix.prototype.set = function (x, y, value) {
		        this.data[y * this.width + x] = value;
		    };
		    return Matrix;
		}());
		function binarize(data, width, height, returnInverted) {
		    if (data.length !== width * height * 4) {
		        throw new Error("Malformed data passed to binarizer.");
		    }
		    // Convert image to greyscale
		    var greyscalePixels = new Matrix(width, height);
		    for (var x = 0; x < width; x++) {
		        for (var y = 0; y < height; y++) {
		            var r = data[((y * width + x) * 4) + 0];
		            var g = data[((y * width + x) * 4) + 1];
		            var b = data[((y * width + x) * 4) + 2];
		            greyscalePixels.set(x, y, 0.2126 * r + 0.7152 * g + 0.0722 * b);
		        }
		    }
		    var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
		    var verticalRegionCount = Math.ceil(height / REGION_SIZE);
		    var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);
		    for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
		        for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
		            var sum = 0;
		            var min = Infinity;
		            var max = 0;
		            for (var y = 0; y < REGION_SIZE; y++) {
		                for (var x = 0; x < REGION_SIZE; x++) {
		                    var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);
		                    sum += pixelLumosity;
		                    min = Math.min(min, pixelLumosity);
		                    max = Math.max(max, pixelLumosity);
		                }
		            }
		            var average = sum / (Math.pow(REGION_SIZE, 2));
		            if (max - min <= MIN_DYNAMIC_RANGE) {
		                // If variation within the block is low, assume this is a block with only light or only
		                // dark pixels. In that case we do not want to use the average, as it would divide this
		                // low contrast area into black and white pixels, essentially creating data out of noise.
		                //
		                // Default the blackpoint for these blocks to be half the min - effectively white them out
		                average = min / 2;
		                if (verticalRegion > 0 && hortizontalRegion > 0) {
		                    // Correct the "white background" assumption for blocks that have neighbors by comparing
		                    // the pixels in this block to the previously calculated black points. This is based on
		                    // the fact that dark barcode symbology is always surrounded by some amount of light
		                    // background for which reasonable black point estimates were made. The bp estimated at
		                    // the boundaries is used for the interior.
		                    // The (min < bp) is arbitrary but works better than other heuristics that were tried.
		                    var averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - 1) +
		                        (2 * blackPoints.get(hortizontalRegion - 1, verticalRegion)) +
		                        blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) / 4;
		                    if (min < averageNeighborBlackPoint) {
		                        average = averageNeighborBlackPoint;
		                    }
		                }
		            }
		            blackPoints.set(hortizontalRegion, verticalRegion, average);
		        }
		    }
		    var binarized = BitMatrix_1.BitMatrix.createEmpty(width, height);
		    var inverted = null;
		    if (returnInverted) {
		        inverted = BitMatrix_1.BitMatrix.createEmpty(width, height);
		    }
		    for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
		        for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
		            var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
		            var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
		            var sum = 0;
		            for (var xRegion = -2; xRegion <= 2; xRegion++) {
		                for (var yRegion = -2; yRegion <= 2; yRegion++) {
		                    sum += blackPoints.get(left + xRegion, top_1 + yRegion);
		                }
		            }
		            var threshold = sum / 25;
		            for (var xRegion = 0; xRegion < REGION_SIZE; xRegion++) {
		                for (var yRegion = 0; yRegion < REGION_SIZE; yRegion++) {
		                    var x = hortizontalRegion * REGION_SIZE + xRegion;
		                    var y = verticalRegion * REGION_SIZE + yRegion;
		                    var lum = greyscalePixels.get(x, y);
		                    binarized.set(x, y, lum <= threshold);
		                    if (returnInverted) {
		                        inverted.set(x, y, !(lum <= threshold));
		                    }
		                }
		            }
		        }
		    }
		    if (returnInverted) {
		        return { binarized: binarized, inverted: inverted };
		    }
		    return { binarized: binarized };
		}
		exports$1.binarize = binarize;


		/***/ }),
		/* 5 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var BitMatrix_1 = __webpack_require__(0);
		var decodeData_1 = __webpack_require__(6);
		var reedsolomon_1 = __webpack_require__(9);
		var version_1 = __webpack_require__(10);
		// tslint:disable:no-bitwise
		function numBitsDiffering(x, y) {
		    var z = x ^ y;
		    var bitCount = 0;
		    while (z) {
		        bitCount++;
		        z &= z - 1;
		    }
		    return bitCount;
		}
		function pushBit(bit, byte) {
		    return (byte << 1) | bit;
		}
		// tslint:enable:no-bitwise
		var FORMAT_INFO_TABLE = [
		    { bits: 0x5412, formatInfo: { errorCorrectionLevel: 1, dataMask: 0 } },
		    { bits: 0x5125, formatInfo: { errorCorrectionLevel: 1, dataMask: 1 } },
		    { bits: 0x5E7C, formatInfo: { errorCorrectionLevel: 1, dataMask: 2 } },
		    { bits: 0x5B4B, formatInfo: { errorCorrectionLevel: 1, dataMask: 3 } },
		    { bits: 0x45F9, formatInfo: { errorCorrectionLevel: 1, dataMask: 4 } },
		    { bits: 0x40CE, formatInfo: { errorCorrectionLevel: 1, dataMask: 5 } },
		    { bits: 0x4F97, formatInfo: { errorCorrectionLevel: 1, dataMask: 6 } },
		    { bits: 0x4AA0, formatInfo: { errorCorrectionLevel: 1, dataMask: 7 } },
		    { bits: 0x77C4, formatInfo: { errorCorrectionLevel: 0, dataMask: 0 } },
		    { bits: 0x72F3, formatInfo: { errorCorrectionLevel: 0, dataMask: 1 } },
		    { bits: 0x7DAA, formatInfo: { errorCorrectionLevel: 0, dataMask: 2 } },
		    { bits: 0x789D, formatInfo: { errorCorrectionLevel: 0, dataMask: 3 } },
		    { bits: 0x662F, formatInfo: { errorCorrectionLevel: 0, dataMask: 4 } },
		    { bits: 0x6318, formatInfo: { errorCorrectionLevel: 0, dataMask: 5 } },
		    { bits: 0x6C41, formatInfo: { errorCorrectionLevel: 0, dataMask: 6 } },
		    { bits: 0x6976, formatInfo: { errorCorrectionLevel: 0, dataMask: 7 } },
		    { bits: 0x1689, formatInfo: { errorCorrectionLevel: 3, dataMask: 0 } },
		    { bits: 0x13BE, formatInfo: { errorCorrectionLevel: 3, dataMask: 1 } },
		    { bits: 0x1CE7, formatInfo: { errorCorrectionLevel: 3, dataMask: 2 } },
		    { bits: 0x19D0, formatInfo: { errorCorrectionLevel: 3, dataMask: 3 } },
		    { bits: 0x0762, formatInfo: { errorCorrectionLevel: 3, dataMask: 4 } },
		    { bits: 0x0255, formatInfo: { errorCorrectionLevel: 3, dataMask: 5 } },
		    { bits: 0x0D0C, formatInfo: { errorCorrectionLevel: 3, dataMask: 6 } },
		    { bits: 0x083B, formatInfo: { errorCorrectionLevel: 3, dataMask: 7 } },
		    { bits: 0x355F, formatInfo: { errorCorrectionLevel: 2, dataMask: 0 } },
		    { bits: 0x3068, formatInfo: { errorCorrectionLevel: 2, dataMask: 1 } },
		    { bits: 0x3F31, formatInfo: { errorCorrectionLevel: 2, dataMask: 2 } },
		    { bits: 0x3A06, formatInfo: { errorCorrectionLevel: 2, dataMask: 3 } },
		    { bits: 0x24B4, formatInfo: { errorCorrectionLevel: 2, dataMask: 4 } },
		    { bits: 0x2183, formatInfo: { errorCorrectionLevel: 2, dataMask: 5 } },
		    { bits: 0x2EDA, formatInfo: { errorCorrectionLevel: 2, dataMask: 6 } },
		    { bits: 0x2BED, formatInfo: { errorCorrectionLevel: 2, dataMask: 7 } },
		];
		var DATA_MASKS = [
		    function (p) { return ((p.y + p.x) % 2) === 0; },
		    function (p) { return (p.y % 2) === 0; },
		    function (p) { return p.x % 3 === 0; },
		    function (p) { return (p.y + p.x) % 3 === 0; },
		    function (p) { return (Math.floor(p.y / 2) + Math.floor(p.x / 3)) % 2 === 0; },
		    function (p) { return ((p.x * p.y) % 2) + ((p.x * p.y) % 3) === 0; },
		    function (p) { return ((((p.y * p.x) % 2) + (p.y * p.x) % 3) % 2) === 0; },
		    function (p) { return ((((p.y + p.x) % 2) + (p.y * p.x) % 3) % 2) === 0; },
		];
		function buildFunctionPatternMask(version) {
		    var dimension = 17 + 4 * version.versionNumber;
		    var matrix = BitMatrix_1.BitMatrix.createEmpty(dimension, dimension);
		    matrix.setRegion(0, 0, 9, 9, true); // Top left finder pattern + separator + format
		    matrix.setRegion(dimension - 8, 0, 8, 9, true); // Top right finder pattern + separator + format
		    matrix.setRegion(0, dimension - 8, 9, 8, true); // Bottom left finder pattern + separator + format
		    // Alignment patterns
		    for (var _i = 0, _a = version.alignmentPatternCenters; _i < _a.length; _i++) {
		        var x = _a[_i];
		        for (var _b = 0, _c = version.alignmentPatternCenters; _b < _c.length; _b++) {
		            var y = _c[_b];
		            if (!(x === 6 && y === 6 || x === 6 && y === dimension - 7 || x === dimension - 7 && y === 6)) {
		                matrix.setRegion(x - 2, y - 2, 5, 5, true);
		            }
		        }
		    }
		    matrix.setRegion(6, 9, 1, dimension - 17, true); // Vertical timing pattern
		    matrix.setRegion(9, 6, dimension - 17, 1, true); // Horizontal timing pattern
		    if (version.versionNumber > 6) {
		        matrix.setRegion(dimension - 11, 0, 3, 6, true); // Version info, top right
		        matrix.setRegion(0, dimension - 11, 6, 3, true); // Version info, bottom left
		    }
		    return matrix;
		}
		function readCodewords(matrix, version, formatInfo) {
		    var dataMask = DATA_MASKS[formatInfo.dataMask];
		    var dimension = matrix.height;
		    var functionPatternMask = buildFunctionPatternMask(version);
		    var codewords = [];
		    var currentByte = 0;
		    var bitsRead = 0;
		    // Read columns in pairs, from right to left
		    var readingUp = true;
		    for (var columnIndex = dimension - 1; columnIndex > 0; columnIndex -= 2) {
		        if (columnIndex === 6) { // Skip whole column with vertical alignment pattern;
		            columnIndex--;
		        }
		        for (var i = 0; i < dimension; i++) {
		            var y = readingUp ? dimension - 1 - i : i;
		            for (var columnOffset = 0; columnOffset < 2; columnOffset++) {
		                var x = columnIndex - columnOffset;
		                if (!functionPatternMask.get(x, y)) {
		                    bitsRead++;
		                    var bit = matrix.get(x, y);
		                    if (dataMask({ y: y, x: x })) {
		                        bit = !bit;
		                    }
		                    currentByte = pushBit(bit, currentByte);
		                    if (bitsRead === 8) { // Whole bytes
		                        codewords.push(currentByte);
		                        bitsRead = 0;
		                        currentByte = 0;
		                    }
		                }
		            }
		        }
		        readingUp = !readingUp;
		    }
		    return codewords;
		}
		function readVersion(matrix) {
		    var dimension = matrix.height;
		    var provisionalVersion = Math.floor((dimension - 17) / 4);
		    if (provisionalVersion <= 6) { // 6 and under dont have version info in the QR code
		        return version_1.VERSIONS[provisionalVersion - 1];
		    }
		    var topRightVersionBits = 0;
		    for (var y = 5; y >= 0; y--) {
		        for (var x = dimension - 9; x >= dimension - 11; x--) {
		            topRightVersionBits = pushBit(matrix.get(x, y), topRightVersionBits);
		        }
		    }
		    var bottomLeftVersionBits = 0;
		    for (var x = 5; x >= 0; x--) {
		        for (var y = dimension - 9; y >= dimension - 11; y--) {
		            bottomLeftVersionBits = pushBit(matrix.get(x, y), bottomLeftVersionBits);
		        }
		    }
		    var bestDifference = Infinity;
		    var bestVersion;
		    for (var _i = 0, VERSIONS_1 = version_1.VERSIONS; _i < VERSIONS_1.length; _i++) {
		        var version = VERSIONS_1[_i];
		        if (version.infoBits === topRightVersionBits || version.infoBits === bottomLeftVersionBits) {
		            return version;
		        }
		        var difference = numBitsDiffering(topRightVersionBits, version.infoBits);
		        if (difference < bestDifference) {
		            bestVersion = version;
		            bestDifference = difference;
		        }
		        difference = numBitsDiffering(bottomLeftVersionBits, version.infoBits);
		        if (difference < bestDifference) {
		            bestVersion = version;
		            bestDifference = difference;
		        }
		    }
		    // We can tolerate up to 3 bits of error since no two version info codewords will
		    // differ in less than 8 bits.
		    if (bestDifference <= 3) {
		        return bestVersion;
		    }
		}
		function readFormatInformation(matrix) {
		    var topLeftFormatInfoBits = 0;
		    for (var x = 0; x <= 8; x++) {
		        if (x !== 6) { // Skip timing pattern bit
		            topLeftFormatInfoBits = pushBit(matrix.get(x, 8), topLeftFormatInfoBits);
		        }
		    }
		    for (var y = 7; y >= 0; y--) {
		        if (y !== 6) { // Skip timing pattern bit
		            topLeftFormatInfoBits = pushBit(matrix.get(8, y), topLeftFormatInfoBits);
		        }
		    }
		    var dimension = matrix.height;
		    var topRightBottomRightFormatInfoBits = 0;
		    for (var y = dimension - 1; y >= dimension - 7; y--) { // bottom left
		        topRightBottomRightFormatInfoBits = pushBit(matrix.get(8, y), topRightBottomRightFormatInfoBits);
		    }
		    for (var x = dimension - 8; x < dimension; x++) { // top right
		        topRightBottomRightFormatInfoBits = pushBit(matrix.get(x, 8), topRightBottomRightFormatInfoBits);
		    }
		    var bestDifference = Infinity;
		    var bestFormatInfo = null;
		    for (var _i = 0, FORMAT_INFO_TABLE_1 = FORMAT_INFO_TABLE; _i < FORMAT_INFO_TABLE_1.length; _i++) {
		        var _a = FORMAT_INFO_TABLE_1[_i], bits = _a.bits, formatInfo = _a.formatInfo;
		        if (bits === topLeftFormatInfoBits || bits === topRightBottomRightFormatInfoBits) {
		            return formatInfo;
		        }
		        var difference = numBitsDiffering(topLeftFormatInfoBits, bits);
		        if (difference < bestDifference) {
		            bestFormatInfo = formatInfo;
		            bestDifference = difference;
		        }
		        if (topLeftFormatInfoBits !== topRightBottomRightFormatInfoBits) { // also try the other option
		            difference = numBitsDiffering(topRightBottomRightFormatInfoBits, bits);
		            if (difference < bestDifference) {
		                bestFormatInfo = formatInfo;
		                bestDifference = difference;
		            }
		        }
		    }
		    // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits differing means we found a match
		    if (bestDifference <= 3) {
		        return bestFormatInfo;
		    }
		    return null;
		}
		function getDataBlocks(codewords, version, ecLevel) {
		    var ecInfo = version.errorCorrectionLevels[ecLevel];
		    var dataBlocks = [];
		    var totalCodewords = 0;
		    ecInfo.ecBlocks.forEach(function (block) {
		        for (var i = 0; i < block.numBlocks; i++) {
		            dataBlocks.push({ numDataCodewords: block.dataCodewordsPerBlock, codewords: [] });
		            totalCodewords += block.dataCodewordsPerBlock + ecInfo.ecCodewordsPerBlock;
		        }
		    });
		    // In some cases the QR code will be malformed enough that we pull off more or less than we should.
		    // If we pull off less there's nothing we can do.
		    // If we pull off more we can safely truncate
		    if (codewords.length < totalCodewords) {
		        return null;
		    }
		    codewords = codewords.slice(0, totalCodewords);
		    var shortBlockSize = ecInfo.ecBlocks[0].dataCodewordsPerBlock;
		    // Pull codewords to fill the blocks up to the minimum size
		    for (var i = 0; i < shortBlockSize; i++) {
		        for (var _i = 0, dataBlocks_1 = dataBlocks; _i < dataBlocks_1.length; _i++) {
		            var dataBlock = dataBlocks_1[_i];
		            dataBlock.codewords.push(codewords.shift());
		        }
		    }
		    // If there are any large blocks, pull codewords to fill the last element of those
		    if (ecInfo.ecBlocks.length > 1) {
		        var smallBlockCount = ecInfo.ecBlocks[0].numBlocks;
		        var largeBlockCount = ecInfo.ecBlocks[1].numBlocks;
		        for (var i = 0; i < largeBlockCount; i++) {
		            dataBlocks[smallBlockCount + i].codewords.push(codewords.shift());
		        }
		    }
		    // Add the rest of the codewords to the blocks. These are the error correction codewords.
		    while (codewords.length > 0) {
		        for (var _a = 0, dataBlocks_2 = dataBlocks; _a < dataBlocks_2.length; _a++) {
		            var dataBlock = dataBlocks_2[_a];
		            dataBlock.codewords.push(codewords.shift());
		        }
		    }
		    return dataBlocks;
		}
		function decodeMatrix(matrix) {
		    var version = readVersion(matrix);
		    if (!version) {
		        return null;
		    }
		    var formatInfo = readFormatInformation(matrix);
		    if (!formatInfo) {
		        return null;
		    }
		    var codewords = readCodewords(matrix, version, formatInfo);
		    var dataBlocks = getDataBlocks(codewords, version, formatInfo.errorCorrectionLevel);
		    if (!dataBlocks) {
		        return null;
		    }
		    // Count total number of data bytes
		    var totalBytes = dataBlocks.reduce(function (a, b) { return a + b.numDataCodewords; }, 0);
		    var resultBytes = new Uint8ClampedArray(totalBytes);
		    var resultIndex = 0;
		    for (var _i = 0, dataBlocks_3 = dataBlocks; _i < dataBlocks_3.length; _i++) {
		        var dataBlock = dataBlocks_3[_i];
		        var correctedBytes = reedsolomon_1.decode(dataBlock.codewords, dataBlock.codewords.length - dataBlock.numDataCodewords);
		        if (!correctedBytes) {
		            return null;
		        }
		        for (var i = 0; i < dataBlock.numDataCodewords; i++) {
		            resultBytes[resultIndex++] = correctedBytes[i];
		        }
		    }
		    try {
		        return decodeData_1.decode(resultBytes, version.versionNumber);
		    }
		    catch (_a) {
		        return null;
		    }
		}
		function decode(matrix) {
		    if (matrix == null) {
		        return null;
		    }
		    var result = decodeMatrix(matrix);
		    if (result) {
		        return result;
		    }
		    // Decoding didn't work, try mirroring the QR across the topLeft -> bottomRight line.
		    for (var x = 0; x < matrix.width; x++) {
		        for (var y = x + 1; y < matrix.height; y++) {
		            if (matrix.get(x, y) !== matrix.get(y, x)) {
		                matrix.set(x, y, !matrix.get(x, y));
		                matrix.set(y, x, !matrix.get(y, x));
		            }
		        }
		    }
		    return decodeMatrix(matrix);
		}
		exports$1.decode = decode;


		/***/ }),
		/* 6 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		// tslint:disable:no-bitwise
		var BitStream_1 = __webpack_require__(7);
		var shiftJISTable_1 = __webpack_require__(8);
		var Mode;
		(function (Mode) {
		    Mode["Numeric"] = "numeric";
		    Mode["Alphanumeric"] = "alphanumeric";
		    Mode["Byte"] = "byte";
		    Mode["Kanji"] = "kanji";
		    Mode["ECI"] = "eci";
		})(Mode = exports$1.Mode || (exports$1.Mode = {}));
		var ModeByte;
		(function (ModeByte) {
		    ModeByte[ModeByte["Terminator"] = 0] = "Terminator";
		    ModeByte[ModeByte["Numeric"] = 1] = "Numeric";
		    ModeByte[ModeByte["Alphanumeric"] = 2] = "Alphanumeric";
		    ModeByte[ModeByte["Byte"] = 4] = "Byte";
		    ModeByte[ModeByte["Kanji"] = 8] = "Kanji";
		    ModeByte[ModeByte["ECI"] = 7] = "ECI";
		    // StructuredAppend = 0x3,
		    // FNC1FirstPosition = 0x5,
		    // FNC1SecondPosition = 0x9,
		})(ModeByte || (ModeByte = {}));
		function decodeNumeric(stream, size) {
		    var bytes = [];
		    var text = "";
		    var characterCountSize = [10, 12, 14][size];
		    var length = stream.readBits(characterCountSize);
		    // Read digits in groups of 3
		    while (length >= 3) {
		        var num = stream.readBits(10);
		        if (num >= 1000) {
		            throw new Error("Invalid numeric value above 999");
		        }
		        var a = Math.floor(num / 100);
		        var b = Math.floor(num / 10) % 10;
		        var c = num % 10;
		        bytes.push(48 + a, 48 + b, 48 + c);
		        text += a.toString() + b.toString() + c.toString();
		        length -= 3;
		    }
		    // If the number of digits aren't a multiple of 3, the remaining digits are special cased.
		    if (length === 2) {
		        var num = stream.readBits(7);
		        if (num >= 100) {
		            throw new Error("Invalid numeric value above 99");
		        }
		        var a = Math.floor(num / 10);
		        var b = num % 10;
		        bytes.push(48 + a, 48 + b);
		        text += a.toString() + b.toString();
		    }
		    else if (length === 1) {
		        var num = stream.readBits(4);
		        if (num >= 10) {
		            throw new Error("Invalid numeric value above 9");
		        }
		        bytes.push(48 + num);
		        text += num.toString();
		    }
		    return { bytes: bytes, text: text };
		}
		var AlphanumericCharacterCodes = [
		    "0", "1", "2", "3", "4", "5", "6", "7", "8",
		    "9", "A", "B", "C", "D", "E", "F", "G", "H",
		    "I", "J", "K", "L", "M", "N", "O", "P", "Q",
		    "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
		    " ", "$", "%", "*", "+", "-", ".", "/", ":",
		];
		function decodeAlphanumeric(stream, size) {
		    var bytes = [];
		    var text = "";
		    var characterCountSize = [9, 11, 13][size];
		    var length = stream.readBits(characterCountSize);
		    while (length >= 2) {
		        var v = stream.readBits(11);
		        var a = Math.floor(v / 45);
		        var b = v % 45;
		        bytes.push(AlphanumericCharacterCodes[a].charCodeAt(0), AlphanumericCharacterCodes[b].charCodeAt(0));
		        text += AlphanumericCharacterCodes[a] + AlphanumericCharacterCodes[b];
		        length -= 2;
		    }
		    if (length === 1) {
		        var a = stream.readBits(6);
		        bytes.push(AlphanumericCharacterCodes[a].charCodeAt(0));
		        text += AlphanumericCharacterCodes[a];
		    }
		    return { bytes: bytes, text: text };
		}
		function decodeByte(stream, size) {
		    var bytes = [];
		    var text = "";
		    var characterCountSize = [8, 16, 16][size];
		    var length = stream.readBits(characterCountSize);
		    for (var i = 0; i < length; i++) {
		        var b = stream.readBits(8);
		        bytes.push(b);
		    }
		    try {
		        text += decodeURIComponent(bytes.map(function (b) { return "%" + ("0" + b.toString(16)).substr(-2); }).join(""));
		    }
		    catch (_a) {
		        // failed to decode
		    }
		    return { bytes: bytes, text: text };
		}
		function decodeKanji(stream, size) {
		    var bytes = [];
		    var text = "";
		    var characterCountSize = [8, 10, 12][size];
		    var length = stream.readBits(characterCountSize);
		    for (var i = 0; i < length; i++) {
		        var k = stream.readBits(13);
		        var c = (Math.floor(k / 0xC0) << 8) | (k % 0xC0);
		        if (c < 0x1F00) {
		            c += 0x8140;
		        }
		        else {
		            c += 0xC140;
		        }
		        bytes.push(c >> 8, c & 0xFF);
		        text += String.fromCharCode(shiftJISTable_1.shiftJISTable[c]);
		    }
		    return { bytes: bytes, text: text };
		}
		function decode(data, version) {
		    var _a, _b, _c, _d;
		    var stream = new BitStream_1.BitStream(data);
		    // There are 3 'sizes' based on the version. 1-9 is small (0), 10-26 is medium (1) and 27-40 is large (2).
		    var size = version <= 9 ? 0 : version <= 26 ? 1 : 2;
		    var result = {
		        text: "",
		        bytes: [],
		        chunks: [],
		        version: version,
		    };
		    while (stream.available() >= 4) {
		        var mode = stream.readBits(4);
		        if (mode === ModeByte.Terminator) {
		            return result;
		        }
		        else if (mode === ModeByte.ECI) {
		            if (stream.readBits(1) === 0) {
		                result.chunks.push({
		                    type: Mode.ECI,
		                    assignmentNumber: stream.readBits(7),
		                });
		            }
		            else if (stream.readBits(1) === 0) {
		                result.chunks.push({
		                    type: Mode.ECI,
		                    assignmentNumber: stream.readBits(14),
		                });
		            }
		            else if (stream.readBits(1) === 0) {
		                result.chunks.push({
		                    type: Mode.ECI,
		                    assignmentNumber: stream.readBits(21),
		                });
		            }
		            else {
		                // ECI data seems corrupted
		                result.chunks.push({
		                    type: Mode.ECI,
		                    assignmentNumber: -1,
		                });
		            }
		        }
		        else if (mode === ModeByte.Numeric) {
		            var numericResult = decodeNumeric(stream, size);
		            result.text += numericResult.text;
		            (_a = result.bytes).push.apply(_a, numericResult.bytes);
		            result.chunks.push({
		                type: Mode.Numeric,
		                text: numericResult.text,
		            });
		        }
		        else if (mode === ModeByte.Alphanumeric) {
		            var alphanumericResult = decodeAlphanumeric(stream, size);
		            result.text += alphanumericResult.text;
		            (_b = result.bytes).push.apply(_b, alphanumericResult.bytes);
		            result.chunks.push({
		                type: Mode.Alphanumeric,
		                text: alphanumericResult.text,
		            });
		        }
		        else if (mode === ModeByte.Byte) {
		            var byteResult = decodeByte(stream, size);
		            result.text += byteResult.text;
		            (_c = result.bytes).push.apply(_c, byteResult.bytes);
		            result.chunks.push({
		                type: Mode.Byte,
		                bytes: byteResult.bytes,
		                text: byteResult.text,
		            });
		        }
		        else if (mode === ModeByte.Kanji) {
		            var kanjiResult = decodeKanji(stream, size);
		            result.text += kanjiResult.text;
		            (_d = result.bytes).push.apply(_d, kanjiResult.bytes);
		            result.chunks.push({
		                type: Mode.Kanji,
		                bytes: kanjiResult.bytes,
		                text: kanjiResult.text,
		            });
		        }
		    }
		    // If there is no data left, or the remaining bits are all 0, then that counts as a termination marker
		    if (stream.available() === 0 || stream.readBits(stream.available()) === 0) {
		        return result;
		    }
		}
		exports$1.decode = decode;


		/***/ }),
		/* 7 */
		/***/ (function(module, exports$1, __webpack_require__) {

		// tslint:disable:no-bitwise
		Object.defineProperty(exports$1, "__esModule", { value: true });
		var BitStream = /** @class */ (function () {
		    function BitStream(bytes) {
		        this.byteOffset = 0;
		        this.bitOffset = 0;
		        this.bytes = bytes;
		    }
		    BitStream.prototype.readBits = function (numBits) {
		        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
		            throw new Error("Cannot read " + numBits.toString() + " bits");
		        }
		        var result = 0;
		        // First, read remainder from current byte
		        if (this.bitOffset > 0) {
		            var bitsLeft = 8 - this.bitOffset;
		            var toRead = numBits < bitsLeft ? numBits : bitsLeft;
		            var bitsToNotRead = bitsLeft - toRead;
		            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
		            result = (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
		            numBits -= toRead;
		            this.bitOffset += toRead;
		            if (this.bitOffset === 8) {
		                this.bitOffset = 0;
		                this.byteOffset++;
		            }
		        }
		        // Next read whole bytes
		        if (numBits > 0) {
		            while (numBits >= 8) {
		                result = (result << 8) | (this.bytes[this.byteOffset] & 0xFF);
		                this.byteOffset++;
		                numBits -= 8;
		            }
		            // Finally read a partial byte
		            if (numBits > 0) {
		                var bitsToNotRead = 8 - numBits;
		                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;
		                result = (result << numBits) | ((this.bytes[this.byteOffset] & mask) >> bitsToNotRead);
		                this.bitOffset += numBits;
		            }
		        }
		        return result;
		    };
		    BitStream.prototype.available = function () {
		        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
		    };
		    return BitStream;
		}());
		exports$1.BitStream = BitStream;


		/***/ }),
		/* 8 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.shiftJISTable = {
		    0x20: 0x0020,
		    0x21: 0x0021,
		    0x22: 0x0022,
		    0x23: 0x0023,
		    0x24: 0x0024,
		    0x25: 0x0025,
		    0x26: 0x0026,
		    0x27: 0x0027,
		    0x28: 0x0028,
		    0x29: 0x0029,
		    0x2A: 0x002A,
		    0x2B: 0x002B,
		    0x2C: 0x002C,
		    0x2D: 0x002D,
		    0x2E: 0x002E,
		    0x2F: 0x002F,
		    0x30: 0x0030,
		    0x31: 0x0031,
		    0x32: 0x0032,
		    0x33: 0x0033,
		    0x34: 0x0034,
		    0x35: 0x0035,
		    0x36: 0x0036,
		    0x37: 0x0037,
		    0x38: 0x0038,
		    0x39: 0x0039,
		    0x3A: 0x003A,
		    0x3B: 0x003B,
		    0x3C: 0x003C,
		    0x3D: 0x003D,
		    0x3E: 0x003E,
		    0x3F: 0x003F,
		    0x40: 0x0040,
		    0x41: 0x0041,
		    0x42: 0x0042,
		    0x43: 0x0043,
		    0x44: 0x0044,
		    0x45: 0x0045,
		    0x46: 0x0046,
		    0x47: 0x0047,
		    0x48: 0x0048,
		    0x49: 0x0049,
		    0x4A: 0x004A,
		    0x4B: 0x004B,
		    0x4C: 0x004C,
		    0x4D: 0x004D,
		    0x4E: 0x004E,
		    0x4F: 0x004F,
		    0x50: 0x0050,
		    0x51: 0x0051,
		    0x52: 0x0052,
		    0x53: 0x0053,
		    0x54: 0x0054,
		    0x55: 0x0055,
		    0x56: 0x0056,
		    0x57: 0x0057,
		    0x58: 0x0058,
		    0x59: 0x0059,
		    0x5A: 0x005A,
		    0x5B: 0x005B,
		    0x5C: 0x00A5,
		    0x5D: 0x005D,
		    0x5E: 0x005E,
		    0x5F: 0x005F,
		    0x60: 0x0060,
		    0x61: 0x0061,
		    0x62: 0x0062,
		    0x63: 0x0063,
		    0x64: 0x0064,
		    0x65: 0x0065,
		    0x66: 0x0066,
		    0x67: 0x0067,
		    0x68: 0x0068,
		    0x69: 0x0069,
		    0x6A: 0x006A,
		    0x6B: 0x006B,
		    0x6C: 0x006C,
		    0x6D: 0x006D,
		    0x6E: 0x006E,
		    0x6F: 0x006F,
		    0x70: 0x0070,
		    0x71: 0x0071,
		    0x72: 0x0072,
		    0x73: 0x0073,
		    0x74: 0x0074,
		    0x75: 0x0075,
		    0x76: 0x0076,
		    0x77: 0x0077,
		    0x78: 0x0078,
		    0x79: 0x0079,
		    0x7A: 0x007A,
		    0x7B: 0x007B,
		    0x7C: 0x007C,
		    0x7D: 0x007D,
		    0x7E: 0x203E,
		    0x8140: 0x3000,
		    0x8141: 0x3001,
		    0x8142: 0x3002,
		    0x8143: 0xFF0C,
		    0x8144: 0xFF0E,
		    0x8145: 0x30FB,
		    0x8146: 0xFF1A,
		    0x8147: 0xFF1B,
		    0x8148: 0xFF1F,
		    0x8149: 0xFF01,
		    0x814A: 0x309B,
		    0x814B: 0x309C,
		    0x814C: 0x00B4,
		    0x814D: 0xFF40,
		    0x814E: 0x00A8,
		    0x814F: 0xFF3E,
		    0x8150: 0xFFE3,
		    0x8151: 0xFF3F,
		    0x8152: 0x30FD,
		    0x8153: 0x30FE,
		    0x8154: 0x309D,
		    0x8155: 0x309E,
		    0x8156: 0x3003,
		    0x8157: 0x4EDD,
		    0x8158: 0x3005,
		    0x8159: 0x3006,
		    0x815A: 0x3007,
		    0x815B: 0x30FC,
		    0x815C: 0x2015,
		    0x815D: 0x2010,
		    0x815E: 0xFF0F,
		    0x815F: 0x005C,
		    0x8160: 0x301C,
		    0x8161: 0x2016,
		    0x8162: 0xFF5C,
		    0x8163: 0x2026,
		    0x8164: 0x2025,
		    0x8165: 0x2018,
		    0x8166: 0x2019,
		    0x8167: 0x201C,
		    0x8168: 0x201D,
		    0x8169: 0xFF08,
		    0x816A: 0xFF09,
		    0x816B: 0x3014,
		    0x816C: 0x3015,
		    0x816D: 0xFF3B,
		    0x816E: 0xFF3D,
		    0x816F: 0xFF5B,
		    0x8170: 0xFF5D,
		    0x8171: 0x3008,
		    0x8172: 0x3009,
		    0x8173: 0x300A,
		    0x8174: 0x300B,
		    0x8175: 0x300C,
		    0x8176: 0x300D,
		    0x8177: 0x300E,
		    0x8178: 0x300F,
		    0x8179: 0x3010,
		    0x817A: 0x3011,
		    0x817B: 0xFF0B,
		    0x817C: 0x2212,
		    0x817D: 0x00B1,
		    0x817E: 0x00D7,
		    0x8180: 0x00F7,
		    0x8181: 0xFF1D,
		    0x8182: 0x2260,
		    0x8183: 0xFF1C,
		    0x8184: 0xFF1E,
		    0x8185: 0x2266,
		    0x8186: 0x2267,
		    0x8187: 0x221E,
		    0x8188: 0x2234,
		    0x8189: 0x2642,
		    0x818A: 0x2640,
		    0x818B: 0x00B0,
		    0x818C: 0x2032,
		    0x818D: 0x2033,
		    0x818E: 0x2103,
		    0x818F: 0xFFE5,
		    0x8190: 0xFF04,
		    0x8191: 0x00A2,
		    0x8192: 0x00A3,
		    0x8193: 0xFF05,
		    0x8194: 0xFF03,
		    0x8195: 0xFF06,
		    0x8196: 0xFF0A,
		    0x8197: 0xFF20,
		    0x8198: 0x00A7,
		    0x8199: 0x2606,
		    0x819A: 0x2605,
		    0x819B: 0x25CB,
		    0x819C: 0x25CF,
		    0x819D: 0x25CE,
		    0x819E: 0x25C7,
		    0x819F: 0x25C6,
		    0x81A0: 0x25A1,
		    0x81A1: 0x25A0,
		    0x81A2: 0x25B3,
		    0x81A3: 0x25B2,
		    0x81A4: 0x25BD,
		    0x81A5: 0x25BC,
		    0x81A6: 0x203B,
		    0x81A7: 0x3012,
		    0x81A8: 0x2192,
		    0x81A9: 0x2190,
		    0x81AA: 0x2191,
		    0x81AB: 0x2193,
		    0x81AC: 0x3013,
		    0x81B8: 0x2208,
		    0x81B9: 0x220B,
		    0x81BA: 0x2286,
		    0x81BB: 0x2287,
		    0x81BC: 0x2282,
		    0x81BD: 0x2283,
		    0x81BE: 0x222A,
		    0x81BF: 0x2229,
		    0x81C8: 0x2227,
		    0x81C9: 0x2228,
		    0x81CA: 0x00AC,
		    0x81CB: 0x21D2,
		    0x81CC: 0x21D4,
		    0x81CD: 0x2200,
		    0x81CE: 0x2203,
		    0x81DA: 0x2220,
		    0x81DB: 0x22A5,
		    0x81DC: 0x2312,
		    0x81DD: 0x2202,
		    0x81DE: 0x2207,
		    0x81DF: 0x2261,
		    0x81E0: 0x2252,
		    0x81E1: 0x226A,
		    0x81E2: 0x226B,
		    0x81E3: 0x221A,
		    0x81E4: 0x223D,
		    0x81E5: 0x221D,
		    0x81E6: 0x2235,
		    0x81E7: 0x222B,
		    0x81E8: 0x222C,
		    0x81F0: 0x212B,
		    0x81F1: 0x2030,
		    0x81F2: 0x266F,
		    0x81F3: 0x266D,
		    0x81F4: 0x266A,
		    0x81F5: 0x2020,
		    0x81F6: 0x2021,
		    0x81F7: 0x00B6,
		    0x81FC: 0x25EF,
		    0x824F: 0xFF10,
		    0x8250: 0xFF11,
		    0x8251: 0xFF12,
		    0x8252: 0xFF13,
		    0x8253: 0xFF14,
		    0x8254: 0xFF15,
		    0x8255: 0xFF16,
		    0x8256: 0xFF17,
		    0x8257: 0xFF18,
		    0x8258: 0xFF19,
		    0x8260: 0xFF21,
		    0x8261: 0xFF22,
		    0x8262: 0xFF23,
		    0x8263: 0xFF24,
		    0x8264: 0xFF25,
		    0x8265: 0xFF26,
		    0x8266: 0xFF27,
		    0x8267: 0xFF28,
		    0x8268: 0xFF29,
		    0x8269: 0xFF2A,
		    0x826A: 0xFF2B,
		    0x826B: 0xFF2C,
		    0x826C: 0xFF2D,
		    0x826D: 0xFF2E,
		    0x826E: 0xFF2F,
		    0x826F: 0xFF30,
		    0x8270: 0xFF31,
		    0x8271: 0xFF32,
		    0x8272: 0xFF33,
		    0x8273: 0xFF34,
		    0x8274: 0xFF35,
		    0x8275: 0xFF36,
		    0x8276: 0xFF37,
		    0x8277: 0xFF38,
		    0x8278: 0xFF39,
		    0x8279: 0xFF3A,
		    0x8281: 0xFF41,
		    0x8282: 0xFF42,
		    0x8283: 0xFF43,
		    0x8284: 0xFF44,
		    0x8285: 0xFF45,
		    0x8286: 0xFF46,
		    0x8287: 0xFF47,
		    0x8288: 0xFF48,
		    0x8289: 0xFF49,
		    0x828A: 0xFF4A,
		    0x828B: 0xFF4B,
		    0x828C: 0xFF4C,
		    0x828D: 0xFF4D,
		    0x828E: 0xFF4E,
		    0x828F: 0xFF4F,
		    0x8290: 0xFF50,
		    0x8291: 0xFF51,
		    0x8292: 0xFF52,
		    0x8293: 0xFF53,
		    0x8294: 0xFF54,
		    0x8295: 0xFF55,
		    0x8296: 0xFF56,
		    0x8297: 0xFF57,
		    0x8298: 0xFF58,
		    0x8299: 0xFF59,
		    0x829A: 0xFF5A,
		    0x829F: 0x3041,
		    0x82A0: 0x3042,
		    0x82A1: 0x3043,
		    0x82A2: 0x3044,
		    0x82A3: 0x3045,
		    0x82A4: 0x3046,
		    0x82A5: 0x3047,
		    0x82A6: 0x3048,
		    0x82A7: 0x3049,
		    0x82A8: 0x304A,
		    0x82A9: 0x304B,
		    0x82AA: 0x304C,
		    0x82AB: 0x304D,
		    0x82AC: 0x304E,
		    0x82AD: 0x304F,
		    0x82AE: 0x3050,
		    0x82AF: 0x3051,
		    0x82B0: 0x3052,
		    0x82B1: 0x3053,
		    0x82B2: 0x3054,
		    0x82B3: 0x3055,
		    0x82B4: 0x3056,
		    0x82B5: 0x3057,
		    0x82B6: 0x3058,
		    0x82B7: 0x3059,
		    0x82B8: 0x305A,
		    0x82B9: 0x305B,
		    0x82BA: 0x305C,
		    0x82BB: 0x305D,
		    0x82BC: 0x305E,
		    0x82BD: 0x305F,
		    0x82BE: 0x3060,
		    0x82BF: 0x3061,
		    0x82C0: 0x3062,
		    0x82C1: 0x3063,
		    0x82C2: 0x3064,
		    0x82C3: 0x3065,
		    0x82C4: 0x3066,
		    0x82C5: 0x3067,
		    0x82C6: 0x3068,
		    0x82C7: 0x3069,
		    0x82C8: 0x306A,
		    0x82C9: 0x306B,
		    0x82CA: 0x306C,
		    0x82CB: 0x306D,
		    0x82CC: 0x306E,
		    0x82CD: 0x306F,
		    0x82CE: 0x3070,
		    0x82CF: 0x3071,
		    0x82D0: 0x3072,
		    0x82D1: 0x3073,
		    0x82D2: 0x3074,
		    0x82D3: 0x3075,
		    0x82D4: 0x3076,
		    0x82D5: 0x3077,
		    0x82D6: 0x3078,
		    0x82D7: 0x3079,
		    0x82D8: 0x307A,
		    0x82D9: 0x307B,
		    0x82DA: 0x307C,
		    0x82DB: 0x307D,
		    0x82DC: 0x307E,
		    0x82DD: 0x307F,
		    0x82DE: 0x3080,
		    0x82DF: 0x3081,
		    0x82E0: 0x3082,
		    0x82E1: 0x3083,
		    0x82E2: 0x3084,
		    0x82E3: 0x3085,
		    0x82E4: 0x3086,
		    0x82E5: 0x3087,
		    0x82E6: 0x3088,
		    0x82E7: 0x3089,
		    0x82E8: 0x308A,
		    0x82E9: 0x308B,
		    0x82EA: 0x308C,
		    0x82EB: 0x308D,
		    0x82EC: 0x308E,
		    0x82ED: 0x308F,
		    0x82EE: 0x3090,
		    0x82EF: 0x3091,
		    0x82F0: 0x3092,
		    0x82F1: 0x3093,
		    0x8340: 0x30A1,
		    0x8341: 0x30A2,
		    0x8342: 0x30A3,
		    0x8343: 0x30A4,
		    0x8344: 0x30A5,
		    0x8345: 0x30A6,
		    0x8346: 0x30A7,
		    0x8347: 0x30A8,
		    0x8348: 0x30A9,
		    0x8349: 0x30AA,
		    0x834A: 0x30AB,
		    0x834B: 0x30AC,
		    0x834C: 0x30AD,
		    0x834D: 0x30AE,
		    0x834E: 0x30AF,
		    0x834F: 0x30B0,
		    0x8350: 0x30B1,
		    0x8351: 0x30B2,
		    0x8352: 0x30B3,
		    0x8353: 0x30B4,
		    0x8354: 0x30B5,
		    0x8355: 0x30B6,
		    0x8356: 0x30B7,
		    0x8357: 0x30B8,
		    0x8358: 0x30B9,
		    0x8359: 0x30BA,
		    0x835A: 0x30BB,
		    0x835B: 0x30BC,
		    0x835C: 0x30BD,
		    0x835D: 0x30BE,
		    0x835E: 0x30BF,
		    0x835F: 0x30C0,
		    0x8360: 0x30C1,
		    0x8361: 0x30C2,
		    0x8362: 0x30C3,
		    0x8363: 0x30C4,
		    0x8364: 0x30C5,
		    0x8365: 0x30C6,
		    0x8366: 0x30C7,
		    0x8367: 0x30C8,
		    0x8368: 0x30C9,
		    0x8369: 0x30CA,
		    0x836A: 0x30CB,
		    0x836B: 0x30CC,
		    0x836C: 0x30CD,
		    0x836D: 0x30CE,
		    0x836E: 0x30CF,
		    0x836F: 0x30D0,
		    0x8370: 0x30D1,
		    0x8371: 0x30D2,
		    0x8372: 0x30D3,
		    0x8373: 0x30D4,
		    0x8374: 0x30D5,
		    0x8375: 0x30D6,
		    0x8376: 0x30D7,
		    0x8377: 0x30D8,
		    0x8378: 0x30D9,
		    0x8379: 0x30DA,
		    0x837A: 0x30DB,
		    0x837B: 0x30DC,
		    0x837C: 0x30DD,
		    0x837D: 0x30DE,
		    0x837E: 0x30DF,
		    0x8380: 0x30E0,
		    0x8381: 0x30E1,
		    0x8382: 0x30E2,
		    0x8383: 0x30E3,
		    0x8384: 0x30E4,
		    0x8385: 0x30E5,
		    0x8386: 0x30E6,
		    0x8387: 0x30E7,
		    0x8388: 0x30E8,
		    0x8389: 0x30E9,
		    0x838A: 0x30EA,
		    0x838B: 0x30EB,
		    0x838C: 0x30EC,
		    0x838D: 0x30ED,
		    0x838E: 0x30EE,
		    0x838F: 0x30EF,
		    0x8390: 0x30F0,
		    0x8391: 0x30F1,
		    0x8392: 0x30F2,
		    0x8393: 0x30F3,
		    0x8394: 0x30F4,
		    0x8395: 0x30F5,
		    0x8396: 0x30F6,
		    0x839F: 0x0391,
		    0x83A0: 0x0392,
		    0x83A1: 0x0393,
		    0x83A2: 0x0394,
		    0x83A3: 0x0395,
		    0x83A4: 0x0396,
		    0x83A5: 0x0397,
		    0x83A6: 0x0398,
		    0x83A7: 0x0399,
		    0x83A8: 0x039A,
		    0x83A9: 0x039B,
		    0x83AA: 0x039C,
		    0x83AB: 0x039D,
		    0x83AC: 0x039E,
		    0x83AD: 0x039F,
		    0x83AE: 0x03A0,
		    0x83AF: 0x03A1,
		    0x83B0: 0x03A3,
		    0x83B1: 0x03A4,
		    0x83B2: 0x03A5,
		    0x83B3: 0x03A6,
		    0x83B4: 0x03A7,
		    0x83B5: 0x03A8,
		    0x83B6: 0x03A9,
		    0x83BF: 0x03B1,
		    0x83C0: 0x03B2,
		    0x83C1: 0x03B3,
		    0x83C2: 0x03B4,
		    0x83C3: 0x03B5,
		    0x83C4: 0x03B6,
		    0x83C5: 0x03B7,
		    0x83C6: 0x03B8,
		    0x83C7: 0x03B9,
		    0x83C8: 0x03BA,
		    0x83C9: 0x03BB,
		    0x83CA: 0x03BC,
		    0x83CB: 0x03BD,
		    0x83CC: 0x03BE,
		    0x83CD: 0x03BF,
		    0x83CE: 0x03C0,
		    0x83CF: 0x03C1,
		    0x83D0: 0x03C3,
		    0x83D1: 0x03C4,
		    0x83D2: 0x03C5,
		    0x83D3: 0x03C6,
		    0x83D4: 0x03C7,
		    0x83D5: 0x03C8,
		    0x83D6: 0x03C9,
		    0x8440: 0x0410,
		    0x8441: 0x0411,
		    0x8442: 0x0412,
		    0x8443: 0x0413,
		    0x8444: 0x0414,
		    0x8445: 0x0415,
		    0x8446: 0x0401,
		    0x8447: 0x0416,
		    0x8448: 0x0417,
		    0x8449: 0x0418,
		    0x844A: 0x0419,
		    0x844B: 0x041A,
		    0x844C: 0x041B,
		    0x844D: 0x041C,
		    0x844E: 0x041D,
		    0x844F: 0x041E,
		    0x8450: 0x041F,
		    0x8451: 0x0420,
		    0x8452: 0x0421,
		    0x8453: 0x0422,
		    0x8454: 0x0423,
		    0x8455: 0x0424,
		    0x8456: 0x0425,
		    0x8457: 0x0426,
		    0x8458: 0x0427,
		    0x8459: 0x0428,
		    0x845A: 0x0429,
		    0x845B: 0x042A,
		    0x845C: 0x042B,
		    0x845D: 0x042C,
		    0x845E: 0x042D,
		    0x845F: 0x042E,
		    0x8460: 0x042F,
		    0x8470: 0x0430,
		    0x8471: 0x0431,
		    0x8472: 0x0432,
		    0x8473: 0x0433,
		    0x8474: 0x0434,
		    0x8475: 0x0435,
		    0x8476: 0x0451,
		    0x8477: 0x0436,
		    0x8478: 0x0437,
		    0x8479: 0x0438,
		    0x847A: 0x0439,
		    0x847B: 0x043A,
		    0x847C: 0x043B,
		    0x847D: 0x043C,
		    0x847E: 0x043D,
		    0x8480: 0x043E,
		    0x8481: 0x043F,
		    0x8482: 0x0440,
		    0x8483: 0x0441,
		    0x8484: 0x0442,
		    0x8485: 0x0443,
		    0x8486: 0x0444,
		    0x8487: 0x0445,
		    0x8488: 0x0446,
		    0x8489: 0x0447,
		    0x848A: 0x0448,
		    0x848B: 0x0449,
		    0x848C: 0x044A,
		    0x848D: 0x044B,
		    0x848E: 0x044C,
		    0x848F: 0x044D,
		    0x8490: 0x044E,
		    0x8491: 0x044F,
		    0x849F: 0x2500,
		    0x84A0: 0x2502,
		    0x84A1: 0x250C,
		    0x84A2: 0x2510,
		    0x84A3: 0x2518,
		    0x84A4: 0x2514,
		    0x84A5: 0x251C,
		    0x84A6: 0x252C,
		    0x84A7: 0x2524,
		    0x84A8: 0x2534,
		    0x84A9: 0x253C,
		    0x84AA: 0x2501,
		    0x84AB: 0x2503,
		    0x84AC: 0x250F,
		    0x84AD: 0x2513,
		    0x84AE: 0x251B,
		    0x84AF: 0x2517,
		    0x84B0: 0x2523,
		    0x84B1: 0x2533,
		    0x84B2: 0x252B,
		    0x84B3: 0x253B,
		    0x84B4: 0x254B,
		    0x84B5: 0x2520,
		    0x84B6: 0x252F,
		    0x84B7: 0x2528,
		    0x84B8: 0x2537,
		    0x84B9: 0x253F,
		    0x84BA: 0x251D,
		    0x84BB: 0x2530,
		    0x84BC: 0x2525,
		    0x84BD: 0x2538,
		    0x84BE: 0x2542,
		    0x889F: 0x4E9C,
		    0x88A0: 0x5516,
		    0x88A1: 0x5A03,
		    0x88A2: 0x963F,
		    0x88A3: 0x54C0,
		    0x88A4: 0x611B,
		    0x88A5: 0x6328,
		    0x88A6: 0x59F6,
		    0x88A7: 0x9022,
		    0x88A8: 0x8475,
		    0x88A9: 0x831C,
		    0x88AA: 0x7A50,
		    0x88AB: 0x60AA,
		    0x88AC: 0x63E1,
		    0x88AD: 0x6E25,
		    0x88AE: 0x65ED,
		    0x88AF: 0x8466,
		    0x88B0: 0x82A6,
		    0x88B1: 0x9BF5,
		    0x88B2: 0x6893,
		    0x88B3: 0x5727,
		    0x88B4: 0x65A1,
		    0x88B5: 0x6271,
		    0x88B6: 0x5B9B,
		    0x88B7: 0x59D0,
		    0x88B8: 0x867B,
		    0x88B9: 0x98F4,
		    0x88BA: 0x7D62,
		    0x88BB: 0x7DBE,
		    0x88BC: 0x9B8E,
		    0x88BD: 0x6216,
		    0x88BE: 0x7C9F,
		    0x88BF: 0x88B7,
		    0x88C0: 0x5B89,
		    0x88C1: 0x5EB5,
		    0x88C2: 0x6309,
		    0x88C3: 0x6697,
		    0x88C4: 0x6848,
		    0x88C5: 0x95C7,
		    0x88C6: 0x978D,
		    0x88C7: 0x674F,
		    0x88C8: 0x4EE5,
		    0x88C9: 0x4F0A,
		    0x88CA: 0x4F4D,
		    0x88CB: 0x4F9D,
		    0x88CC: 0x5049,
		    0x88CD: 0x56F2,
		    0x88CE: 0x5937,
		    0x88CF: 0x59D4,
		    0x88D0: 0x5A01,
		    0x88D1: 0x5C09,
		    0x88D2: 0x60DF,
		    0x88D3: 0x610F,
		    0x88D4: 0x6170,
		    0x88D5: 0x6613,
		    0x88D6: 0x6905,
		    0x88D7: 0x70BA,
		    0x88D8: 0x754F,
		    0x88D9: 0x7570,
		    0x88DA: 0x79FB,
		    0x88DB: 0x7DAD,
		    0x88DC: 0x7DEF,
		    0x88DD: 0x80C3,
		    0x88DE: 0x840E,
		    0x88DF: 0x8863,
		    0x88E0: 0x8B02,
		    0x88E1: 0x9055,
		    0x88E2: 0x907A,
		    0x88E3: 0x533B,
		    0x88E4: 0x4E95,
		    0x88E5: 0x4EA5,
		    0x88E6: 0x57DF,
		    0x88E7: 0x80B2,
		    0x88E8: 0x90C1,
		    0x88E9: 0x78EF,
		    0x88EA: 0x4E00,
		    0x88EB: 0x58F1,
		    0x88EC: 0x6EA2,
		    0x88ED: 0x9038,
		    0x88EE: 0x7A32,
		    0x88EF: 0x8328,
		    0x88F0: 0x828B,
		    0x88F1: 0x9C2F,
		    0x88F2: 0x5141,
		    0x88F3: 0x5370,
		    0x88F4: 0x54BD,
		    0x88F5: 0x54E1,
		    0x88F6: 0x56E0,
		    0x88F7: 0x59FB,
		    0x88F8: 0x5F15,
		    0x88F9: 0x98F2,
		    0x88FA: 0x6DEB,
		    0x88FB: 0x80E4,
		    0x88FC: 0x852D,
		    0x8940: 0x9662,
		    0x8941: 0x9670,
		    0x8942: 0x96A0,
		    0x8943: 0x97FB,
		    0x8944: 0x540B,
		    0x8945: 0x53F3,
		    0x8946: 0x5B87,
		    0x8947: 0x70CF,
		    0x8948: 0x7FBD,
		    0x8949: 0x8FC2,
		    0x894A: 0x96E8,
		    0x894B: 0x536F,
		    0x894C: 0x9D5C,
		    0x894D: 0x7ABA,
		    0x894E: 0x4E11,
		    0x894F: 0x7893,
		    0x8950: 0x81FC,
		    0x8951: 0x6E26,
		    0x8952: 0x5618,
		    0x8953: 0x5504,
		    0x8954: 0x6B1D,
		    0x8955: 0x851A,
		    0x8956: 0x9C3B,
		    0x8957: 0x59E5,
		    0x8958: 0x53A9,
		    0x8959: 0x6D66,
		    0x895A: 0x74DC,
		    0x895B: 0x958F,
		    0x895C: 0x5642,
		    0x895D: 0x4E91,
		    0x895E: 0x904B,
		    0x895F: 0x96F2,
		    0x8960: 0x834F,
		    0x8961: 0x990C,
		    0x8962: 0x53E1,
		    0x8963: 0x55B6,
		    0x8964: 0x5B30,
		    0x8965: 0x5F71,
		    0x8966: 0x6620,
		    0x8967: 0x66F3,
		    0x8968: 0x6804,
		    0x8969: 0x6C38,
		    0x896A: 0x6CF3,
		    0x896B: 0x6D29,
		    0x896C: 0x745B,
		    0x896D: 0x76C8,
		    0x896E: 0x7A4E,
		    0x896F: 0x9834,
		    0x8970: 0x82F1,
		    0x8971: 0x885B,
		    0x8972: 0x8A60,
		    0x8973: 0x92ED,
		    0x8974: 0x6DB2,
		    0x8975: 0x75AB,
		    0x8976: 0x76CA,
		    0x8977: 0x99C5,
		    0x8978: 0x60A6,
		    0x8979: 0x8B01,
		    0x897A: 0x8D8A,
		    0x897B: 0x95B2,
		    0x897C: 0x698E,
		    0x897D: 0x53AD,
		    0x897E: 0x5186,
		    0x8980: 0x5712,
		    0x8981: 0x5830,
		    0x8982: 0x5944,
		    0x8983: 0x5BB4,
		    0x8984: 0x5EF6,
		    0x8985: 0x6028,
		    0x8986: 0x63A9,
		    0x8987: 0x63F4,
		    0x8988: 0x6CBF,
		    0x8989: 0x6F14,
		    0x898A: 0x708E,
		    0x898B: 0x7114,
		    0x898C: 0x7159,
		    0x898D: 0x71D5,
		    0x898E: 0x733F,
		    0x898F: 0x7E01,
		    0x8990: 0x8276,
		    0x8991: 0x82D1,
		    0x8992: 0x8597,
		    0x8993: 0x9060,
		    0x8994: 0x925B,
		    0x8995: 0x9D1B,
		    0x8996: 0x5869,
		    0x8997: 0x65BC,
		    0x8998: 0x6C5A,
		    0x8999: 0x7525,
		    0x899A: 0x51F9,
		    0x899B: 0x592E,
		    0x899C: 0x5965,
		    0x899D: 0x5F80,
		    0x899E: 0x5FDC,
		    0x899F: 0x62BC,
		    0x89A0: 0x65FA,
		    0x89A1: 0x6A2A,
		    0x89A2: 0x6B27,
		    0x89A3: 0x6BB4,
		    0x89A4: 0x738B,
		    0x89A5: 0x7FC1,
		    0x89A6: 0x8956,
		    0x89A7: 0x9D2C,
		    0x89A8: 0x9D0E,
		    0x89A9: 0x9EC4,
		    0x89AA: 0x5CA1,
		    0x89AB: 0x6C96,
		    0x89AC: 0x837B,
		    0x89AD: 0x5104,
		    0x89AE: 0x5C4B,
		    0x89AF: 0x61B6,
		    0x89B0: 0x81C6,
		    0x89B1: 0x6876,
		    0x89B2: 0x7261,
		    0x89B3: 0x4E59,
		    0x89B4: 0x4FFA,
		    0x89B5: 0x5378,
		    0x89B6: 0x6069,
		    0x89B7: 0x6E29,
		    0x89B8: 0x7A4F,
		    0x89B9: 0x97F3,
		    0x89BA: 0x4E0B,
		    0x89BB: 0x5316,
		    0x89BC: 0x4EEE,
		    0x89BD: 0x4F55,
		    0x89BE: 0x4F3D,
		    0x89BF: 0x4FA1,
		    0x89C0: 0x4F73,
		    0x89C1: 0x52A0,
		    0x89C2: 0x53EF,
		    0x89C3: 0x5609,
		    0x89C4: 0x590F,
		    0x89C5: 0x5AC1,
		    0x89C6: 0x5BB6,
		    0x89C7: 0x5BE1,
		    0x89C8: 0x79D1,
		    0x89C9: 0x6687,
		    0x89CA: 0x679C,
		    0x89CB: 0x67B6,
		    0x89CC: 0x6B4C,
		    0x89CD: 0x6CB3,
		    0x89CE: 0x706B,
		    0x89CF: 0x73C2,
		    0x89D0: 0x798D,
		    0x89D1: 0x79BE,
		    0x89D2: 0x7A3C,
		    0x89D3: 0x7B87,
		    0x89D4: 0x82B1,
		    0x89D5: 0x82DB,
		    0x89D6: 0x8304,
		    0x89D7: 0x8377,
		    0x89D8: 0x83EF,
		    0x89D9: 0x83D3,
		    0x89DA: 0x8766,
		    0x89DB: 0x8AB2,
		    0x89DC: 0x5629,
		    0x89DD: 0x8CA8,
		    0x89DE: 0x8FE6,
		    0x89DF: 0x904E,
		    0x89E0: 0x971E,
		    0x89E1: 0x868A,
		    0x89E2: 0x4FC4,
		    0x89E3: 0x5CE8,
		    0x89E4: 0x6211,
		    0x89E5: 0x7259,
		    0x89E6: 0x753B,
		    0x89E7: 0x81E5,
		    0x89E8: 0x82BD,
		    0x89E9: 0x86FE,
		    0x89EA: 0x8CC0,
		    0x89EB: 0x96C5,
		    0x89EC: 0x9913,
		    0x89ED: 0x99D5,
		    0x89EE: 0x4ECB,
		    0x89EF: 0x4F1A,
		    0x89F0: 0x89E3,
		    0x89F1: 0x56DE,
		    0x89F2: 0x584A,
		    0x89F3: 0x58CA,
		    0x89F4: 0x5EFB,
		    0x89F5: 0x5FEB,
		    0x89F6: 0x602A,
		    0x89F7: 0x6094,
		    0x89F8: 0x6062,
		    0x89F9: 0x61D0,
		    0x89FA: 0x6212,
		    0x89FB: 0x62D0,
		    0x89FC: 0x6539,
		    0x8A40: 0x9B41,
		    0x8A41: 0x6666,
		    0x8A42: 0x68B0,
		    0x8A43: 0x6D77,
		    0x8A44: 0x7070,
		    0x8A45: 0x754C,
		    0x8A46: 0x7686,
		    0x8A47: 0x7D75,
		    0x8A48: 0x82A5,
		    0x8A49: 0x87F9,
		    0x8A4A: 0x958B,
		    0x8A4B: 0x968E,
		    0x8A4C: 0x8C9D,
		    0x8A4D: 0x51F1,
		    0x8A4E: 0x52BE,
		    0x8A4F: 0x5916,
		    0x8A50: 0x54B3,
		    0x8A51: 0x5BB3,
		    0x8A52: 0x5D16,
		    0x8A53: 0x6168,
		    0x8A54: 0x6982,
		    0x8A55: 0x6DAF,
		    0x8A56: 0x788D,
		    0x8A57: 0x84CB,
		    0x8A58: 0x8857,
		    0x8A59: 0x8A72,
		    0x8A5A: 0x93A7,
		    0x8A5B: 0x9AB8,
		    0x8A5C: 0x6D6C,
		    0x8A5D: 0x99A8,
		    0x8A5E: 0x86D9,
		    0x8A5F: 0x57A3,
		    0x8A60: 0x67FF,
		    0x8A61: 0x86CE,
		    0x8A62: 0x920E,
		    0x8A63: 0x5283,
		    0x8A64: 0x5687,
		    0x8A65: 0x5404,
		    0x8A66: 0x5ED3,
		    0x8A67: 0x62E1,
		    0x8A68: 0x64B9,
		    0x8A69: 0x683C,
		    0x8A6A: 0x6838,
		    0x8A6B: 0x6BBB,
		    0x8A6C: 0x7372,
		    0x8A6D: 0x78BA,
		    0x8A6E: 0x7A6B,
		    0x8A6F: 0x899A,
		    0x8A70: 0x89D2,
		    0x8A71: 0x8D6B,
		    0x8A72: 0x8F03,
		    0x8A73: 0x90ED,
		    0x8A74: 0x95A3,
		    0x8A75: 0x9694,
		    0x8A76: 0x9769,
		    0x8A77: 0x5B66,
		    0x8A78: 0x5CB3,
		    0x8A79: 0x697D,
		    0x8A7A: 0x984D,
		    0x8A7B: 0x984E,
		    0x8A7C: 0x639B,
		    0x8A7D: 0x7B20,
		    0x8A7E: 0x6A2B,
		    0x8A80: 0x6A7F,
		    0x8A81: 0x68B6,
		    0x8A82: 0x9C0D,
		    0x8A83: 0x6F5F,
		    0x8A84: 0x5272,
		    0x8A85: 0x559D,
		    0x8A86: 0x6070,
		    0x8A87: 0x62EC,
		    0x8A88: 0x6D3B,
		    0x8A89: 0x6E07,
		    0x8A8A: 0x6ED1,
		    0x8A8B: 0x845B,
		    0x8A8C: 0x8910,
		    0x8A8D: 0x8F44,
		    0x8A8E: 0x4E14,
		    0x8A8F: 0x9C39,
		    0x8A90: 0x53F6,
		    0x8A91: 0x691B,
		    0x8A92: 0x6A3A,
		    0x8A93: 0x9784,
		    0x8A94: 0x682A,
		    0x8A95: 0x515C,
		    0x8A96: 0x7AC3,
		    0x8A97: 0x84B2,
		    0x8A98: 0x91DC,
		    0x8A99: 0x938C,
		    0x8A9A: 0x565B,
		    0x8A9B: 0x9D28,
		    0x8A9C: 0x6822,
		    0x8A9D: 0x8305,
		    0x8A9E: 0x8431,
		    0x8A9F: 0x7CA5,
		    0x8AA0: 0x5208,
		    0x8AA1: 0x82C5,
		    0x8AA2: 0x74E6,
		    0x8AA3: 0x4E7E,
		    0x8AA4: 0x4F83,
		    0x8AA5: 0x51A0,
		    0x8AA6: 0x5BD2,
		    0x8AA7: 0x520A,
		    0x8AA8: 0x52D8,
		    0x8AA9: 0x52E7,
		    0x8AAA: 0x5DFB,
		    0x8AAB: 0x559A,
		    0x8AAC: 0x582A,
		    0x8AAD: 0x59E6,
		    0x8AAE: 0x5B8C,
		    0x8AAF: 0x5B98,
		    0x8AB0: 0x5BDB,
		    0x8AB1: 0x5E72,
		    0x8AB2: 0x5E79,
		    0x8AB3: 0x60A3,
		    0x8AB4: 0x611F,
		    0x8AB5: 0x6163,
		    0x8AB6: 0x61BE,
		    0x8AB7: 0x63DB,
		    0x8AB8: 0x6562,
		    0x8AB9: 0x67D1,
		    0x8ABA: 0x6853,
		    0x8ABB: 0x68FA,
		    0x8ABC: 0x6B3E,
		    0x8ABD: 0x6B53,
		    0x8ABE: 0x6C57,
		    0x8ABF: 0x6F22,
		    0x8AC0: 0x6F97,
		    0x8AC1: 0x6F45,
		    0x8AC2: 0x74B0,
		    0x8AC3: 0x7518,
		    0x8AC4: 0x76E3,
		    0x8AC5: 0x770B,
		    0x8AC6: 0x7AFF,
		    0x8AC7: 0x7BA1,
		    0x8AC8: 0x7C21,
		    0x8AC9: 0x7DE9,
		    0x8ACA: 0x7F36,
		    0x8ACB: 0x7FF0,
		    0x8ACC: 0x809D,
		    0x8ACD: 0x8266,
		    0x8ACE: 0x839E,
		    0x8ACF: 0x89B3,
		    0x8AD0: 0x8ACC,
		    0x8AD1: 0x8CAB,
		    0x8AD2: 0x9084,
		    0x8AD3: 0x9451,
		    0x8AD4: 0x9593,
		    0x8AD5: 0x9591,
		    0x8AD6: 0x95A2,
		    0x8AD7: 0x9665,
		    0x8AD8: 0x97D3,
		    0x8AD9: 0x9928,
		    0x8ADA: 0x8218,
		    0x8ADB: 0x4E38,
		    0x8ADC: 0x542B,
		    0x8ADD: 0x5CB8,
		    0x8ADE: 0x5DCC,
		    0x8ADF: 0x73A9,
		    0x8AE0: 0x764C,
		    0x8AE1: 0x773C,
		    0x8AE2: 0x5CA9,
		    0x8AE3: 0x7FEB,
		    0x8AE4: 0x8D0B,
		    0x8AE5: 0x96C1,
		    0x8AE6: 0x9811,
		    0x8AE7: 0x9854,
		    0x8AE8: 0x9858,
		    0x8AE9: 0x4F01,
		    0x8AEA: 0x4F0E,
		    0x8AEB: 0x5371,
		    0x8AEC: 0x559C,
		    0x8AED: 0x5668,
		    0x8AEE: 0x57FA,
		    0x8AEF: 0x5947,
		    0x8AF0: 0x5B09,
		    0x8AF1: 0x5BC4,
		    0x8AF2: 0x5C90,
		    0x8AF3: 0x5E0C,
		    0x8AF4: 0x5E7E,
		    0x8AF5: 0x5FCC,
		    0x8AF6: 0x63EE,
		    0x8AF7: 0x673A,
		    0x8AF8: 0x65D7,
		    0x8AF9: 0x65E2,
		    0x8AFA: 0x671F,
		    0x8AFB: 0x68CB,
		    0x8AFC: 0x68C4,
		    0x8B40: 0x6A5F,
		    0x8B41: 0x5E30,
		    0x8B42: 0x6BC5,
		    0x8B43: 0x6C17,
		    0x8B44: 0x6C7D,
		    0x8B45: 0x757F,
		    0x8B46: 0x7948,
		    0x8B47: 0x5B63,
		    0x8B48: 0x7A00,
		    0x8B49: 0x7D00,
		    0x8B4A: 0x5FBD,
		    0x8B4B: 0x898F,
		    0x8B4C: 0x8A18,
		    0x8B4D: 0x8CB4,
		    0x8B4E: 0x8D77,
		    0x8B4F: 0x8ECC,
		    0x8B50: 0x8F1D,
		    0x8B51: 0x98E2,
		    0x8B52: 0x9A0E,
		    0x8B53: 0x9B3C,
		    0x8B54: 0x4E80,
		    0x8B55: 0x507D,
		    0x8B56: 0x5100,
		    0x8B57: 0x5993,
		    0x8B58: 0x5B9C,
		    0x8B59: 0x622F,
		    0x8B5A: 0x6280,
		    0x8B5B: 0x64EC,
		    0x8B5C: 0x6B3A,
		    0x8B5D: 0x72A0,
		    0x8B5E: 0x7591,
		    0x8B5F: 0x7947,
		    0x8B60: 0x7FA9,
		    0x8B61: 0x87FB,
		    0x8B62: 0x8ABC,
		    0x8B63: 0x8B70,
		    0x8B64: 0x63AC,
		    0x8B65: 0x83CA,
		    0x8B66: 0x97A0,
		    0x8B67: 0x5409,
		    0x8B68: 0x5403,
		    0x8B69: 0x55AB,
		    0x8B6A: 0x6854,
		    0x8B6B: 0x6A58,
		    0x8B6C: 0x8A70,
		    0x8B6D: 0x7827,
		    0x8B6E: 0x6775,
		    0x8B6F: 0x9ECD,
		    0x8B70: 0x5374,
		    0x8B71: 0x5BA2,
		    0x8B72: 0x811A,
		    0x8B73: 0x8650,
		    0x8B74: 0x9006,
		    0x8B75: 0x4E18,
		    0x8B76: 0x4E45,
		    0x8B77: 0x4EC7,
		    0x8B78: 0x4F11,
		    0x8B79: 0x53CA,
		    0x8B7A: 0x5438,
		    0x8B7B: 0x5BAE,
		    0x8B7C: 0x5F13,
		    0x8B7D: 0x6025,
		    0x8B7E: 0x6551,
		    0x8B80: 0x673D,
		    0x8B81: 0x6C42,
		    0x8B82: 0x6C72,
		    0x8B83: 0x6CE3,
		    0x8B84: 0x7078,
		    0x8B85: 0x7403,
		    0x8B86: 0x7A76,
		    0x8B87: 0x7AAE,
		    0x8B88: 0x7B08,
		    0x8B89: 0x7D1A,
		    0x8B8A: 0x7CFE,
		    0x8B8B: 0x7D66,
		    0x8B8C: 0x65E7,
		    0x8B8D: 0x725B,
		    0x8B8E: 0x53BB,
		    0x8B8F: 0x5C45,
		    0x8B90: 0x5DE8,
		    0x8B91: 0x62D2,
		    0x8B92: 0x62E0,
		    0x8B93: 0x6319,
		    0x8B94: 0x6E20,
		    0x8B95: 0x865A,
		    0x8B96: 0x8A31,
		    0x8B97: 0x8DDD,
		    0x8B98: 0x92F8,
		    0x8B99: 0x6F01,
		    0x8B9A: 0x79A6,
		    0x8B9B: 0x9B5A,
		    0x8B9C: 0x4EA8,
		    0x8B9D: 0x4EAB,
		    0x8B9E: 0x4EAC,
		    0x8B9F: 0x4F9B,
		    0x8BA0: 0x4FA0,
		    0x8BA1: 0x50D1,
		    0x8BA2: 0x5147,
		    0x8BA3: 0x7AF6,
		    0x8BA4: 0x5171,
		    0x8BA5: 0x51F6,
		    0x8BA6: 0x5354,
		    0x8BA7: 0x5321,
		    0x8BA8: 0x537F,
		    0x8BA9: 0x53EB,
		    0x8BAA: 0x55AC,
		    0x8BAB: 0x5883,
		    0x8BAC: 0x5CE1,
		    0x8BAD: 0x5F37,
		    0x8BAE: 0x5F4A,
		    0x8BAF: 0x602F,
		    0x8BB0: 0x6050,
		    0x8BB1: 0x606D,
		    0x8BB2: 0x631F,
		    0x8BB3: 0x6559,
		    0x8BB4: 0x6A4B,
		    0x8BB5: 0x6CC1,
		    0x8BB6: 0x72C2,
		    0x8BB7: 0x72ED,
		    0x8BB8: 0x77EF,
		    0x8BB9: 0x80F8,
		    0x8BBA: 0x8105,
		    0x8BBB: 0x8208,
		    0x8BBC: 0x854E,
		    0x8BBD: 0x90F7,
		    0x8BBE: 0x93E1,
		    0x8BBF: 0x97FF,
		    0x8BC0: 0x9957,
		    0x8BC1: 0x9A5A,
		    0x8BC2: 0x4EF0,
		    0x8BC3: 0x51DD,
		    0x8BC4: 0x5C2D,
		    0x8BC5: 0x6681,
		    0x8BC6: 0x696D,
		    0x8BC7: 0x5C40,
		    0x8BC8: 0x66F2,
		    0x8BC9: 0x6975,
		    0x8BCA: 0x7389,
		    0x8BCB: 0x6850,
		    0x8BCC: 0x7C81,
		    0x8BCD: 0x50C5,
		    0x8BCE: 0x52E4,
		    0x8BCF: 0x5747,
		    0x8BD0: 0x5DFE,
		    0x8BD1: 0x9326,
		    0x8BD2: 0x65A4,
		    0x8BD3: 0x6B23,
		    0x8BD4: 0x6B3D,
		    0x8BD5: 0x7434,
		    0x8BD6: 0x7981,
		    0x8BD7: 0x79BD,
		    0x8BD8: 0x7B4B,
		    0x8BD9: 0x7DCA,
		    0x8BDA: 0x82B9,
		    0x8BDB: 0x83CC,
		    0x8BDC: 0x887F,
		    0x8BDD: 0x895F,
		    0x8BDE: 0x8B39,
		    0x8BDF: 0x8FD1,
		    0x8BE0: 0x91D1,
		    0x8BE1: 0x541F,
		    0x8BE2: 0x9280,
		    0x8BE3: 0x4E5D,
		    0x8BE4: 0x5036,
		    0x8BE5: 0x53E5,
		    0x8BE6: 0x533A,
		    0x8BE7: 0x72D7,
		    0x8BE8: 0x7396,
		    0x8BE9: 0x77E9,
		    0x8BEA: 0x82E6,
		    0x8BEB: 0x8EAF,
		    0x8BEC: 0x99C6,
		    0x8BED: 0x99C8,
		    0x8BEE: 0x99D2,
		    0x8BEF: 0x5177,
		    0x8BF0: 0x611A,
		    0x8BF1: 0x865E,
		    0x8BF2: 0x55B0,
		    0x8BF3: 0x7A7A,
		    0x8BF4: 0x5076,
		    0x8BF5: 0x5BD3,
		    0x8BF6: 0x9047,
		    0x8BF7: 0x9685,
		    0x8BF8: 0x4E32,
		    0x8BF9: 0x6ADB,
		    0x8BFA: 0x91E7,
		    0x8BFB: 0x5C51,
		    0x8BFC: 0x5C48,
		    0x8C40: 0x6398,
		    0x8C41: 0x7A9F,
		    0x8C42: 0x6C93,
		    0x8C43: 0x9774,
		    0x8C44: 0x8F61,
		    0x8C45: 0x7AAA,
		    0x8C46: 0x718A,
		    0x8C47: 0x9688,
		    0x8C48: 0x7C82,
		    0x8C49: 0x6817,
		    0x8C4A: 0x7E70,
		    0x8C4B: 0x6851,
		    0x8C4C: 0x936C,
		    0x8C4D: 0x52F2,
		    0x8C4E: 0x541B,
		    0x8C4F: 0x85AB,
		    0x8C50: 0x8A13,
		    0x8C51: 0x7FA4,
		    0x8C52: 0x8ECD,
		    0x8C53: 0x90E1,
		    0x8C54: 0x5366,
		    0x8C55: 0x8888,
		    0x8C56: 0x7941,
		    0x8C57: 0x4FC2,
		    0x8C58: 0x50BE,
		    0x8C59: 0x5211,
		    0x8C5A: 0x5144,
		    0x8C5B: 0x5553,
		    0x8C5C: 0x572D,
		    0x8C5D: 0x73EA,
		    0x8C5E: 0x578B,
		    0x8C5F: 0x5951,
		    0x8C60: 0x5F62,
		    0x8C61: 0x5F84,
		    0x8C62: 0x6075,
		    0x8C63: 0x6176,
		    0x8C64: 0x6167,
		    0x8C65: 0x61A9,
		    0x8C66: 0x63B2,
		    0x8C67: 0x643A,
		    0x8C68: 0x656C,
		    0x8C69: 0x666F,
		    0x8C6A: 0x6842,
		    0x8C6B: 0x6E13,
		    0x8C6C: 0x7566,
		    0x8C6D: 0x7A3D,
		    0x8C6E: 0x7CFB,
		    0x8C6F: 0x7D4C,
		    0x8C70: 0x7D99,
		    0x8C71: 0x7E4B,
		    0x8C72: 0x7F6B,
		    0x8C73: 0x830E,
		    0x8C74: 0x834A,
		    0x8C75: 0x86CD,
		    0x8C76: 0x8A08,
		    0x8C77: 0x8A63,
		    0x8C78: 0x8B66,
		    0x8C79: 0x8EFD,
		    0x8C7A: 0x981A,
		    0x8C7B: 0x9D8F,
		    0x8C7C: 0x82B8,
		    0x8C7D: 0x8FCE,
		    0x8C7E: 0x9BE8,
		    0x8C80: 0x5287,
		    0x8C81: 0x621F,
		    0x8C82: 0x6483,
		    0x8C83: 0x6FC0,
		    0x8C84: 0x9699,
		    0x8C85: 0x6841,
		    0x8C86: 0x5091,
		    0x8C87: 0x6B20,
		    0x8C88: 0x6C7A,
		    0x8C89: 0x6F54,
		    0x8C8A: 0x7A74,
		    0x8C8B: 0x7D50,
		    0x8C8C: 0x8840,
		    0x8C8D: 0x8A23,
		    0x8C8E: 0x6708,
		    0x8C8F: 0x4EF6,
		    0x8C90: 0x5039,
		    0x8C91: 0x5026,
		    0x8C92: 0x5065,
		    0x8C93: 0x517C,
		    0x8C94: 0x5238,
		    0x8C95: 0x5263,
		    0x8C96: 0x55A7,
		    0x8C97: 0x570F,
		    0x8C98: 0x5805,
		    0x8C99: 0x5ACC,
		    0x8C9A: 0x5EFA,
		    0x8C9B: 0x61B2,
		    0x8C9C: 0x61F8,
		    0x8C9D: 0x62F3,
		    0x8C9E: 0x6372,
		    0x8C9F: 0x691C,
		    0x8CA0: 0x6A29,
		    0x8CA1: 0x727D,
		    0x8CA2: 0x72AC,
		    0x8CA3: 0x732E,
		    0x8CA4: 0x7814,
		    0x8CA5: 0x786F,
		    0x8CA6: 0x7D79,
		    0x8CA7: 0x770C,
		    0x8CA8: 0x80A9,
		    0x8CA9: 0x898B,
		    0x8CAA: 0x8B19,
		    0x8CAB: 0x8CE2,
		    0x8CAC: 0x8ED2,
		    0x8CAD: 0x9063,
		    0x8CAE: 0x9375,
		    0x8CAF: 0x967A,
		    0x8CB0: 0x9855,
		    0x8CB1: 0x9A13,
		    0x8CB2: 0x9E78,
		    0x8CB3: 0x5143,
		    0x8CB4: 0x539F,
		    0x8CB5: 0x53B3,
		    0x8CB6: 0x5E7B,
		    0x8CB7: 0x5F26,
		    0x8CB8: 0x6E1B,
		    0x8CB9: 0x6E90,
		    0x8CBA: 0x7384,
		    0x8CBB: 0x73FE,
		    0x8CBC: 0x7D43,
		    0x8CBD: 0x8237,
		    0x8CBE: 0x8A00,
		    0x8CBF: 0x8AFA,
		    0x8CC0: 0x9650,
		    0x8CC1: 0x4E4E,
		    0x8CC2: 0x500B,
		    0x8CC3: 0x53E4,
		    0x8CC4: 0x547C,
		    0x8CC5: 0x56FA,
		    0x8CC6: 0x59D1,
		    0x8CC7: 0x5B64,
		    0x8CC8: 0x5DF1,
		    0x8CC9: 0x5EAB,
		    0x8CCA: 0x5F27,
		    0x8CCB: 0x6238,
		    0x8CCC: 0x6545,
		    0x8CCD: 0x67AF,
		    0x8CCE: 0x6E56,
		    0x8CCF: 0x72D0,
		    0x8CD0: 0x7CCA,
		    0x8CD1: 0x88B4,
		    0x8CD2: 0x80A1,
		    0x8CD3: 0x80E1,
		    0x8CD4: 0x83F0,
		    0x8CD5: 0x864E,
		    0x8CD6: 0x8A87,
		    0x8CD7: 0x8DE8,
		    0x8CD8: 0x9237,
		    0x8CD9: 0x96C7,
		    0x8CDA: 0x9867,
		    0x8CDB: 0x9F13,
		    0x8CDC: 0x4E94,
		    0x8CDD: 0x4E92,
		    0x8CDE: 0x4F0D,
		    0x8CDF: 0x5348,
		    0x8CE0: 0x5449,
		    0x8CE1: 0x543E,
		    0x8CE2: 0x5A2F,
		    0x8CE3: 0x5F8C,
		    0x8CE4: 0x5FA1,
		    0x8CE5: 0x609F,
		    0x8CE6: 0x68A7,
		    0x8CE7: 0x6A8E,
		    0x8CE8: 0x745A,
		    0x8CE9: 0x7881,
		    0x8CEA: 0x8A9E,
		    0x8CEB: 0x8AA4,
		    0x8CEC: 0x8B77,
		    0x8CED: 0x9190,
		    0x8CEE: 0x4E5E,
		    0x8CEF: 0x9BC9,
		    0x8CF0: 0x4EA4,
		    0x8CF1: 0x4F7C,
		    0x8CF2: 0x4FAF,
		    0x8CF3: 0x5019,
		    0x8CF4: 0x5016,
		    0x8CF5: 0x5149,
		    0x8CF6: 0x516C,
		    0x8CF7: 0x529F,
		    0x8CF8: 0x52B9,
		    0x8CF9: 0x52FE,
		    0x8CFA: 0x539A,
		    0x8CFB: 0x53E3,
		    0x8CFC: 0x5411,
		    0x8D40: 0x540E,
		    0x8D41: 0x5589,
		    0x8D42: 0x5751,
		    0x8D43: 0x57A2,
		    0x8D44: 0x597D,
		    0x8D45: 0x5B54,
		    0x8D46: 0x5B5D,
		    0x8D47: 0x5B8F,
		    0x8D48: 0x5DE5,
		    0x8D49: 0x5DE7,
		    0x8D4A: 0x5DF7,
		    0x8D4B: 0x5E78,
		    0x8D4C: 0x5E83,
		    0x8D4D: 0x5E9A,
		    0x8D4E: 0x5EB7,
		    0x8D4F: 0x5F18,
		    0x8D50: 0x6052,
		    0x8D51: 0x614C,
		    0x8D52: 0x6297,
		    0x8D53: 0x62D8,
		    0x8D54: 0x63A7,
		    0x8D55: 0x653B,
		    0x8D56: 0x6602,
		    0x8D57: 0x6643,
		    0x8D58: 0x66F4,
		    0x8D59: 0x676D,
		    0x8D5A: 0x6821,
		    0x8D5B: 0x6897,
		    0x8D5C: 0x69CB,
		    0x8D5D: 0x6C5F,
		    0x8D5E: 0x6D2A,
		    0x8D5F: 0x6D69,
		    0x8D60: 0x6E2F,
		    0x8D61: 0x6E9D,
		    0x8D62: 0x7532,
		    0x8D63: 0x7687,
		    0x8D64: 0x786C,
		    0x8D65: 0x7A3F,
		    0x8D66: 0x7CE0,
		    0x8D67: 0x7D05,
		    0x8D68: 0x7D18,
		    0x8D69: 0x7D5E,
		    0x8D6A: 0x7DB1,
		    0x8D6B: 0x8015,
		    0x8D6C: 0x8003,
		    0x8D6D: 0x80AF,
		    0x8D6E: 0x80B1,
		    0x8D6F: 0x8154,
		    0x8D70: 0x818F,
		    0x8D71: 0x822A,
		    0x8D72: 0x8352,
		    0x8D73: 0x884C,
		    0x8D74: 0x8861,
		    0x8D75: 0x8B1B,
		    0x8D76: 0x8CA2,
		    0x8D77: 0x8CFC,
		    0x8D78: 0x90CA,
		    0x8D79: 0x9175,
		    0x8D7A: 0x9271,
		    0x8D7B: 0x783F,
		    0x8D7C: 0x92FC,
		    0x8D7D: 0x95A4,
		    0x8D7E: 0x964D,
		    0x8D80: 0x9805,
		    0x8D81: 0x9999,
		    0x8D82: 0x9AD8,
		    0x8D83: 0x9D3B,
		    0x8D84: 0x525B,
		    0x8D85: 0x52AB,
		    0x8D86: 0x53F7,
		    0x8D87: 0x5408,
		    0x8D88: 0x58D5,
		    0x8D89: 0x62F7,
		    0x8D8A: 0x6FE0,
		    0x8D8B: 0x8C6A,
		    0x8D8C: 0x8F5F,
		    0x8D8D: 0x9EB9,
		    0x8D8E: 0x514B,
		    0x8D8F: 0x523B,
		    0x8D90: 0x544A,
		    0x8D91: 0x56FD,
		    0x8D92: 0x7A40,
		    0x8D93: 0x9177,
		    0x8D94: 0x9D60,
		    0x8D95: 0x9ED2,
		    0x8D96: 0x7344,
		    0x8D97: 0x6F09,
		    0x8D98: 0x8170,
		    0x8D99: 0x7511,
		    0x8D9A: 0x5FFD,
		    0x8D9B: 0x60DA,
		    0x8D9C: 0x9AA8,
		    0x8D9D: 0x72DB,
		    0x8D9E: 0x8FBC,
		    0x8D9F: 0x6B64,
		    0x8DA0: 0x9803,
		    0x8DA1: 0x4ECA,
		    0x8DA2: 0x56F0,
		    0x8DA3: 0x5764,
		    0x8DA4: 0x58BE,
		    0x8DA5: 0x5A5A,
		    0x8DA6: 0x6068,
		    0x8DA7: 0x61C7,
		    0x8DA8: 0x660F,
		    0x8DA9: 0x6606,
		    0x8DAA: 0x6839,
		    0x8DAB: 0x68B1,
		    0x8DAC: 0x6DF7,
		    0x8DAD: 0x75D5,
		    0x8DAE: 0x7D3A,
		    0x8DAF: 0x826E,
		    0x8DB0: 0x9B42,
		    0x8DB1: 0x4E9B,
		    0x8DB2: 0x4F50,
		    0x8DB3: 0x53C9,
		    0x8DB4: 0x5506,
		    0x8DB5: 0x5D6F,
		    0x8DB6: 0x5DE6,
		    0x8DB7: 0x5DEE,
		    0x8DB8: 0x67FB,
		    0x8DB9: 0x6C99,
		    0x8DBA: 0x7473,
		    0x8DBB: 0x7802,
		    0x8DBC: 0x8A50,
		    0x8DBD: 0x9396,
		    0x8DBE: 0x88DF,
		    0x8DBF: 0x5750,
		    0x8DC0: 0x5EA7,
		    0x8DC1: 0x632B,
		    0x8DC2: 0x50B5,
		    0x8DC3: 0x50AC,
		    0x8DC4: 0x518D,
		    0x8DC5: 0x6700,
		    0x8DC6: 0x54C9,
		    0x8DC7: 0x585E,
		    0x8DC8: 0x59BB,
		    0x8DC9: 0x5BB0,
		    0x8DCA: 0x5F69,
		    0x8DCB: 0x624D,
		    0x8DCC: 0x63A1,
		    0x8DCD: 0x683D,
		    0x8DCE: 0x6B73,
		    0x8DCF: 0x6E08,
		    0x8DD0: 0x707D,
		    0x8DD1: 0x91C7,
		    0x8DD2: 0x7280,
		    0x8DD3: 0x7815,
		    0x8DD4: 0x7826,
		    0x8DD5: 0x796D,
		    0x8DD6: 0x658E,
		    0x8DD7: 0x7D30,
		    0x8DD8: 0x83DC,
		    0x8DD9: 0x88C1,
		    0x8DDA: 0x8F09,
		    0x8DDB: 0x969B,
		    0x8DDC: 0x5264,
		    0x8DDD: 0x5728,
		    0x8DDE: 0x6750,
		    0x8DDF: 0x7F6A,
		    0x8DE0: 0x8CA1,
		    0x8DE1: 0x51B4,
		    0x8DE2: 0x5742,
		    0x8DE3: 0x962A,
		    0x8DE4: 0x583A,
		    0x8DE5: 0x698A,
		    0x8DE6: 0x80B4,
		    0x8DE7: 0x54B2,
		    0x8DE8: 0x5D0E,
		    0x8DE9: 0x57FC,
		    0x8DEA: 0x7895,
		    0x8DEB: 0x9DFA,
		    0x8DEC: 0x4F5C,
		    0x8DED: 0x524A,
		    0x8DEE: 0x548B,
		    0x8DEF: 0x643E,
		    0x8DF0: 0x6628,
		    0x8DF1: 0x6714,
		    0x8DF2: 0x67F5,
		    0x8DF3: 0x7A84,
		    0x8DF4: 0x7B56,
		    0x8DF5: 0x7D22,
		    0x8DF6: 0x932F,
		    0x8DF7: 0x685C,
		    0x8DF8: 0x9BAD,
		    0x8DF9: 0x7B39,
		    0x8DFA: 0x5319,
		    0x8DFB: 0x518A,
		    0x8DFC: 0x5237,
		    0x8E40: 0x5BDF,
		    0x8E41: 0x62F6,
		    0x8E42: 0x64AE,
		    0x8E43: 0x64E6,
		    0x8E44: 0x672D,
		    0x8E45: 0x6BBA,
		    0x8E46: 0x85A9,
		    0x8E47: 0x96D1,
		    0x8E48: 0x7690,
		    0x8E49: 0x9BD6,
		    0x8E4A: 0x634C,
		    0x8E4B: 0x9306,
		    0x8E4C: 0x9BAB,
		    0x8E4D: 0x76BF,
		    0x8E4E: 0x6652,
		    0x8E4F: 0x4E09,
		    0x8E50: 0x5098,
		    0x8E51: 0x53C2,
		    0x8E52: 0x5C71,
		    0x8E53: 0x60E8,
		    0x8E54: 0x6492,
		    0x8E55: 0x6563,
		    0x8E56: 0x685F,
		    0x8E57: 0x71E6,
		    0x8E58: 0x73CA,
		    0x8E59: 0x7523,
		    0x8E5A: 0x7B97,
		    0x8E5B: 0x7E82,
		    0x8E5C: 0x8695,
		    0x8E5D: 0x8B83,
		    0x8E5E: 0x8CDB,
		    0x8E5F: 0x9178,
		    0x8E60: 0x9910,
		    0x8E61: 0x65AC,
		    0x8E62: 0x66AB,
		    0x8E63: 0x6B8B,
		    0x8E64: 0x4ED5,
		    0x8E65: 0x4ED4,
		    0x8E66: 0x4F3A,
		    0x8E67: 0x4F7F,
		    0x8E68: 0x523A,
		    0x8E69: 0x53F8,
		    0x8E6A: 0x53F2,
		    0x8E6B: 0x55E3,
		    0x8E6C: 0x56DB,
		    0x8E6D: 0x58EB,
		    0x8E6E: 0x59CB,
		    0x8E6F: 0x59C9,
		    0x8E70: 0x59FF,
		    0x8E71: 0x5B50,
		    0x8E72: 0x5C4D,
		    0x8E73: 0x5E02,
		    0x8E74: 0x5E2B,
		    0x8E75: 0x5FD7,
		    0x8E76: 0x601D,
		    0x8E77: 0x6307,
		    0x8E78: 0x652F,
		    0x8E79: 0x5B5C,
		    0x8E7A: 0x65AF,
		    0x8E7B: 0x65BD,
		    0x8E7C: 0x65E8,
		    0x8E7D: 0x679D,
		    0x8E7E: 0x6B62,
		    0x8E80: 0x6B7B,
		    0x8E81: 0x6C0F,
		    0x8E82: 0x7345,
		    0x8E83: 0x7949,
		    0x8E84: 0x79C1,
		    0x8E85: 0x7CF8,
		    0x8E86: 0x7D19,
		    0x8E87: 0x7D2B,
		    0x8E88: 0x80A2,
		    0x8E89: 0x8102,
		    0x8E8A: 0x81F3,
		    0x8E8B: 0x8996,
		    0x8E8C: 0x8A5E,
		    0x8E8D: 0x8A69,
		    0x8E8E: 0x8A66,
		    0x8E8F: 0x8A8C,
		    0x8E90: 0x8AEE,
		    0x8E91: 0x8CC7,
		    0x8E92: 0x8CDC,
		    0x8E93: 0x96CC,
		    0x8E94: 0x98FC,
		    0x8E95: 0x6B6F,
		    0x8E96: 0x4E8B,
		    0x8E97: 0x4F3C,
		    0x8E98: 0x4F8D,
		    0x8E99: 0x5150,
		    0x8E9A: 0x5B57,
		    0x8E9B: 0x5BFA,
		    0x8E9C: 0x6148,
		    0x8E9D: 0x6301,
		    0x8E9E: 0x6642,
		    0x8E9F: 0x6B21,
		    0x8EA0: 0x6ECB,
		    0x8EA1: 0x6CBB,
		    0x8EA2: 0x723E,
		    0x8EA3: 0x74BD,
		    0x8EA4: 0x75D4,
		    0x8EA5: 0x78C1,
		    0x8EA6: 0x793A,
		    0x8EA7: 0x800C,
		    0x8EA8: 0x8033,
		    0x8EA9: 0x81EA,
		    0x8EAA: 0x8494,
		    0x8EAB: 0x8F9E,
		    0x8EAC: 0x6C50,
		    0x8EAD: 0x9E7F,
		    0x8EAE: 0x5F0F,
		    0x8EAF: 0x8B58,
		    0x8EB0: 0x9D2B,
		    0x8EB1: 0x7AFA,
		    0x8EB2: 0x8EF8,
		    0x8EB3: 0x5B8D,
		    0x8EB4: 0x96EB,
		    0x8EB5: 0x4E03,
		    0x8EB6: 0x53F1,
		    0x8EB7: 0x57F7,
		    0x8EB8: 0x5931,
		    0x8EB9: 0x5AC9,
		    0x8EBA: 0x5BA4,
		    0x8EBB: 0x6089,
		    0x8EBC: 0x6E7F,
		    0x8EBD: 0x6F06,
		    0x8EBE: 0x75BE,
		    0x8EBF: 0x8CEA,
		    0x8EC0: 0x5B9F,
		    0x8EC1: 0x8500,
		    0x8EC2: 0x7BE0,
		    0x8EC3: 0x5072,
		    0x8EC4: 0x67F4,
		    0x8EC5: 0x829D,
		    0x8EC6: 0x5C61,
		    0x8EC7: 0x854A,
		    0x8EC8: 0x7E1E,
		    0x8EC9: 0x820E,
		    0x8ECA: 0x5199,
		    0x8ECB: 0x5C04,
		    0x8ECC: 0x6368,
		    0x8ECD: 0x8D66,
		    0x8ECE: 0x659C,
		    0x8ECF: 0x716E,
		    0x8ED0: 0x793E,
		    0x8ED1: 0x7D17,
		    0x8ED2: 0x8005,
		    0x8ED3: 0x8B1D,
		    0x8ED4: 0x8ECA,
		    0x8ED5: 0x906E,
		    0x8ED6: 0x86C7,
		    0x8ED7: 0x90AA,
		    0x8ED8: 0x501F,
		    0x8ED9: 0x52FA,
		    0x8EDA: 0x5C3A,
		    0x8EDB: 0x6753,
		    0x8EDC: 0x707C,
		    0x8EDD: 0x7235,
		    0x8EDE: 0x914C,
		    0x8EDF: 0x91C8,
		    0x8EE0: 0x932B,
		    0x8EE1: 0x82E5,
		    0x8EE2: 0x5BC2,
		    0x8EE3: 0x5F31,
		    0x8EE4: 0x60F9,
		    0x8EE5: 0x4E3B,
		    0x8EE6: 0x53D6,
		    0x8EE7: 0x5B88,
		    0x8EE8: 0x624B,
		    0x8EE9: 0x6731,
		    0x8EEA: 0x6B8A,
		    0x8EEB: 0x72E9,
		    0x8EEC: 0x73E0,
		    0x8EED: 0x7A2E,
		    0x8EEE: 0x816B,
		    0x8EEF: 0x8DA3,
		    0x8EF0: 0x9152,
		    0x8EF1: 0x9996,
		    0x8EF2: 0x5112,
		    0x8EF3: 0x53D7,
		    0x8EF4: 0x546A,
		    0x8EF5: 0x5BFF,
		    0x8EF6: 0x6388,
		    0x8EF7: 0x6A39,
		    0x8EF8: 0x7DAC,
		    0x8EF9: 0x9700,
		    0x8EFA: 0x56DA,
		    0x8EFB: 0x53CE,
		    0x8EFC: 0x5468,
		    0x8F40: 0x5B97,
		    0x8F41: 0x5C31,
		    0x8F42: 0x5DDE,
		    0x8F43: 0x4FEE,
		    0x8F44: 0x6101,
		    0x8F45: 0x62FE,
		    0x8F46: 0x6D32,
		    0x8F47: 0x79C0,
		    0x8F48: 0x79CB,
		    0x8F49: 0x7D42,
		    0x8F4A: 0x7E4D,
		    0x8F4B: 0x7FD2,
		    0x8F4C: 0x81ED,
		    0x8F4D: 0x821F,
		    0x8F4E: 0x8490,
		    0x8F4F: 0x8846,
		    0x8F50: 0x8972,
		    0x8F51: 0x8B90,
		    0x8F52: 0x8E74,
		    0x8F53: 0x8F2F,
		    0x8F54: 0x9031,
		    0x8F55: 0x914B,
		    0x8F56: 0x916C,
		    0x8F57: 0x96C6,
		    0x8F58: 0x919C,
		    0x8F59: 0x4EC0,
		    0x8F5A: 0x4F4F,
		    0x8F5B: 0x5145,
		    0x8F5C: 0x5341,
		    0x8F5D: 0x5F93,
		    0x8F5E: 0x620E,
		    0x8F5F: 0x67D4,
		    0x8F60: 0x6C41,
		    0x8F61: 0x6E0B,
		    0x8F62: 0x7363,
		    0x8F63: 0x7E26,
		    0x8F64: 0x91CD,
		    0x8F65: 0x9283,
		    0x8F66: 0x53D4,
		    0x8F67: 0x5919,
		    0x8F68: 0x5BBF,
		    0x8F69: 0x6DD1,
		    0x8F6A: 0x795D,
		    0x8F6B: 0x7E2E,
		    0x8F6C: 0x7C9B,
		    0x8F6D: 0x587E,
		    0x8F6E: 0x719F,
		    0x8F6F: 0x51FA,
		    0x8F70: 0x8853,
		    0x8F71: 0x8FF0,
		    0x8F72: 0x4FCA,
		    0x8F73: 0x5CFB,
		    0x8F74: 0x6625,
		    0x8F75: 0x77AC,
		    0x8F76: 0x7AE3,
		    0x8F77: 0x821C,
		    0x8F78: 0x99FF,
		    0x8F79: 0x51C6,
		    0x8F7A: 0x5FAA,
		    0x8F7B: 0x65EC,
		    0x8F7C: 0x696F,
		    0x8F7D: 0x6B89,
		    0x8F7E: 0x6DF3,
		    0x8F80: 0x6E96,
		    0x8F81: 0x6F64,
		    0x8F82: 0x76FE,
		    0x8F83: 0x7D14,
		    0x8F84: 0x5DE1,
		    0x8F85: 0x9075,
		    0x8F86: 0x9187,
		    0x8F87: 0x9806,
		    0x8F88: 0x51E6,
		    0x8F89: 0x521D,
		    0x8F8A: 0x6240,
		    0x8F8B: 0x6691,
		    0x8F8C: 0x66D9,
		    0x8F8D: 0x6E1A,
		    0x8F8E: 0x5EB6,
		    0x8F8F: 0x7DD2,
		    0x8F90: 0x7F72,
		    0x8F91: 0x66F8,
		    0x8F92: 0x85AF,
		    0x8F93: 0x85F7,
		    0x8F94: 0x8AF8,
		    0x8F95: 0x52A9,
		    0x8F96: 0x53D9,
		    0x8F97: 0x5973,
		    0x8F98: 0x5E8F,
		    0x8F99: 0x5F90,
		    0x8F9A: 0x6055,
		    0x8F9B: 0x92E4,
		    0x8F9C: 0x9664,
		    0x8F9D: 0x50B7,
		    0x8F9E: 0x511F,
		    0x8F9F: 0x52DD,
		    0x8FA0: 0x5320,
		    0x8FA1: 0x5347,
		    0x8FA2: 0x53EC,
		    0x8FA3: 0x54E8,
		    0x8FA4: 0x5546,
		    0x8FA5: 0x5531,
		    0x8FA6: 0x5617,
		    0x8FA7: 0x5968,
		    0x8FA8: 0x59BE,
		    0x8FA9: 0x5A3C,
		    0x8FAA: 0x5BB5,
		    0x8FAB: 0x5C06,
		    0x8FAC: 0x5C0F,
		    0x8FAD: 0x5C11,
		    0x8FAE: 0x5C1A,
		    0x8FAF: 0x5E84,
		    0x8FB0: 0x5E8A,
		    0x8FB1: 0x5EE0,
		    0x8FB2: 0x5F70,
		    0x8FB3: 0x627F,
		    0x8FB4: 0x6284,
		    0x8FB5: 0x62DB,
		    0x8FB6: 0x638C,
		    0x8FB7: 0x6377,
		    0x8FB8: 0x6607,
		    0x8FB9: 0x660C,
		    0x8FBA: 0x662D,
		    0x8FBB: 0x6676,
		    0x8FBC: 0x677E,
		    0x8FBD: 0x68A2,
		    0x8FBE: 0x6A1F,
		    0x8FBF: 0x6A35,
		    0x8FC0: 0x6CBC,
		    0x8FC1: 0x6D88,
		    0x8FC2: 0x6E09,
		    0x8FC3: 0x6E58,
		    0x8FC4: 0x713C,
		    0x8FC5: 0x7126,
		    0x8FC6: 0x7167,
		    0x8FC7: 0x75C7,
		    0x8FC8: 0x7701,
		    0x8FC9: 0x785D,
		    0x8FCA: 0x7901,
		    0x8FCB: 0x7965,
		    0x8FCC: 0x79F0,
		    0x8FCD: 0x7AE0,
		    0x8FCE: 0x7B11,
		    0x8FCF: 0x7CA7,
		    0x8FD0: 0x7D39,
		    0x8FD1: 0x8096,
		    0x8FD2: 0x83D6,
		    0x8FD3: 0x848B,
		    0x8FD4: 0x8549,
		    0x8FD5: 0x885D,
		    0x8FD6: 0x88F3,
		    0x8FD7: 0x8A1F,
		    0x8FD8: 0x8A3C,
		    0x8FD9: 0x8A54,
		    0x8FDA: 0x8A73,
		    0x8FDB: 0x8C61,
		    0x8FDC: 0x8CDE,
		    0x8FDD: 0x91A4,
		    0x8FDE: 0x9266,
		    0x8FDF: 0x937E,
		    0x8FE0: 0x9418,
		    0x8FE1: 0x969C,
		    0x8FE2: 0x9798,
		    0x8FE3: 0x4E0A,
		    0x8FE4: 0x4E08,
		    0x8FE5: 0x4E1E,
		    0x8FE6: 0x4E57,
		    0x8FE7: 0x5197,
		    0x8FE8: 0x5270,
		    0x8FE9: 0x57CE,
		    0x8FEA: 0x5834,
		    0x8FEB: 0x58CC,
		    0x8FEC: 0x5B22,
		    0x8FED: 0x5E38,
		    0x8FEE: 0x60C5,
		    0x8FEF: 0x64FE,
		    0x8FF0: 0x6761,
		    0x8FF1: 0x6756,
		    0x8FF2: 0x6D44,
		    0x8FF3: 0x72B6,
		    0x8FF4: 0x7573,
		    0x8FF5: 0x7A63,
		    0x8FF6: 0x84B8,
		    0x8FF7: 0x8B72,
		    0x8FF8: 0x91B8,
		    0x8FF9: 0x9320,
		    0x8FFA: 0x5631,
		    0x8FFB: 0x57F4,
		    0x8FFC: 0x98FE,
		    0x9040: 0x62ED,
		    0x9041: 0x690D,
		    0x9042: 0x6B96,
		    0x9043: 0x71ED,
		    0x9044: 0x7E54,
		    0x9045: 0x8077,
		    0x9046: 0x8272,
		    0x9047: 0x89E6,
		    0x9048: 0x98DF,
		    0x9049: 0x8755,
		    0x904A: 0x8FB1,
		    0x904B: 0x5C3B,
		    0x904C: 0x4F38,
		    0x904D: 0x4FE1,
		    0x904E: 0x4FB5,
		    0x904F: 0x5507,
		    0x9050: 0x5A20,
		    0x9051: 0x5BDD,
		    0x9052: 0x5BE9,
		    0x9053: 0x5FC3,
		    0x9054: 0x614E,
		    0x9055: 0x632F,
		    0x9056: 0x65B0,
		    0x9057: 0x664B,
		    0x9058: 0x68EE,
		    0x9059: 0x699B,
		    0x905A: 0x6D78,
		    0x905B: 0x6DF1,
		    0x905C: 0x7533,
		    0x905D: 0x75B9,
		    0x905E: 0x771F,
		    0x905F: 0x795E,
		    0x9060: 0x79E6,
		    0x9061: 0x7D33,
		    0x9062: 0x81E3,
		    0x9063: 0x82AF,
		    0x9064: 0x85AA,
		    0x9065: 0x89AA,
		    0x9066: 0x8A3A,
		    0x9067: 0x8EAB,
		    0x9068: 0x8F9B,
		    0x9069: 0x9032,
		    0x906A: 0x91DD,
		    0x906B: 0x9707,
		    0x906C: 0x4EBA,
		    0x906D: 0x4EC1,
		    0x906E: 0x5203,
		    0x906F: 0x5875,
		    0x9070: 0x58EC,
		    0x9071: 0x5C0B,
		    0x9072: 0x751A,
		    0x9073: 0x5C3D,
		    0x9074: 0x814E,
		    0x9075: 0x8A0A,
		    0x9076: 0x8FC5,
		    0x9077: 0x9663,
		    0x9078: 0x976D,
		    0x9079: 0x7B25,
		    0x907A: 0x8ACF,
		    0x907B: 0x9808,
		    0x907C: 0x9162,
		    0x907D: 0x56F3,
		    0x907E: 0x53A8,
		    0x9080: 0x9017,
		    0x9081: 0x5439,
		    0x9082: 0x5782,
		    0x9083: 0x5E25,
		    0x9084: 0x63A8,
		    0x9085: 0x6C34,
		    0x9086: 0x708A,
		    0x9087: 0x7761,
		    0x9088: 0x7C8B,
		    0x9089: 0x7FE0,
		    0x908A: 0x8870,
		    0x908B: 0x9042,
		    0x908C: 0x9154,
		    0x908D: 0x9310,
		    0x908E: 0x9318,
		    0x908F: 0x968F,
		    0x9090: 0x745E,
		    0x9091: 0x9AC4,
		    0x9092: 0x5D07,
		    0x9093: 0x5D69,
		    0x9094: 0x6570,
		    0x9095: 0x67A2,
		    0x9096: 0x8DA8,
		    0x9097: 0x96DB,
		    0x9098: 0x636E,
		    0x9099: 0x6749,
		    0x909A: 0x6919,
		    0x909B: 0x83C5,
		    0x909C: 0x9817,
		    0x909D: 0x96C0,
		    0x909E: 0x88FE,
		    0x909F: 0x6F84,
		    0x90A0: 0x647A,
		    0x90A1: 0x5BF8,
		    0x90A2: 0x4E16,
		    0x90A3: 0x702C,
		    0x90A4: 0x755D,
		    0x90A5: 0x662F,
		    0x90A6: 0x51C4,
		    0x90A7: 0x5236,
		    0x90A8: 0x52E2,
		    0x90A9: 0x59D3,
		    0x90AA: 0x5F81,
		    0x90AB: 0x6027,
		    0x90AC: 0x6210,
		    0x90AD: 0x653F,
		    0x90AE: 0x6574,
		    0x90AF: 0x661F,
		    0x90B0: 0x6674,
		    0x90B1: 0x68F2,
		    0x90B2: 0x6816,
		    0x90B3: 0x6B63,
		    0x90B4: 0x6E05,
		    0x90B5: 0x7272,
		    0x90B6: 0x751F,
		    0x90B7: 0x76DB,
		    0x90B8: 0x7CBE,
		    0x90B9: 0x8056,
		    0x90BA: 0x58F0,
		    0x90BB: 0x88FD,
		    0x90BC: 0x897F,
		    0x90BD: 0x8AA0,
		    0x90BE: 0x8A93,
		    0x90BF: 0x8ACB,
		    0x90C0: 0x901D,
		    0x90C1: 0x9192,
		    0x90C2: 0x9752,
		    0x90C3: 0x9759,
		    0x90C4: 0x6589,
		    0x90C5: 0x7A0E,
		    0x90C6: 0x8106,
		    0x90C7: 0x96BB,
		    0x90C8: 0x5E2D,
		    0x90C9: 0x60DC,
		    0x90CA: 0x621A,
		    0x90CB: 0x65A5,
		    0x90CC: 0x6614,
		    0x90CD: 0x6790,
		    0x90CE: 0x77F3,
		    0x90CF: 0x7A4D,
		    0x90D0: 0x7C4D,
		    0x90D1: 0x7E3E,
		    0x90D2: 0x810A,
		    0x90D3: 0x8CAC,
		    0x90D4: 0x8D64,
		    0x90D5: 0x8DE1,
		    0x90D6: 0x8E5F,
		    0x90D7: 0x78A9,
		    0x90D8: 0x5207,
		    0x90D9: 0x62D9,
		    0x90DA: 0x63A5,
		    0x90DB: 0x6442,
		    0x90DC: 0x6298,
		    0x90DD: 0x8A2D,
		    0x90DE: 0x7A83,
		    0x90DF: 0x7BC0,
		    0x90E0: 0x8AAC,
		    0x90E1: 0x96EA,
		    0x90E2: 0x7D76,
		    0x90E3: 0x820C,
		    0x90E4: 0x8749,
		    0x90E5: 0x4ED9,
		    0x90E6: 0x5148,
		    0x90E7: 0x5343,
		    0x90E8: 0x5360,
		    0x90E9: 0x5BA3,
		    0x90EA: 0x5C02,
		    0x90EB: 0x5C16,
		    0x90EC: 0x5DDD,
		    0x90ED: 0x6226,
		    0x90EE: 0x6247,
		    0x90EF: 0x64B0,
		    0x90F0: 0x6813,
		    0x90F1: 0x6834,
		    0x90F2: 0x6CC9,
		    0x90F3: 0x6D45,
		    0x90F4: 0x6D17,
		    0x90F5: 0x67D3,
		    0x90F6: 0x6F5C,
		    0x90F7: 0x714E,
		    0x90F8: 0x717D,
		    0x90F9: 0x65CB,
		    0x90FA: 0x7A7F,
		    0x90FB: 0x7BAD,
		    0x90FC: 0x7DDA,
		    0x9140: 0x7E4A,
		    0x9141: 0x7FA8,
		    0x9142: 0x817A,
		    0x9143: 0x821B,
		    0x9144: 0x8239,
		    0x9145: 0x85A6,
		    0x9146: 0x8A6E,
		    0x9147: 0x8CCE,
		    0x9148: 0x8DF5,
		    0x9149: 0x9078,
		    0x914A: 0x9077,
		    0x914B: 0x92AD,
		    0x914C: 0x9291,
		    0x914D: 0x9583,
		    0x914E: 0x9BAE,
		    0x914F: 0x524D,
		    0x9150: 0x5584,
		    0x9151: 0x6F38,
		    0x9152: 0x7136,
		    0x9153: 0x5168,
		    0x9154: 0x7985,
		    0x9155: 0x7E55,
		    0x9156: 0x81B3,
		    0x9157: 0x7CCE,
		    0x9158: 0x564C,
		    0x9159: 0x5851,
		    0x915A: 0x5CA8,
		    0x915B: 0x63AA,
		    0x915C: 0x66FE,
		    0x915D: 0x66FD,
		    0x915E: 0x695A,
		    0x915F: 0x72D9,
		    0x9160: 0x758F,
		    0x9161: 0x758E,
		    0x9162: 0x790E,
		    0x9163: 0x7956,
		    0x9164: 0x79DF,
		    0x9165: 0x7C97,
		    0x9166: 0x7D20,
		    0x9167: 0x7D44,
		    0x9168: 0x8607,
		    0x9169: 0x8A34,
		    0x916A: 0x963B,
		    0x916B: 0x9061,
		    0x916C: 0x9F20,
		    0x916D: 0x50E7,
		    0x916E: 0x5275,
		    0x916F: 0x53CC,
		    0x9170: 0x53E2,
		    0x9171: 0x5009,
		    0x9172: 0x55AA,
		    0x9173: 0x58EE,
		    0x9174: 0x594F,
		    0x9175: 0x723D,
		    0x9176: 0x5B8B,
		    0x9177: 0x5C64,
		    0x9178: 0x531D,
		    0x9179: 0x60E3,
		    0x917A: 0x60F3,
		    0x917B: 0x635C,
		    0x917C: 0x6383,
		    0x917D: 0x633F,
		    0x917E: 0x63BB,
		    0x9180: 0x64CD,
		    0x9181: 0x65E9,
		    0x9182: 0x66F9,
		    0x9183: 0x5DE3,
		    0x9184: 0x69CD,
		    0x9185: 0x69FD,
		    0x9186: 0x6F15,
		    0x9187: 0x71E5,
		    0x9188: 0x4E89,
		    0x9189: 0x75E9,
		    0x918A: 0x76F8,
		    0x918B: 0x7A93,
		    0x918C: 0x7CDF,
		    0x918D: 0x7DCF,
		    0x918E: 0x7D9C,
		    0x918F: 0x8061,
		    0x9190: 0x8349,
		    0x9191: 0x8358,
		    0x9192: 0x846C,
		    0x9193: 0x84BC,
		    0x9194: 0x85FB,
		    0x9195: 0x88C5,
		    0x9196: 0x8D70,
		    0x9197: 0x9001,
		    0x9198: 0x906D,
		    0x9199: 0x9397,
		    0x919A: 0x971C,
		    0x919B: 0x9A12,
		    0x919C: 0x50CF,
		    0x919D: 0x5897,
		    0x919E: 0x618E,
		    0x919F: 0x81D3,
		    0x91A0: 0x8535,
		    0x91A1: 0x8D08,
		    0x91A2: 0x9020,
		    0x91A3: 0x4FC3,
		    0x91A4: 0x5074,
		    0x91A5: 0x5247,
		    0x91A6: 0x5373,
		    0x91A7: 0x606F,
		    0x91A8: 0x6349,
		    0x91A9: 0x675F,
		    0x91AA: 0x6E2C,
		    0x91AB: 0x8DB3,
		    0x91AC: 0x901F,
		    0x91AD: 0x4FD7,
		    0x91AE: 0x5C5E,
		    0x91AF: 0x8CCA,
		    0x91B0: 0x65CF,
		    0x91B1: 0x7D9A,
		    0x91B2: 0x5352,
		    0x91B3: 0x8896,
		    0x91B4: 0x5176,
		    0x91B5: 0x63C3,
		    0x91B6: 0x5B58,
		    0x91B7: 0x5B6B,
		    0x91B8: 0x5C0A,
		    0x91B9: 0x640D,
		    0x91BA: 0x6751,
		    0x91BB: 0x905C,
		    0x91BC: 0x4ED6,
		    0x91BD: 0x591A,
		    0x91BE: 0x592A,
		    0x91BF: 0x6C70,
		    0x91C0: 0x8A51,
		    0x91C1: 0x553E,
		    0x91C2: 0x5815,
		    0x91C3: 0x59A5,
		    0x91C4: 0x60F0,
		    0x91C5: 0x6253,
		    0x91C6: 0x67C1,
		    0x91C7: 0x8235,
		    0x91C8: 0x6955,
		    0x91C9: 0x9640,
		    0x91CA: 0x99C4,
		    0x91CB: 0x9A28,
		    0x91CC: 0x4F53,
		    0x91CD: 0x5806,
		    0x91CE: 0x5BFE,
		    0x91CF: 0x8010,
		    0x91D0: 0x5CB1,
		    0x91D1: 0x5E2F,
		    0x91D2: 0x5F85,
		    0x91D3: 0x6020,
		    0x91D4: 0x614B,
		    0x91D5: 0x6234,
		    0x91D6: 0x66FF,
		    0x91D7: 0x6CF0,
		    0x91D8: 0x6EDE,
		    0x91D9: 0x80CE,
		    0x91DA: 0x817F,
		    0x91DB: 0x82D4,
		    0x91DC: 0x888B,
		    0x91DD: 0x8CB8,
		    0x91DE: 0x9000,
		    0x91DF: 0x902E,
		    0x91E0: 0x968A,
		    0x91E1: 0x9EDB,
		    0x91E2: 0x9BDB,
		    0x91E3: 0x4EE3,
		    0x91E4: 0x53F0,
		    0x91E5: 0x5927,
		    0x91E6: 0x7B2C,
		    0x91E7: 0x918D,
		    0x91E8: 0x984C,
		    0x91E9: 0x9DF9,
		    0x91EA: 0x6EDD,
		    0x91EB: 0x7027,
		    0x91EC: 0x5353,
		    0x91ED: 0x5544,
		    0x91EE: 0x5B85,
		    0x91EF: 0x6258,
		    0x91F0: 0x629E,
		    0x91F1: 0x62D3,
		    0x91F2: 0x6CA2,
		    0x91F3: 0x6FEF,
		    0x91F4: 0x7422,
		    0x91F5: 0x8A17,
		    0x91F6: 0x9438,
		    0x91F7: 0x6FC1,
		    0x91F8: 0x8AFE,
		    0x91F9: 0x8338,
		    0x91FA: 0x51E7,
		    0x91FB: 0x86F8,
		    0x91FC: 0x53EA,
		    0x9240: 0x53E9,
		    0x9241: 0x4F46,
		    0x9242: 0x9054,
		    0x9243: 0x8FB0,
		    0x9244: 0x596A,
		    0x9245: 0x8131,
		    0x9246: 0x5DFD,
		    0x9247: 0x7AEA,
		    0x9248: 0x8FBF,
		    0x9249: 0x68DA,
		    0x924A: 0x8C37,
		    0x924B: 0x72F8,
		    0x924C: 0x9C48,
		    0x924D: 0x6A3D,
		    0x924E: 0x8AB0,
		    0x924F: 0x4E39,
		    0x9250: 0x5358,
		    0x9251: 0x5606,
		    0x9252: 0x5766,
		    0x9253: 0x62C5,
		    0x9254: 0x63A2,
		    0x9255: 0x65E6,
		    0x9256: 0x6B4E,
		    0x9257: 0x6DE1,
		    0x9258: 0x6E5B,
		    0x9259: 0x70AD,
		    0x925A: 0x77ED,
		    0x925B: 0x7AEF,
		    0x925C: 0x7BAA,
		    0x925D: 0x7DBB,
		    0x925E: 0x803D,
		    0x925F: 0x80C6,
		    0x9260: 0x86CB,
		    0x9261: 0x8A95,
		    0x9262: 0x935B,
		    0x9263: 0x56E3,
		    0x9264: 0x58C7,
		    0x9265: 0x5F3E,
		    0x9266: 0x65AD,
		    0x9267: 0x6696,
		    0x9268: 0x6A80,
		    0x9269: 0x6BB5,
		    0x926A: 0x7537,
		    0x926B: 0x8AC7,
		    0x926C: 0x5024,
		    0x926D: 0x77E5,
		    0x926E: 0x5730,
		    0x926F: 0x5F1B,
		    0x9270: 0x6065,
		    0x9271: 0x667A,
		    0x9272: 0x6C60,
		    0x9273: 0x75F4,
		    0x9274: 0x7A1A,
		    0x9275: 0x7F6E,
		    0x9276: 0x81F4,
		    0x9277: 0x8718,
		    0x9278: 0x9045,
		    0x9279: 0x99B3,
		    0x927A: 0x7BC9,
		    0x927B: 0x755C,
		    0x927C: 0x7AF9,
		    0x927D: 0x7B51,
		    0x927E: 0x84C4,
		    0x9280: 0x9010,
		    0x9281: 0x79E9,
		    0x9282: 0x7A92,
		    0x9283: 0x8336,
		    0x9284: 0x5AE1,
		    0x9285: 0x7740,
		    0x9286: 0x4E2D,
		    0x9287: 0x4EF2,
		    0x9288: 0x5B99,
		    0x9289: 0x5FE0,
		    0x928A: 0x62BD,
		    0x928B: 0x663C,
		    0x928C: 0x67F1,
		    0x928D: 0x6CE8,
		    0x928E: 0x866B,
		    0x928F: 0x8877,
		    0x9290: 0x8A3B,
		    0x9291: 0x914E,
		    0x9292: 0x92F3,
		    0x9293: 0x99D0,
		    0x9294: 0x6A17,
		    0x9295: 0x7026,
		    0x9296: 0x732A,
		    0x9297: 0x82E7,
		    0x9298: 0x8457,
		    0x9299: 0x8CAF,
		    0x929A: 0x4E01,
		    0x929B: 0x5146,
		    0x929C: 0x51CB,
		    0x929D: 0x558B,
		    0x929E: 0x5BF5,
		    0x929F: 0x5E16,
		    0x92A0: 0x5E33,
		    0x92A1: 0x5E81,
		    0x92A2: 0x5F14,
		    0x92A3: 0x5F35,
		    0x92A4: 0x5F6B,
		    0x92A5: 0x5FB4,
		    0x92A6: 0x61F2,
		    0x92A7: 0x6311,
		    0x92A8: 0x66A2,
		    0x92A9: 0x671D,
		    0x92AA: 0x6F6E,
		    0x92AB: 0x7252,
		    0x92AC: 0x753A,
		    0x92AD: 0x773A,
		    0x92AE: 0x8074,
		    0x92AF: 0x8139,
		    0x92B0: 0x8178,
		    0x92B1: 0x8776,
		    0x92B2: 0x8ABF,
		    0x92B3: 0x8ADC,
		    0x92B4: 0x8D85,
		    0x92B5: 0x8DF3,
		    0x92B6: 0x929A,
		    0x92B7: 0x9577,
		    0x92B8: 0x9802,
		    0x92B9: 0x9CE5,
		    0x92BA: 0x52C5,
		    0x92BB: 0x6357,
		    0x92BC: 0x76F4,
		    0x92BD: 0x6715,
		    0x92BE: 0x6C88,
		    0x92BF: 0x73CD,
		    0x92C0: 0x8CC3,
		    0x92C1: 0x93AE,
		    0x92C2: 0x9673,
		    0x92C3: 0x6D25,
		    0x92C4: 0x589C,
		    0x92C5: 0x690E,
		    0x92C6: 0x69CC,
		    0x92C7: 0x8FFD,
		    0x92C8: 0x939A,
		    0x92C9: 0x75DB,
		    0x92CA: 0x901A,
		    0x92CB: 0x585A,
		    0x92CC: 0x6802,
		    0x92CD: 0x63B4,
		    0x92CE: 0x69FB,
		    0x92CF: 0x4F43,
		    0x92D0: 0x6F2C,
		    0x92D1: 0x67D8,
		    0x92D2: 0x8FBB,
		    0x92D3: 0x8526,
		    0x92D4: 0x7DB4,
		    0x92D5: 0x9354,
		    0x92D6: 0x693F,
		    0x92D7: 0x6F70,
		    0x92D8: 0x576A,
		    0x92D9: 0x58F7,
		    0x92DA: 0x5B2C,
		    0x92DB: 0x7D2C,
		    0x92DC: 0x722A,
		    0x92DD: 0x540A,
		    0x92DE: 0x91E3,
		    0x92DF: 0x9DB4,
		    0x92E0: 0x4EAD,
		    0x92E1: 0x4F4E,
		    0x92E2: 0x505C,
		    0x92E3: 0x5075,
		    0x92E4: 0x5243,
		    0x92E5: 0x8C9E,
		    0x92E6: 0x5448,
		    0x92E7: 0x5824,
		    0x92E8: 0x5B9A,
		    0x92E9: 0x5E1D,
		    0x92EA: 0x5E95,
		    0x92EB: 0x5EAD,
		    0x92EC: 0x5EF7,
		    0x92ED: 0x5F1F,
		    0x92EE: 0x608C,
		    0x92EF: 0x62B5,
		    0x92F0: 0x633A,
		    0x92F1: 0x63D0,
		    0x92F2: 0x68AF,
		    0x92F3: 0x6C40,
		    0x92F4: 0x7887,
		    0x92F5: 0x798E,
		    0x92F6: 0x7A0B,
		    0x92F7: 0x7DE0,
		    0x92F8: 0x8247,
		    0x92F9: 0x8A02,
		    0x92FA: 0x8AE6,
		    0x92FB: 0x8E44,
		    0x92FC: 0x9013,
		    0x9340: 0x90B8,
		    0x9341: 0x912D,
		    0x9342: 0x91D8,
		    0x9343: 0x9F0E,
		    0x9344: 0x6CE5,
		    0x9345: 0x6458,
		    0x9346: 0x64E2,
		    0x9347: 0x6575,
		    0x9348: 0x6EF4,
		    0x9349: 0x7684,
		    0x934A: 0x7B1B,
		    0x934B: 0x9069,
		    0x934C: 0x93D1,
		    0x934D: 0x6EBA,
		    0x934E: 0x54F2,
		    0x934F: 0x5FB9,
		    0x9350: 0x64A4,
		    0x9351: 0x8F4D,
		    0x9352: 0x8FED,
		    0x9353: 0x9244,
		    0x9354: 0x5178,
		    0x9355: 0x586B,
		    0x9356: 0x5929,
		    0x9357: 0x5C55,
		    0x9358: 0x5E97,
		    0x9359: 0x6DFB,
		    0x935A: 0x7E8F,
		    0x935B: 0x751C,
		    0x935C: 0x8CBC,
		    0x935D: 0x8EE2,
		    0x935E: 0x985B,
		    0x935F: 0x70B9,
		    0x9360: 0x4F1D,
		    0x9361: 0x6BBF,
		    0x9362: 0x6FB1,
		    0x9363: 0x7530,
		    0x9364: 0x96FB,
		    0x9365: 0x514E,
		    0x9366: 0x5410,
		    0x9367: 0x5835,
		    0x9368: 0x5857,
		    0x9369: 0x59AC,
		    0x936A: 0x5C60,
		    0x936B: 0x5F92,
		    0x936C: 0x6597,
		    0x936D: 0x675C,
		    0x936E: 0x6E21,
		    0x936F: 0x767B,
		    0x9370: 0x83DF,
		    0x9371: 0x8CED,
		    0x9372: 0x9014,
		    0x9373: 0x90FD,
		    0x9374: 0x934D,
		    0x9375: 0x7825,
		    0x9376: 0x783A,
		    0x9377: 0x52AA,
		    0x9378: 0x5EA6,
		    0x9379: 0x571F,
		    0x937A: 0x5974,
		    0x937B: 0x6012,
		    0x937C: 0x5012,
		    0x937D: 0x515A,
		    0x937E: 0x51AC,
		    0x9380: 0x51CD,
		    0x9381: 0x5200,
		    0x9382: 0x5510,
		    0x9383: 0x5854,
		    0x9384: 0x5858,
		    0x9385: 0x5957,
		    0x9386: 0x5B95,
		    0x9387: 0x5CF6,
		    0x9388: 0x5D8B,
		    0x9389: 0x60BC,
		    0x938A: 0x6295,
		    0x938B: 0x642D,
		    0x938C: 0x6771,
		    0x938D: 0x6843,
		    0x938E: 0x68BC,
		    0x938F: 0x68DF,
		    0x9390: 0x76D7,
		    0x9391: 0x6DD8,
		    0x9392: 0x6E6F,
		    0x9393: 0x6D9B,
		    0x9394: 0x706F,
		    0x9395: 0x71C8,
		    0x9396: 0x5F53,
		    0x9397: 0x75D8,
		    0x9398: 0x7977,
		    0x9399: 0x7B49,
		    0x939A: 0x7B54,
		    0x939B: 0x7B52,
		    0x939C: 0x7CD6,
		    0x939D: 0x7D71,
		    0x939E: 0x5230,
		    0x939F: 0x8463,
		    0x93A0: 0x8569,
		    0x93A1: 0x85E4,
		    0x93A2: 0x8A0E,
		    0x93A3: 0x8B04,
		    0x93A4: 0x8C46,
		    0x93A5: 0x8E0F,
		    0x93A6: 0x9003,
		    0x93A7: 0x900F,
		    0x93A8: 0x9419,
		    0x93A9: 0x9676,
		    0x93AA: 0x982D,
		    0x93AB: 0x9A30,
		    0x93AC: 0x95D8,
		    0x93AD: 0x50CD,
		    0x93AE: 0x52D5,
		    0x93AF: 0x540C,
		    0x93B0: 0x5802,
		    0x93B1: 0x5C0E,
		    0x93B2: 0x61A7,
		    0x93B3: 0x649E,
		    0x93B4: 0x6D1E,
		    0x93B5: 0x77B3,
		    0x93B6: 0x7AE5,
		    0x93B7: 0x80F4,
		    0x93B8: 0x8404,
		    0x93B9: 0x9053,
		    0x93BA: 0x9285,
		    0x93BB: 0x5CE0,
		    0x93BC: 0x9D07,
		    0x93BD: 0x533F,
		    0x93BE: 0x5F97,
		    0x93BF: 0x5FB3,
		    0x93C0: 0x6D9C,
		    0x93C1: 0x7279,
		    0x93C2: 0x7763,
		    0x93C3: 0x79BF,
		    0x93C4: 0x7BE4,
		    0x93C5: 0x6BD2,
		    0x93C6: 0x72EC,
		    0x93C7: 0x8AAD,
		    0x93C8: 0x6803,
		    0x93C9: 0x6A61,
		    0x93CA: 0x51F8,
		    0x93CB: 0x7A81,
		    0x93CC: 0x6934,
		    0x93CD: 0x5C4A,
		    0x93CE: 0x9CF6,
		    0x93CF: 0x82EB,
		    0x93D0: 0x5BC5,
		    0x93D1: 0x9149,
		    0x93D2: 0x701E,
		    0x93D3: 0x5678,
		    0x93D4: 0x5C6F,
		    0x93D5: 0x60C7,
		    0x93D6: 0x6566,
		    0x93D7: 0x6C8C,
		    0x93D8: 0x8C5A,
		    0x93D9: 0x9041,
		    0x93DA: 0x9813,
		    0x93DB: 0x5451,
		    0x93DC: 0x66C7,
		    0x93DD: 0x920D,
		    0x93DE: 0x5948,
		    0x93DF: 0x90A3,
		    0x93E0: 0x5185,
		    0x93E1: 0x4E4D,
		    0x93E2: 0x51EA,
		    0x93E3: 0x8599,
		    0x93E4: 0x8B0E,
		    0x93E5: 0x7058,
		    0x93E6: 0x637A,
		    0x93E7: 0x934B,
		    0x93E8: 0x6962,
		    0x93E9: 0x99B4,
		    0x93EA: 0x7E04,
		    0x93EB: 0x7577,
		    0x93EC: 0x5357,
		    0x93ED: 0x6960,
		    0x93EE: 0x8EDF,
		    0x93EF: 0x96E3,
		    0x93F0: 0x6C5D,
		    0x93F1: 0x4E8C,
		    0x93F2: 0x5C3C,
		    0x93F3: 0x5F10,
		    0x93F4: 0x8FE9,
		    0x93F5: 0x5302,
		    0x93F6: 0x8CD1,
		    0x93F7: 0x8089,
		    0x93F8: 0x8679,
		    0x93F9: 0x5EFF,
		    0x93FA: 0x65E5,
		    0x93FB: 0x4E73,
		    0x93FC: 0x5165,
		    0x9440: 0x5982,
		    0x9441: 0x5C3F,
		    0x9442: 0x97EE,
		    0x9443: 0x4EFB,
		    0x9444: 0x598A,
		    0x9445: 0x5FCD,
		    0x9446: 0x8A8D,
		    0x9447: 0x6FE1,
		    0x9448: 0x79B0,
		    0x9449: 0x7962,
		    0x944A: 0x5BE7,
		    0x944B: 0x8471,
		    0x944C: 0x732B,
		    0x944D: 0x71B1,
		    0x944E: 0x5E74,
		    0x944F: 0x5FF5,
		    0x9450: 0x637B,
		    0x9451: 0x649A,
		    0x9452: 0x71C3,
		    0x9453: 0x7C98,
		    0x9454: 0x4E43,
		    0x9455: 0x5EFC,
		    0x9456: 0x4E4B,
		    0x9457: 0x57DC,
		    0x9458: 0x56A2,
		    0x9459: 0x60A9,
		    0x945A: 0x6FC3,
		    0x945B: 0x7D0D,
		    0x945C: 0x80FD,
		    0x945D: 0x8133,
		    0x945E: 0x81BF,
		    0x945F: 0x8FB2,
		    0x9460: 0x8997,
		    0x9461: 0x86A4,
		    0x9462: 0x5DF4,
		    0x9463: 0x628A,
		    0x9464: 0x64AD,
		    0x9465: 0x8987,
		    0x9466: 0x6777,
		    0x9467: 0x6CE2,
		    0x9468: 0x6D3E,
		    0x9469: 0x7436,
		    0x946A: 0x7834,
		    0x946B: 0x5A46,
		    0x946C: 0x7F75,
		    0x946D: 0x82AD,
		    0x946E: 0x99AC,
		    0x946F: 0x4FF3,
		    0x9470: 0x5EC3,
		    0x9471: 0x62DD,
		    0x9472: 0x6392,
		    0x9473: 0x6557,
		    0x9474: 0x676F,
		    0x9475: 0x76C3,
		    0x9476: 0x724C,
		    0x9477: 0x80CC,
		    0x9478: 0x80BA,
		    0x9479: 0x8F29,
		    0x947A: 0x914D,
		    0x947B: 0x500D,
		    0x947C: 0x57F9,
		    0x947D: 0x5A92,
		    0x947E: 0x6885,
		    0x9480: 0x6973,
		    0x9481: 0x7164,
		    0x9482: 0x72FD,
		    0x9483: 0x8CB7,
		    0x9484: 0x58F2,
		    0x9485: 0x8CE0,
		    0x9486: 0x966A,
		    0x9487: 0x9019,
		    0x9488: 0x877F,
		    0x9489: 0x79E4,
		    0x948A: 0x77E7,
		    0x948B: 0x8429,
		    0x948C: 0x4F2F,
		    0x948D: 0x5265,
		    0x948E: 0x535A,
		    0x948F: 0x62CD,
		    0x9490: 0x67CF,
		    0x9491: 0x6CCA,
		    0x9492: 0x767D,
		    0x9493: 0x7B94,
		    0x9494: 0x7C95,
		    0x9495: 0x8236,
		    0x9496: 0x8584,
		    0x9497: 0x8FEB,
		    0x9498: 0x66DD,
		    0x9499: 0x6F20,
		    0x949A: 0x7206,
		    0x949B: 0x7E1B,
		    0x949C: 0x83AB,
		    0x949D: 0x99C1,
		    0x949E: 0x9EA6,
		    0x949F: 0x51FD,
		    0x94A0: 0x7BB1,
		    0x94A1: 0x7872,
		    0x94A2: 0x7BB8,
		    0x94A3: 0x8087,
		    0x94A4: 0x7B48,
		    0x94A5: 0x6AE8,
		    0x94A6: 0x5E61,
		    0x94A7: 0x808C,
		    0x94A8: 0x7551,
		    0x94A9: 0x7560,
		    0x94AA: 0x516B,
		    0x94AB: 0x9262,
		    0x94AC: 0x6E8C,
		    0x94AD: 0x767A,
		    0x94AE: 0x9197,
		    0x94AF: 0x9AEA,
		    0x94B0: 0x4F10,
		    0x94B1: 0x7F70,
		    0x94B2: 0x629C,
		    0x94B3: 0x7B4F,
		    0x94B4: 0x95A5,
		    0x94B5: 0x9CE9,
		    0x94B6: 0x567A,
		    0x94B7: 0x5859,
		    0x94B8: 0x86E4,
		    0x94B9: 0x96BC,
		    0x94BA: 0x4F34,
		    0x94BB: 0x5224,
		    0x94BC: 0x534A,
		    0x94BD: 0x53CD,
		    0x94BE: 0x53DB,
		    0x94BF: 0x5E06,
		    0x94C0: 0x642C,
		    0x94C1: 0x6591,
		    0x94C2: 0x677F,
		    0x94C3: 0x6C3E,
		    0x94C4: 0x6C4E,
		    0x94C5: 0x7248,
		    0x94C6: 0x72AF,
		    0x94C7: 0x73ED,
		    0x94C8: 0x7554,
		    0x94C9: 0x7E41,
		    0x94CA: 0x822C,
		    0x94CB: 0x85E9,
		    0x94CC: 0x8CA9,
		    0x94CD: 0x7BC4,
		    0x94CE: 0x91C6,
		    0x94CF: 0x7169,
		    0x94D0: 0x9812,
		    0x94D1: 0x98EF,
		    0x94D2: 0x633D,
		    0x94D3: 0x6669,
		    0x94D4: 0x756A,
		    0x94D5: 0x76E4,
		    0x94D6: 0x78D0,
		    0x94D7: 0x8543,
		    0x94D8: 0x86EE,
		    0x94D9: 0x532A,
		    0x94DA: 0x5351,
		    0x94DB: 0x5426,
		    0x94DC: 0x5983,
		    0x94DD: 0x5E87,
		    0x94DE: 0x5F7C,
		    0x94DF: 0x60B2,
		    0x94E0: 0x6249,
		    0x94E1: 0x6279,
		    0x94E2: 0x62AB,
		    0x94E3: 0x6590,
		    0x94E4: 0x6BD4,
		    0x94E5: 0x6CCC,
		    0x94E6: 0x75B2,
		    0x94E7: 0x76AE,
		    0x94E8: 0x7891,
		    0x94E9: 0x79D8,
		    0x94EA: 0x7DCB,
		    0x94EB: 0x7F77,
		    0x94EC: 0x80A5,
		    0x94ED: 0x88AB,
		    0x94EE: 0x8AB9,
		    0x94EF: 0x8CBB,
		    0x94F0: 0x907F,
		    0x94F1: 0x975E,
		    0x94F2: 0x98DB,
		    0x94F3: 0x6A0B,
		    0x94F4: 0x7C38,
		    0x94F5: 0x5099,
		    0x94F6: 0x5C3E,
		    0x94F7: 0x5FAE,
		    0x94F8: 0x6787,
		    0x94F9: 0x6BD8,
		    0x94FA: 0x7435,
		    0x94FB: 0x7709,
		    0x94FC: 0x7F8E,
		    0x9540: 0x9F3B,
		    0x9541: 0x67CA,
		    0x9542: 0x7A17,
		    0x9543: 0x5339,
		    0x9544: 0x758B,
		    0x9545: 0x9AED,
		    0x9546: 0x5F66,
		    0x9547: 0x819D,
		    0x9548: 0x83F1,
		    0x9549: 0x8098,
		    0x954A: 0x5F3C,
		    0x954B: 0x5FC5,
		    0x954C: 0x7562,
		    0x954D: 0x7B46,
		    0x954E: 0x903C,
		    0x954F: 0x6867,
		    0x9550: 0x59EB,
		    0x9551: 0x5A9B,
		    0x9552: 0x7D10,
		    0x9553: 0x767E,
		    0x9554: 0x8B2C,
		    0x9555: 0x4FF5,
		    0x9556: 0x5F6A,
		    0x9557: 0x6A19,
		    0x9558: 0x6C37,
		    0x9559: 0x6F02,
		    0x955A: 0x74E2,
		    0x955B: 0x7968,
		    0x955C: 0x8868,
		    0x955D: 0x8A55,
		    0x955E: 0x8C79,
		    0x955F: 0x5EDF,
		    0x9560: 0x63CF,
		    0x9561: 0x75C5,
		    0x9562: 0x79D2,
		    0x9563: 0x82D7,
		    0x9564: 0x9328,
		    0x9565: 0x92F2,
		    0x9566: 0x849C,
		    0x9567: 0x86ED,
		    0x9568: 0x9C2D,
		    0x9569: 0x54C1,
		    0x956A: 0x5F6C,
		    0x956B: 0x658C,
		    0x956C: 0x6D5C,
		    0x956D: 0x7015,
		    0x956E: 0x8CA7,
		    0x956F: 0x8CD3,
		    0x9570: 0x983B,
		    0x9571: 0x654F,
		    0x9572: 0x74F6,
		    0x9573: 0x4E0D,
		    0x9574: 0x4ED8,
		    0x9575: 0x57E0,
		    0x9576: 0x592B,
		    0x9577: 0x5A66,
		    0x9578: 0x5BCC,
		    0x9579: 0x51A8,
		    0x957A: 0x5E03,
		    0x957B: 0x5E9C,
		    0x957C: 0x6016,
		    0x957D: 0x6276,
		    0x957E: 0x6577,
		    0x9580: 0x65A7,
		    0x9581: 0x666E,
		    0x9582: 0x6D6E,
		    0x9583: 0x7236,
		    0x9584: 0x7B26,
		    0x9585: 0x8150,
		    0x9586: 0x819A,
		    0x9587: 0x8299,
		    0x9588: 0x8B5C,
		    0x9589: 0x8CA0,
		    0x958A: 0x8CE6,
		    0x958B: 0x8D74,
		    0x958C: 0x961C,
		    0x958D: 0x9644,
		    0x958E: 0x4FAE,
		    0x958F: 0x64AB,
		    0x9590: 0x6B66,
		    0x9591: 0x821E,
		    0x9592: 0x8461,
		    0x9593: 0x856A,
		    0x9594: 0x90E8,
		    0x9595: 0x5C01,
		    0x9596: 0x6953,
		    0x9597: 0x98A8,
		    0x9598: 0x847A,
		    0x9599: 0x8557,
		    0x959A: 0x4F0F,
		    0x959B: 0x526F,
		    0x959C: 0x5FA9,
		    0x959D: 0x5E45,
		    0x959E: 0x670D,
		    0x959F: 0x798F,
		    0x95A0: 0x8179,
		    0x95A1: 0x8907,
		    0x95A2: 0x8986,
		    0x95A3: 0x6DF5,
		    0x95A4: 0x5F17,
		    0x95A5: 0x6255,
		    0x95A6: 0x6CB8,
		    0x95A7: 0x4ECF,
		    0x95A8: 0x7269,
		    0x95A9: 0x9B92,
		    0x95AA: 0x5206,
		    0x95AB: 0x543B,
		    0x95AC: 0x5674,
		    0x95AD: 0x58B3,
		    0x95AE: 0x61A4,
		    0x95AF: 0x626E,
		    0x95B0: 0x711A,
		    0x95B1: 0x596E,
		    0x95B2: 0x7C89,
		    0x95B3: 0x7CDE,
		    0x95B4: 0x7D1B,
		    0x95B5: 0x96F0,
		    0x95B6: 0x6587,
		    0x95B7: 0x805E,
		    0x95B8: 0x4E19,
		    0x95B9: 0x4F75,
		    0x95BA: 0x5175,
		    0x95BB: 0x5840,
		    0x95BC: 0x5E63,
		    0x95BD: 0x5E73,
		    0x95BE: 0x5F0A,
		    0x95BF: 0x67C4,
		    0x95C0: 0x4E26,
		    0x95C1: 0x853D,
		    0x95C2: 0x9589,
		    0x95C3: 0x965B,
		    0x95C4: 0x7C73,
		    0x95C5: 0x9801,
		    0x95C6: 0x50FB,
		    0x95C7: 0x58C1,
		    0x95C8: 0x7656,
		    0x95C9: 0x78A7,
		    0x95CA: 0x5225,
		    0x95CB: 0x77A5,
		    0x95CC: 0x8511,
		    0x95CD: 0x7B86,
		    0x95CE: 0x504F,
		    0x95CF: 0x5909,
		    0x95D0: 0x7247,
		    0x95D1: 0x7BC7,
		    0x95D2: 0x7DE8,
		    0x95D3: 0x8FBA,
		    0x95D4: 0x8FD4,
		    0x95D5: 0x904D,
		    0x95D6: 0x4FBF,
		    0x95D7: 0x52C9,
		    0x95D8: 0x5A29,
		    0x95D9: 0x5F01,
		    0x95DA: 0x97AD,
		    0x95DB: 0x4FDD,
		    0x95DC: 0x8217,
		    0x95DD: 0x92EA,
		    0x95DE: 0x5703,
		    0x95DF: 0x6355,
		    0x95E0: 0x6B69,
		    0x95E1: 0x752B,
		    0x95E2: 0x88DC,
		    0x95E3: 0x8F14,
		    0x95E4: 0x7A42,
		    0x95E5: 0x52DF,
		    0x95E6: 0x5893,
		    0x95E7: 0x6155,
		    0x95E8: 0x620A,
		    0x95E9: 0x66AE,
		    0x95EA: 0x6BCD,
		    0x95EB: 0x7C3F,
		    0x95EC: 0x83E9,
		    0x95ED: 0x5023,
		    0x95EE: 0x4FF8,
		    0x95EF: 0x5305,
		    0x95F0: 0x5446,
		    0x95F1: 0x5831,
		    0x95F2: 0x5949,
		    0x95F3: 0x5B9D,
		    0x95F4: 0x5CF0,
		    0x95F5: 0x5CEF,
		    0x95F6: 0x5D29,
		    0x95F7: 0x5E96,
		    0x95F8: 0x62B1,
		    0x95F9: 0x6367,
		    0x95FA: 0x653E,
		    0x95FB: 0x65B9,
		    0x95FC: 0x670B,
		    0x9640: 0x6CD5,
		    0x9641: 0x6CE1,
		    0x9642: 0x70F9,
		    0x9643: 0x7832,
		    0x9644: 0x7E2B,
		    0x9645: 0x80DE,
		    0x9646: 0x82B3,
		    0x9647: 0x840C,
		    0x9648: 0x84EC,
		    0x9649: 0x8702,
		    0x964A: 0x8912,
		    0x964B: 0x8A2A,
		    0x964C: 0x8C4A,
		    0x964D: 0x90A6,
		    0x964E: 0x92D2,
		    0x964F: 0x98FD,
		    0x9650: 0x9CF3,
		    0x9651: 0x9D6C,
		    0x9652: 0x4E4F,
		    0x9653: 0x4EA1,
		    0x9654: 0x508D,
		    0x9655: 0x5256,
		    0x9656: 0x574A,
		    0x9657: 0x59A8,
		    0x9658: 0x5E3D,
		    0x9659: 0x5FD8,
		    0x965A: 0x5FD9,
		    0x965B: 0x623F,
		    0x965C: 0x66B4,
		    0x965D: 0x671B,
		    0x965E: 0x67D0,
		    0x965F: 0x68D2,
		    0x9660: 0x5192,
		    0x9661: 0x7D21,
		    0x9662: 0x80AA,
		    0x9663: 0x81A8,
		    0x9664: 0x8B00,
		    0x9665: 0x8C8C,
		    0x9666: 0x8CBF,
		    0x9667: 0x927E,
		    0x9668: 0x9632,
		    0x9669: 0x5420,
		    0x966A: 0x982C,
		    0x966B: 0x5317,
		    0x966C: 0x50D5,
		    0x966D: 0x535C,
		    0x966E: 0x58A8,
		    0x966F: 0x64B2,
		    0x9670: 0x6734,
		    0x9671: 0x7267,
		    0x9672: 0x7766,
		    0x9673: 0x7A46,
		    0x9674: 0x91E6,
		    0x9675: 0x52C3,
		    0x9676: 0x6CA1,
		    0x9677: 0x6B86,
		    0x9678: 0x5800,
		    0x9679: 0x5E4C,
		    0x967A: 0x5954,
		    0x967B: 0x672C,
		    0x967C: 0x7FFB,
		    0x967D: 0x51E1,
		    0x967E: 0x76C6,
		    0x9680: 0x6469,
		    0x9681: 0x78E8,
		    0x9682: 0x9B54,
		    0x9683: 0x9EBB,
		    0x9684: 0x57CB,
		    0x9685: 0x59B9,
		    0x9686: 0x6627,
		    0x9687: 0x679A,
		    0x9688: 0x6BCE,
		    0x9689: 0x54E9,
		    0x968A: 0x69D9,
		    0x968B: 0x5E55,
		    0x968C: 0x819C,
		    0x968D: 0x6795,
		    0x968E: 0x9BAA,
		    0x968F: 0x67FE,
		    0x9690: 0x9C52,
		    0x9691: 0x685D,
		    0x9692: 0x4EA6,
		    0x9693: 0x4FE3,
		    0x9694: 0x53C8,
		    0x9695: 0x62B9,
		    0x9696: 0x672B,
		    0x9697: 0x6CAB,
		    0x9698: 0x8FC4,
		    0x9699: 0x4FAD,
		    0x969A: 0x7E6D,
		    0x969B: 0x9EBF,
		    0x969C: 0x4E07,
		    0x969D: 0x6162,
		    0x969E: 0x6E80,
		    0x969F: 0x6F2B,
		    0x96A0: 0x8513,
		    0x96A1: 0x5473,
		    0x96A2: 0x672A,
		    0x96A3: 0x9B45,
		    0x96A4: 0x5DF3,
		    0x96A5: 0x7B95,
		    0x96A6: 0x5CAC,
		    0x96A7: 0x5BC6,
		    0x96A8: 0x871C,
		    0x96A9: 0x6E4A,
		    0x96AA: 0x84D1,
		    0x96AB: 0x7A14,
		    0x96AC: 0x8108,
		    0x96AD: 0x5999,
		    0x96AE: 0x7C8D,
		    0x96AF: 0x6C11,
		    0x96B0: 0x7720,
		    0x96B1: 0x52D9,
		    0x96B2: 0x5922,
		    0x96B3: 0x7121,
		    0x96B4: 0x725F,
		    0x96B5: 0x77DB,
		    0x96B6: 0x9727,
		    0x96B7: 0x9D61,
		    0x96B8: 0x690B,
		    0x96B9: 0x5A7F,
		    0x96BA: 0x5A18,
		    0x96BB: 0x51A5,
		    0x96BC: 0x540D,
		    0x96BD: 0x547D,
		    0x96BE: 0x660E,
		    0x96BF: 0x76DF,
		    0x96C0: 0x8FF7,
		    0x96C1: 0x9298,
		    0x96C2: 0x9CF4,
		    0x96C3: 0x59EA,
		    0x96C4: 0x725D,
		    0x96C5: 0x6EC5,
		    0x96C6: 0x514D,
		    0x96C7: 0x68C9,
		    0x96C8: 0x7DBF,
		    0x96C9: 0x7DEC,
		    0x96CA: 0x9762,
		    0x96CB: 0x9EBA,
		    0x96CC: 0x6478,
		    0x96CD: 0x6A21,
		    0x96CE: 0x8302,
		    0x96CF: 0x5984,
		    0x96D0: 0x5B5F,
		    0x96D1: 0x6BDB,
		    0x96D2: 0x731B,
		    0x96D3: 0x76F2,
		    0x96D4: 0x7DB2,
		    0x96D5: 0x8017,
		    0x96D6: 0x8499,
		    0x96D7: 0x5132,
		    0x96D8: 0x6728,
		    0x96D9: 0x9ED9,
		    0x96DA: 0x76EE,
		    0x96DB: 0x6762,
		    0x96DC: 0x52FF,
		    0x96DD: 0x9905,
		    0x96DE: 0x5C24,
		    0x96DF: 0x623B,
		    0x96E0: 0x7C7E,
		    0x96E1: 0x8CB0,
		    0x96E2: 0x554F,
		    0x96E3: 0x60B6,
		    0x96E4: 0x7D0B,
		    0x96E5: 0x9580,
		    0x96E6: 0x5301,
		    0x96E7: 0x4E5F,
		    0x96E8: 0x51B6,
		    0x96E9: 0x591C,
		    0x96EA: 0x723A,
		    0x96EB: 0x8036,
		    0x96EC: 0x91CE,
		    0x96ED: 0x5F25,
		    0x96EE: 0x77E2,
		    0x96EF: 0x5384,
		    0x96F0: 0x5F79,
		    0x96F1: 0x7D04,
		    0x96F2: 0x85AC,
		    0x96F3: 0x8A33,
		    0x96F4: 0x8E8D,
		    0x96F5: 0x9756,
		    0x96F6: 0x67F3,
		    0x96F7: 0x85AE,
		    0x96F8: 0x9453,
		    0x96F9: 0x6109,
		    0x96FA: 0x6108,
		    0x96FB: 0x6CB9,
		    0x96FC: 0x7652,
		    0x9740: 0x8AED,
		    0x9741: 0x8F38,
		    0x9742: 0x552F,
		    0x9743: 0x4F51,
		    0x9744: 0x512A,
		    0x9745: 0x52C7,
		    0x9746: 0x53CB,
		    0x9747: 0x5BA5,
		    0x9748: 0x5E7D,
		    0x9749: 0x60A0,
		    0x974A: 0x6182,
		    0x974B: 0x63D6,
		    0x974C: 0x6709,
		    0x974D: 0x67DA,
		    0x974E: 0x6E67,
		    0x974F: 0x6D8C,
		    0x9750: 0x7336,
		    0x9751: 0x7337,
		    0x9752: 0x7531,
		    0x9753: 0x7950,
		    0x9754: 0x88D5,
		    0x9755: 0x8A98,
		    0x9756: 0x904A,
		    0x9757: 0x9091,
		    0x9758: 0x90F5,
		    0x9759: 0x96C4,
		    0x975A: 0x878D,
		    0x975B: 0x5915,
		    0x975C: 0x4E88,
		    0x975D: 0x4F59,
		    0x975E: 0x4E0E,
		    0x975F: 0x8A89,
		    0x9760: 0x8F3F,
		    0x9761: 0x9810,
		    0x9762: 0x50AD,
		    0x9763: 0x5E7C,
		    0x9764: 0x5996,
		    0x9765: 0x5BB9,
		    0x9766: 0x5EB8,
		    0x9767: 0x63DA,
		    0x9768: 0x63FA,
		    0x9769: 0x64C1,
		    0x976A: 0x66DC,
		    0x976B: 0x694A,
		    0x976C: 0x69D8,
		    0x976D: 0x6D0B,
		    0x976E: 0x6EB6,
		    0x976F: 0x7194,
		    0x9770: 0x7528,
		    0x9771: 0x7AAF,
		    0x9772: 0x7F8A,
		    0x9773: 0x8000,
		    0x9774: 0x8449,
		    0x9775: 0x84C9,
		    0x9776: 0x8981,
		    0x9777: 0x8B21,
		    0x9778: 0x8E0A,
		    0x9779: 0x9065,
		    0x977A: 0x967D,
		    0x977B: 0x990A,
		    0x977C: 0x617E,
		    0x977D: 0x6291,
		    0x977E: 0x6B32,
		    0x9780: 0x6C83,
		    0x9781: 0x6D74,
		    0x9782: 0x7FCC,
		    0x9783: 0x7FFC,
		    0x9784: 0x6DC0,
		    0x9785: 0x7F85,
		    0x9786: 0x87BA,
		    0x9787: 0x88F8,
		    0x9788: 0x6765,
		    0x9789: 0x83B1,
		    0x978A: 0x983C,
		    0x978B: 0x96F7,
		    0x978C: 0x6D1B,
		    0x978D: 0x7D61,
		    0x978E: 0x843D,
		    0x978F: 0x916A,
		    0x9790: 0x4E71,
		    0x9791: 0x5375,
		    0x9792: 0x5D50,
		    0x9793: 0x6B04,
		    0x9794: 0x6FEB,
		    0x9795: 0x85CD,
		    0x9796: 0x862D,
		    0x9797: 0x89A7,
		    0x9798: 0x5229,
		    0x9799: 0x540F,
		    0x979A: 0x5C65,
		    0x979B: 0x674E,
		    0x979C: 0x68A8,
		    0x979D: 0x7406,
		    0x979E: 0x7483,
		    0x979F: 0x75E2,
		    0x97A0: 0x88CF,
		    0x97A1: 0x88E1,
		    0x97A2: 0x91CC,
		    0x97A3: 0x96E2,
		    0x97A4: 0x9678,
		    0x97A5: 0x5F8B,
		    0x97A6: 0x7387,
		    0x97A7: 0x7ACB,
		    0x97A8: 0x844E,
		    0x97A9: 0x63A0,
		    0x97AA: 0x7565,
		    0x97AB: 0x5289,
		    0x97AC: 0x6D41,
		    0x97AD: 0x6E9C,
		    0x97AE: 0x7409,
		    0x97AF: 0x7559,
		    0x97B0: 0x786B,
		    0x97B1: 0x7C92,
		    0x97B2: 0x9686,
		    0x97B3: 0x7ADC,
		    0x97B4: 0x9F8D,
		    0x97B5: 0x4FB6,
		    0x97B6: 0x616E,
		    0x97B7: 0x65C5,
		    0x97B8: 0x865C,
		    0x97B9: 0x4E86,
		    0x97BA: 0x4EAE,
		    0x97BB: 0x50DA,
		    0x97BC: 0x4E21,
		    0x97BD: 0x51CC,
		    0x97BE: 0x5BEE,
		    0x97BF: 0x6599,
		    0x97C0: 0x6881,
		    0x97C1: 0x6DBC,
		    0x97C2: 0x731F,
		    0x97C3: 0x7642,
		    0x97C4: 0x77AD,
		    0x97C5: 0x7A1C,
		    0x97C6: 0x7CE7,
		    0x97C7: 0x826F,
		    0x97C8: 0x8AD2,
		    0x97C9: 0x907C,
		    0x97CA: 0x91CF,
		    0x97CB: 0x9675,
		    0x97CC: 0x9818,
		    0x97CD: 0x529B,
		    0x97CE: 0x7DD1,
		    0x97CF: 0x502B,
		    0x97D0: 0x5398,
		    0x97D1: 0x6797,
		    0x97D2: 0x6DCB,
		    0x97D3: 0x71D0,
		    0x97D4: 0x7433,
		    0x97D5: 0x81E8,
		    0x97D6: 0x8F2A,
		    0x97D7: 0x96A3,
		    0x97D8: 0x9C57,
		    0x97D9: 0x9E9F,
		    0x97DA: 0x7460,
		    0x97DB: 0x5841,
		    0x97DC: 0x6D99,
		    0x97DD: 0x7D2F,
		    0x97DE: 0x985E,
		    0x97DF: 0x4EE4,
		    0x97E0: 0x4F36,
		    0x97E1: 0x4F8B,
		    0x97E2: 0x51B7,
		    0x97E3: 0x52B1,
		    0x97E4: 0x5DBA,
		    0x97E5: 0x601C,
		    0x97E6: 0x73B2,
		    0x97E7: 0x793C,
		    0x97E8: 0x82D3,
		    0x97E9: 0x9234,
		    0x97EA: 0x96B7,
		    0x97EB: 0x96F6,
		    0x97EC: 0x970A,
		    0x97ED: 0x9E97,
		    0x97EE: 0x9F62,
		    0x97EF: 0x66A6,
		    0x97F0: 0x6B74,
		    0x97F1: 0x5217,
		    0x97F2: 0x52A3,
		    0x97F3: 0x70C8,
		    0x97F4: 0x88C2,
		    0x97F5: 0x5EC9,
		    0x97F6: 0x604B,
		    0x97F7: 0x6190,
		    0x97F8: 0x6F23,
		    0x97F9: 0x7149,
		    0x97FA: 0x7C3E,
		    0x97FB: 0x7DF4,
		    0x97FC: 0x806F,
		    0x9840: 0x84EE,
		    0x9841: 0x9023,
		    0x9842: 0x932C,
		    0x9843: 0x5442,
		    0x9844: 0x9B6F,
		    0x9845: 0x6AD3,
		    0x9846: 0x7089,
		    0x9847: 0x8CC2,
		    0x9848: 0x8DEF,
		    0x9849: 0x9732,
		    0x984A: 0x52B4,
		    0x984B: 0x5A41,
		    0x984C: 0x5ECA,
		    0x984D: 0x5F04,
		    0x984E: 0x6717,
		    0x984F: 0x697C,
		    0x9850: 0x6994,
		    0x9851: 0x6D6A,
		    0x9852: 0x6F0F,
		    0x9853: 0x7262,
		    0x9854: 0x72FC,
		    0x9855: 0x7BED,
		    0x9856: 0x8001,
		    0x9857: 0x807E,
		    0x9858: 0x874B,
		    0x9859: 0x90CE,
		    0x985A: 0x516D,
		    0x985B: 0x9E93,
		    0x985C: 0x7984,
		    0x985D: 0x808B,
		    0x985E: 0x9332,
		    0x985F: 0x8AD6,
		    0x9860: 0x502D,
		    0x9861: 0x548C,
		    0x9862: 0x8A71,
		    0x9863: 0x6B6A,
		    0x9864: 0x8CC4,
		    0x9865: 0x8107,
		    0x9866: 0x60D1,
		    0x9867: 0x67A0,
		    0x9868: 0x9DF2,
		    0x9869: 0x4E99,
		    0x986A: 0x4E98,
		    0x986B: 0x9C10,
		    0x986C: 0x8A6B,
		    0x986D: 0x85C1,
		    0x986E: 0x8568,
		    0x986F: 0x6900,
		    0x9870: 0x6E7E,
		    0x9871: 0x7897,
		    0x9872: 0x8155,
		    0x989F: 0x5F0C,
		    0x98A0: 0x4E10,
		    0x98A1: 0x4E15,
		    0x98A2: 0x4E2A,
		    0x98A3: 0x4E31,
		    0x98A4: 0x4E36,
		    0x98A5: 0x4E3C,
		    0x98A6: 0x4E3F,
		    0x98A7: 0x4E42,
		    0x98A8: 0x4E56,
		    0x98A9: 0x4E58,
		    0x98AA: 0x4E82,
		    0x98AB: 0x4E85,
		    0x98AC: 0x8C6B,
		    0x98AD: 0x4E8A,
		    0x98AE: 0x8212,
		    0x98AF: 0x5F0D,
		    0x98B0: 0x4E8E,
		    0x98B1: 0x4E9E,
		    0x98B2: 0x4E9F,
		    0x98B3: 0x4EA0,
		    0x98B4: 0x4EA2,
		    0x98B5: 0x4EB0,
		    0x98B6: 0x4EB3,
		    0x98B7: 0x4EB6,
		    0x98B8: 0x4ECE,
		    0x98B9: 0x4ECD,
		    0x98BA: 0x4EC4,
		    0x98BB: 0x4EC6,
		    0x98BC: 0x4EC2,
		    0x98BD: 0x4ED7,
		    0x98BE: 0x4EDE,
		    0x98BF: 0x4EED,
		    0x98C0: 0x4EDF,
		    0x98C1: 0x4EF7,
		    0x98C2: 0x4F09,
		    0x98C3: 0x4F5A,
		    0x98C4: 0x4F30,
		    0x98C5: 0x4F5B,
		    0x98C6: 0x4F5D,
		    0x98C7: 0x4F57,
		    0x98C8: 0x4F47,
		    0x98C9: 0x4F76,
		    0x98CA: 0x4F88,
		    0x98CB: 0x4F8F,
		    0x98CC: 0x4F98,
		    0x98CD: 0x4F7B,
		    0x98CE: 0x4F69,
		    0x98CF: 0x4F70,
		    0x98D0: 0x4F91,
		    0x98D1: 0x4F6F,
		    0x98D2: 0x4F86,
		    0x98D3: 0x4F96,
		    0x98D4: 0x5118,
		    0x98D5: 0x4FD4,
		    0x98D6: 0x4FDF,
		    0x98D7: 0x4FCE,
		    0x98D8: 0x4FD8,
		    0x98D9: 0x4FDB,
		    0x98DA: 0x4FD1,
		    0x98DB: 0x4FDA,
		    0x98DC: 0x4FD0,
		    0x98DD: 0x4FE4,
		    0x98DE: 0x4FE5,
		    0x98DF: 0x501A,
		    0x98E0: 0x5028,
		    0x98E1: 0x5014,
		    0x98E2: 0x502A,
		    0x98E3: 0x5025,
		    0x98E4: 0x5005,
		    0x98E5: 0x4F1C,
		    0x98E6: 0x4FF6,
		    0x98E7: 0x5021,
		    0x98E8: 0x5029,
		    0x98E9: 0x502C,
		    0x98EA: 0x4FFE,
		    0x98EB: 0x4FEF,
		    0x98EC: 0x5011,
		    0x98ED: 0x5006,
		    0x98EE: 0x5043,
		    0x98EF: 0x5047,
		    0x98F0: 0x6703,
		    0x98F1: 0x5055,
		    0x98F2: 0x5050,
		    0x98F3: 0x5048,
		    0x98F4: 0x505A,
		    0x98F5: 0x5056,
		    0x98F6: 0x506C,
		    0x98F7: 0x5078,
		    0x98F8: 0x5080,
		    0x98F9: 0x509A,
		    0x98FA: 0x5085,
		    0x98FB: 0x50B4,
		    0x98FC: 0x50B2,
		    0x9940: 0x50C9,
		    0x9941: 0x50CA,
		    0x9942: 0x50B3,
		    0x9943: 0x50C2,
		    0x9944: 0x50D6,
		    0x9945: 0x50DE,
		    0x9946: 0x50E5,
		    0x9947: 0x50ED,
		    0x9948: 0x50E3,
		    0x9949: 0x50EE,
		    0x994A: 0x50F9,
		    0x994B: 0x50F5,
		    0x994C: 0x5109,
		    0x994D: 0x5101,
		    0x994E: 0x5102,
		    0x994F: 0x5116,
		    0x9950: 0x5115,
		    0x9951: 0x5114,
		    0x9952: 0x511A,
		    0x9953: 0x5121,
		    0x9954: 0x513A,
		    0x9955: 0x5137,
		    0x9956: 0x513C,
		    0x9957: 0x513B,
		    0x9958: 0x513F,
		    0x9959: 0x5140,
		    0x995A: 0x5152,
		    0x995B: 0x514C,
		    0x995C: 0x5154,
		    0x995D: 0x5162,
		    0x995E: 0x7AF8,
		    0x995F: 0x5169,
		    0x9960: 0x516A,
		    0x9961: 0x516E,
		    0x9962: 0x5180,
		    0x9963: 0x5182,
		    0x9964: 0x56D8,
		    0x9965: 0x518C,
		    0x9966: 0x5189,
		    0x9967: 0x518F,
		    0x9968: 0x5191,
		    0x9969: 0x5193,
		    0x996A: 0x5195,
		    0x996B: 0x5196,
		    0x996C: 0x51A4,
		    0x996D: 0x51A6,
		    0x996E: 0x51A2,
		    0x996F: 0x51A9,
		    0x9970: 0x51AA,
		    0x9971: 0x51AB,
		    0x9972: 0x51B3,
		    0x9973: 0x51B1,
		    0x9974: 0x51B2,
		    0x9975: 0x51B0,
		    0x9976: 0x51B5,
		    0x9977: 0x51BD,
		    0x9978: 0x51C5,
		    0x9979: 0x51C9,
		    0x997A: 0x51DB,
		    0x997B: 0x51E0,
		    0x997C: 0x8655,
		    0x997D: 0x51E9,
		    0x997E: 0x51ED,
		    0x9980: 0x51F0,
		    0x9981: 0x51F5,
		    0x9982: 0x51FE,
		    0x9983: 0x5204,
		    0x9984: 0x520B,
		    0x9985: 0x5214,
		    0x9986: 0x520E,
		    0x9987: 0x5227,
		    0x9988: 0x522A,
		    0x9989: 0x522E,
		    0x998A: 0x5233,
		    0x998B: 0x5239,
		    0x998C: 0x524F,
		    0x998D: 0x5244,
		    0x998E: 0x524B,
		    0x998F: 0x524C,
		    0x9990: 0x525E,
		    0x9991: 0x5254,
		    0x9992: 0x526A,
		    0x9993: 0x5274,
		    0x9994: 0x5269,
		    0x9995: 0x5273,
		    0x9996: 0x527F,
		    0x9997: 0x527D,
		    0x9998: 0x528D,
		    0x9999: 0x5294,
		    0x999A: 0x5292,
		    0x999B: 0x5271,
		    0x999C: 0x5288,
		    0x999D: 0x5291,
		    0x999E: 0x8FA8,
		    0x999F: 0x8FA7,
		    0x99A0: 0x52AC,
		    0x99A1: 0x52AD,
		    0x99A2: 0x52BC,
		    0x99A3: 0x52B5,
		    0x99A4: 0x52C1,
		    0x99A5: 0x52CD,
		    0x99A6: 0x52D7,
		    0x99A7: 0x52DE,
		    0x99A8: 0x52E3,
		    0x99A9: 0x52E6,
		    0x99AA: 0x98ED,
		    0x99AB: 0x52E0,
		    0x99AC: 0x52F3,
		    0x99AD: 0x52F5,
		    0x99AE: 0x52F8,
		    0x99AF: 0x52F9,
		    0x99B0: 0x5306,
		    0x99B1: 0x5308,
		    0x99B2: 0x7538,
		    0x99B3: 0x530D,
		    0x99B4: 0x5310,
		    0x99B5: 0x530F,
		    0x99B6: 0x5315,
		    0x99B7: 0x531A,
		    0x99B8: 0x5323,
		    0x99B9: 0x532F,
		    0x99BA: 0x5331,
		    0x99BB: 0x5333,
		    0x99BC: 0x5338,
		    0x99BD: 0x5340,
		    0x99BE: 0x5346,
		    0x99BF: 0x5345,
		    0x99C0: 0x4E17,
		    0x99C1: 0x5349,
		    0x99C2: 0x534D,
		    0x99C3: 0x51D6,
		    0x99C4: 0x535E,
		    0x99C5: 0x5369,
		    0x99C6: 0x536E,
		    0x99C7: 0x5918,
		    0x99C8: 0x537B,
		    0x99C9: 0x5377,
		    0x99CA: 0x5382,
		    0x99CB: 0x5396,
		    0x99CC: 0x53A0,
		    0x99CD: 0x53A6,
		    0x99CE: 0x53A5,
		    0x99CF: 0x53AE,
		    0x99D0: 0x53B0,
		    0x99D1: 0x53B6,
		    0x99D2: 0x53C3,
		    0x99D3: 0x7C12,
		    0x99D4: 0x96D9,
		    0x99D5: 0x53DF,
		    0x99D6: 0x66FC,
		    0x99D7: 0x71EE,
		    0x99D8: 0x53EE,
		    0x99D9: 0x53E8,
		    0x99DA: 0x53ED,
		    0x99DB: 0x53FA,
		    0x99DC: 0x5401,
		    0x99DD: 0x543D,
		    0x99DE: 0x5440,
		    0x99DF: 0x542C,
		    0x99E0: 0x542D,
		    0x99E1: 0x543C,
		    0x99E2: 0x542E,
		    0x99E3: 0x5436,
		    0x99E4: 0x5429,
		    0x99E5: 0x541D,
		    0x99E6: 0x544E,
		    0x99E7: 0x548F,
		    0x99E8: 0x5475,
		    0x99E9: 0x548E,
		    0x99EA: 0x545F,
		    0x99EB: 0x5471,
		    0x99EC: 0x5477,
		    0x99ED: 0x5470,
		    0x99EE: 0x5492,
		    0x99EF: 0x547B,
		    0x99F0: 0x5480,
		    0x99F1: 0x5476,
		    0x99F2: 0x5484,
		    0x99F3: 0x5490,
		    0x99F4: 0x5486,
		    0x99F5: 0x54C7,
		    0x99F6: 0x54A2,
		    0x99F7: 0x54B8,
		    0x99F8: 0x54A5,
		    0x99F9: 0x54AC,
		    0x99FA: 0x54C4,
		    0x99FB: 0x54C8,
		    0x99FC: 0x54A8,
		    0x9A40: 0x54AB,
		    0x9A41: 0x54C2,
		    0x9A42: 0x54A4,
		    0x9A43: 0x54BE,
		    0x9A44: 0x54BC,
		    0x9A45: 0x54D8,
		    0x9A46: 0x54E5,
		    0x9A47: 0x54E6,
		    0x9A48: 0x550F,
		    0x9A49: 0x5514,
		    0x9A4A: 0x54FD,
		    0x9A4B: 0x54EE,
		    0x9A4C: 0x54ED,
		    0x9A4D: 0x54FA,
		    0x9A4E: 0x54E2,
		    0x9A4F: 0x5539,
		    0x9A50: 0x5540,
		    0x9A51: 0x5563,
		    0x9A52: 0x554C,
		    0x9A53: 0x552E,
		    0x9A54: 0x555C,
		    0x9A55: 0x5545,
		    0x9A56: 0x5556,
		    0x9A57: 0x5557,
		    0x9A58: 0x5538,
		    0x9A59: 0x5533,
		    0x9A5A: 0x555D,
		    0x9A5B: 0x5599,
		    0x9A5C: 0x5580,
		    0x9A5D: 0x54AF,
		    0x9A5E: 0x558A,
		    0x9A5F: 0x559F,
		    0x9A60: 0x557B,
		    0x9A61: 0x557E,
		    0x9A62: 0x5598,
		    0x9A63: 0x559E,
		    0x9A64: 0x55AE,
		    0x9A65: 0x557C,
		    0x9A66: 0x5583,
		    0x9A67: 0x55A9,
		    0x9A68: 0x5587,
		    0x9A69: 0x55A8,
		    0x9A6A: 0x55DA,
		    0x9A6B: 0x55C5,
		    0x9A6C: 0x55DF,
		    0x9A6D: 0x55C4,
		    0x9A6E: 0x55DC,
		    0x9A6F: 0x55E4,
		    0x9A70: 0x55D4,
		    0x9A71: 0x5614,
		    0x9A72: 0x55F7,
		    0x9A73: 0x5616,
		    0x9A74: 0x55FE,
		    0x9A75: 0x55FD,
		    0x9A76: 0x561B,
		    0x9A77: 0x55F9,
		    0x9A78: 0x564E,
		    0x9A79: 0x5650,
		    0x9A7A: 0x71DF,
		    0x9A7B: 0x5634,
		    0x9A7C: 0x5636,
		    0x9A7D: 0x5632,
		    0x9A7E: 0x5638,
		    0x9A80: 0x566B,
		    0x9A81: 0x5664,
		    0x9A82: 0x562F,
		    0x9A83: 0x566C,
		    0x9A84: 0x566A,
		    0x9A85: 0x5686,
		    0x9A86: 0x5680,
		    0x9A87: 0x568A,
		    0x9A88: 0x56A0,
		    0x9A89: 0x5694,
		    0x9A8A: 0x568F,
		    0x9A8B: 0x56A5,
		    0x9A8C: 0x56AE,
		    0x9A8D: 0x56B6,
		    0x9A8E: 0x56B4,
		    0x9A8F: 0x56C2,
		    0x9A90: 0x56BC,
		    0x9A91: 0x56C1,
		    0x9A92: 0x56C3,
		    0x9A93: 0x56C0,
		    0x9A94: 0x56C8,
		    0x9A95: 0x56CE,
		    0x9A96: 0x56D1,
		    0x9A97: 0x56D3,
		    0x9A98: 0x56D7,
		    0x9A99: 0x56EE,
		    0x9A9A: 0x56F9,
		    0x9A9B: 0x5700,
		    0x9A9C: 0x56FF,
		    0x9A9D: 0x5704,
		    0x9A9E: 0x5709,
		    0x9A9F: 0x5708,
		    0x9AA0: 0x570B,
		    0x9AA1: 0x570D,
		    0x9AA2: 0x5713,
		    0x9AA3: 0x5718,
		    0x9AA4: 0x5716,
		    0x9AA5: 0x55C7,
		    0x9AA6: 0x571C,
		    0x9AA7: 0x5726,
		    0x9AA8: 0x5737,
		    0x9AA9: 0x5738,
		    0x9AAA: 0x574E,
		    0x9AAB: 0x573B,
		    0x9AAC: 0x5740,
		    0x9AAD: 0x574F,
		    0x9AAE: 0x5769,
		    0x9AAF: 0x57C0,
		    0x9AB0: 0x5788,
		    0x9AB1: 0x5761,
		    0x9AB2: 0x577F,
		    0x9AB3: 0x5789,
		    0x9AB4: 0x5793,
		    0x9AB5: 0x57A0,
		    0x9AB6: 0x57B3,
		    0x9AB7: 0x57A4,
		    0x9AB8: 0x57AA,
		    0x9AB9: 0x57B0,
		    0x9ABA: 0x57C3,
		    0x9ABB: 0x57C6,
		    0x9ABC: 0x57D4,
		    0x9ABD: 0x57D2,
		    0x9ABE: 0x57D3,
		    0x9ABF: 0x580A,
		    0x9AC0: 0x57D6,
		    0x9AC1: 0x57E3,
		    0x9AC2: 0x580B,
		    0x9AC3: 0x5819,
		    0x9AC4: 0x581D,
		    0x9AC5: 0x5872,
		    0x9AC6: 0x5821,
		    0x9AC7: 0x5862,
		    0x9AC8: 0x584B,
		    0x9AC9: 0x5870,
		    0x9ACA: 0x6BC0,
		    0x9ACB: 0x5852,
		    0x9ACC: 0x583D,
		    0x9ACD: 0x5879,
		    0x9ACE: 0x5885,
		    0x9ACF: 0x58B9,
		    0x9AD0: 0x589F,
		    0x9AD1: 0x58AB,
		    0x9AD2: 0x58BA,
		    0x9AD3: 0x58DE,
		    0x9AD4: 0x58BB,
		    0x9AD5: 0x58B8,
		    0x9AD6: 0x58AE,
		    0x9AD7: 0x58C5,
		    0x9AD8: 0x58D3,
		    0x9AD9: 0x58D1,
		    0x9ADA: 0x58D7,
		    0x9ADB: 0x58D9,
		    0x9ADC: 0x58D8,
		    0x9ADD: 0x58E5,
		    0x9ADE: 0x58DC,
		    0x9ADF: 0x58E4,
		    0x9AE0: 0x58DF,
		    0x9AE1: 0x58EF,
		    0x9AE2: 0x58FA,
		    0x9AE3: 0x58F9,
		    0x9AE4: 0x58FB,
		    0x9AE5: 0x58FC,
		    0x9AE6: 0x58FD,
		    0x9AE7: 0x5902,
		    0x9AE8: 0x590A,
		    0x9AE9: 0x5910,
		    0x9AEA: 0x591B,
		    0x9AEB: 0x68A6,
		    0x9AEC: 0x5925,
		    0x9AED: 0x592C,
		    0x9AEE: 0x592D,
		    0x9AEF: 0x5932,
		    0x9AF0: 0x5938,
		    0x9AF1: 0x593E,
		    0x9AF2: 0x7AD2,
		    0x9AF3: 0x5955,
		    0x9AF4: 0x5950,
		    0x9AF5: 0x594E,
		    0x9AF6: 0x595A,
		    0x9AF7: 0x5958,
		    0x9AF8: 0x5962,
		    0x9AF9: 0x5960,
		    0x9AFA: 0x5967,
		    0x9AFB: 0x596C,
		    0x9AFC: 0x5969,
		    0x9B40: 0x5978,
		    0x9B41: 0x5981,
		    0x9B42: 0x599D,
		    0x9B43: 0x4F5E,
		    0x9B44: 0x4FAB,
		    0x9B45: 0x59A3,
		    0x9B46: 0x59B2,
		    0x9B47: 0x59C6,
		    0x9B48: 0x59E8,
		    0x9B49: 0x59DC,
		    0x9B4A: 0x598D,
		    0x9B4B: 0x59D9,
		    0x9B4C: 0x59DA,
		    0x9B4D: 0x5A25,
		    0x9B4E: 0x5A1F,
		    0x9B4F: 0x5A11,
		    0x9B50: 0x5A1C,
		    0x9B51: 0x5A09,
		    0x9B52: 0x5A1A,
		    0x9B53: 0x5A40,
		    0x9B54: 0x5A6C,
		    0x9B55: 0x5A49,
		    0x9B56: 0x5A35,
		    0x9B57: 0x5A36,
		    0x9B58: 0x5A62,
		    0x9B59: 0x5A6A,
		    0x9B5A: 0x5A9A,
		    0x9B5B: 0x5ABC,
		    0x9B5C: 0x5ABE,
		    0x9B5D: 0x5ACB,
		    0x9B5E: 0x5AC2,
		    0x9B5F: 0x5ABD,
		    0x9B60: 0x5AE3,
		    0x9B61: 0x5AD7,
		    0x9B62: 0x5AE6,
		    0x9B63: 0x5AE9,
		    0x9B64: 0x5AD6,
		    0x9B65: 0x5AFA,
		    0x9B66: 0x5AFB,
		    0x9B67: 0x5B0C,
		    0x9B68: 0x5B0B,
		    0x9B69: 0x5B16,
		    0x9B6A: 0x5B32,
		    0x9B6B: 0x5AD0,
		    0x9B6C: 0x5B2A,
		    0x9B6D: 0x5B36,
		    0x9B6E: 0x5B3E,
		    0x9B6F: 0x5B43,
		    0x9B70: 0x5B45,
		    0x9B71: 0x5B40,
		    0x9B72: 0x5B51,
		    0x9B73: 0x5B55,
		    0x9B74: 0x5B5A,
		    0x9B75: 0x5B5B,
		    0x9B76: 0x5B65,
		    0x9B77: 0x5B69,
		    0x9B78: 0x5B70,
		    0x9B79: 0x5B73,
		    0x9B7A: 0x5B75,
		    0x9B7B: 0x5B78,
		    0x9B7C: 0x6588,
		    0x9B7D: 0x5B7A,
		    0x9B7E: 0x5B80,
		    0x9B80: 0x5B83,
		    0x9B81: 0x5BA6,
		    0x9B82: 0x5BB8,
		    0x9B83: 0x5BC3,
		    0x9B84: 0x5BC7,
		    0x9B85: 0x5BC9,
		    0x9B86: 0x5BD4,
		    0x9B87: 0x5BD0,
		    0x9B88: 0x5BE4,
		    0x9B89: 0x5BE6,
		    0x9B8A: 0x5BE2,
		    0x9B8B: 0x5BDE,
		    0x9B8C: 0x5BE5,
		    0x9B8D: 0x5BEB,
		    0x9B8E: 0x5BF0,
		    0x9B8F: 0x5BF6,
		    0x9B90: 0x5BF3,
		    0x9B91: 0x5C05,
		    0x9B92: 0x5C07,
		    0x9B93: 0x5C08,
		    0x9B94: 0x5C0D,
		    0x9B95: 0x5C13,
		    0x9B96: 0x5C20,
		    0x9B97: 0x5C22,
		    0x9B98: 0x5C28,
		    0x9B99: 0x5C38,
		    0x9B9A: 0x5C39,
		    0x9B9B: 0x5C41,
		    0x9B9C: 0x5C46,
		    0x9B9D: 0x5C4E,
		    0x9B9E: 0x5C53,
		    0x9B9F: 0x5C50,
		    0x9BA0: 0x5C4F,
		    0x9BA1: 0x5B71,
		    0x9BA2: 0x5C6C,
		    0x9BA3: 0x5C6E,
		    0x9BA4: 0x4E62,
		    0x9BA5: 0x5C76,
		    0x9BA6: 0x5C79,
		    0x9BA7: 0x5C8C,
		    0x9BA8: 0x5C91,
		    0x9BA9: 0x5C94,
		    0x9BAA: 0x599B,
		    0x9BAB: 0x5CAB,
		    0x9BAC: 0x5CBB,
		    0x9BAD: 0x5CB6,
		    0x9BAE: 0x5CBC,
		    0x9BAF: 0x5CB7,
		    0x9BB0: 0x5CC5,
		    0x9BB1: 0x5CBE,
		    0x9BB2: 0x5CC7,
		    0x9BB3: 0x5CD9,
		    0x9BB4: 0x5CE9,
		    0x9BB5: 0x5CFD,
		    0x9BB6: 0x5CFA,
		    0x9BB7: 0x5CED,
		    0x9BB8: 0x5D8C,
		    0x9BB9: 0x5CEA,
		    0x9BBA: 0x5D0B,
		    0x9BBB: 0x5D15,
		    0x9BBC: 0x5D17,
		    0x9BBD: 0x5D5C,
		    0x9BBE: 0x5D1F,
		    0x9BBF: 0x5D1B,
		    0x9BC0: 0x5D11,
		    0x9BC1: 0x5D14,
		    0x9BC2: 0x5D22,
		    0x9BC3: 0x5D1A,
		    0x9BC4: 0x5D19,
		    0x9BC5: 0x5D18,
		    0x9BC6: 0x5D4C,
		    0x9BC7: 0x5D52,
		    0x9BC8: 0x5D4E,
		    0x9BC9: 0x5D4B,
		    0x9BCA: 0x5D6C,
		    0x9BCB: 0x5D73,
		    0x9BCC: 0x5D76,
		    0x9BCD: 0x5D87,
		    0x9BCE: 0x5D84,
		    0x9BCF: 0x5D82,
		    0x9BD0: 0x5DA2,
		    0x9BD1: 0x5D9D,
		    0x9BD2: 0x5DAC,
		    0x9BD3: 0x5DAE,
		    0x9BD4: 0x5DBD,
		    0x9BD5: 0x5D90,
		    0x9BD6: 0x5DB7,
		    0x9BD7: 0x5DBC,
		    0x9BD8: 0x5DC9,
		    0x9BD9: 0x5DCD,
		    0x9BDA: 0x5DD3,
		    0x9BDB: 0x5DD2,
		    0x9BDC: 0x5DD6,
		    0x9BDD: 0x5DDB,
		    0x9BDE: 0x5DEB,
		    0x9BDF: 0x5DF2,
		    0x9BE0: 0x5DF5,
		    0x9BE1: 0x5E0B,
		    0x9BE2: 0x5E1A,
		    0x9BE3: 0x5E19,
		    0x9BE4: 0x5E11,
		    0x9BE5: 0x5E1B,
		    0x9BE6: 0x5E36,
		    0x9BE7: 0x5E37,
		    0x9BE8: 0x5E44,
		    0x9BE9: 0x5E43,
		    0x9BEA: 0x5E40,
		    0x9BEB: 0x5E4E,
		    0x9BEC: 0x5E57,
		    0x9BED: 0x5E54,
		    0x9BEE: 0x5E5F,
		    0x9BEF: 0x5E62,
		    0x9BF0: 0x5E64,
		    0x9BF1: 0x5E47,
		    0x9BF2: 0x5E75,
		    0x9BF3: 0x5E76,
		    0x9BF4: 0x5E7A,
		    0x9BF5: 0x9EBC,
		    0x9BF6: 0x5E7F,
		    0x9BF7: 0x5EA0,
		    0x9BF8: 0x5EC1,
		    0x9BF9: 0x5EC2,
		    0x9BFA: 0x5EC8,
		    0x9BFB: 0x5ED0,
		    0x9BFC: 0x5ECF,
		    0x9C40: 0x5ED6,
		    0x9C41: 0x5EE3,
		    0x9C42: 0x5EDD,
		    0x9C43: 0x5EDA,
		    0x9C44: 0x5EDB,
		    0x9C45: 0x5EE2,
		    0x9C46: 0x5EE1,
		    0x9C47: 0x5EE8,
		    0x9C48: 0x5EE9,
		    0x9C49: 0x5EEC,
		    0x9C4A: 0x5EF1,
		    0x9C4B: 0x5EF3,
		    0x9C4C: 0x5EF0,
		    0x9C4D: 0x5EF4,
		    0x9C4E: 0x5EF8,
		    0x9C4F: 0x5EFE,
		    0x9C50: 0x5F03,
		    0x9C51: 0x5F09,
		    0x9C52: 0x5F5D,
		    0x9C53: 0x5F5C,
		    0x9C54: 0x5F0B,
		    0x9C55: 0x5F11,
		    0x9C56: 0x5F16,
		    0x9C57: 0x5F29,
		    0x9C58: 0x5F2D,
		    0x9C59: 0x5F38,
		    0x9C5A: 0x5F41,
		    0x9C5B: 0x5F48,
		    0x9C5C: 0x5F4C,
		    0x9C5D: 0x5F4E,
		    0x9C5E: 0x5F2F,
		    0x9C5F: 0x5F51,
		    0x9C60: 0x5F56,
		    0x9C61: 0x5F57,
		    0x9C62: 0x5F59,
		    0x9C63: 0x5F61,
		    0x9C64: 0x5F6D,
		    0x9C65: 0x5F73,
		    0x9C66: 0x5F77,
		    0x9C67: 0x5F83,
		    0x9C68: 0x5F82,
		    0x9C69: 0x5F7F,
		    0x9C6A: 0x5F8A,
		    0x9C6B: 0x5F88,
		    0x9C6C: 0x5F91,
		    0x9C6D: 0x5F87,
		    0x9C6E: 0x5F9E,
		    0x9C6F: 0x5F99,
		    0x9C70: 0x5F98,
		    0x9C71: 0x5FA0,
		    0x9C72: 0x5FA8,
		    0x9C73: 0x5FAD,
		    0x9C74: 0x5FBC,
		    0x9C75: 0x5FD6,
		    0x9C76: 0x5FFB,
		    0x9C77: 0x5FE4,
		    0x9C78: 0x5FF8,
		    0x9C79: 0x5FF1,
		    0x9C7A: 0x5FDD,
		    0x9C7B: 0x60B3,
		    0x9C7C: 0x5FFF,
		    0x9C7D: 0x6021,
		    0x9C7E: 0x6060,
		    0x9C80: 0x6019,
		    0x9C81: 0x6010,
		    0x9C82: 0x6029,
		    0x9C83: 0x600E,
		    0x9C84: 0x6031,
		    0x9C85: 0x601B,
		    0x9C86: 0x6015,
		    0x9C87: 0x602B,
		    0x9C88: 0x6026,
		    0x9C89: 0x600F,
		    0x9C8A: 0x603A,
		    0x9C8B: 0x605A,
		    0x9C8C: 0x6041,
		    0x9C8D: 0x606A,
		    0x9C8E: 0x6077,
		    0x9C8F: 0x605F,
		    0x9C90: 0x604A,
		    0x9C91: 0x6046,
		    0x9C92: 0x604D,
		    0x9C93: 0x6063,
		    0x9C94: 0x6043,
		    0x9C95: 0x6064,
		    0x9C96: 0x6042,
		    0x9C97: 0x606C,
		    0x9C98: 0x606B,
		    0x9C99: 0x6059,
		    0x9C9A: 0x6081,
		    0x9C9B: 0x608D,
		    0x9C9C: 0x60E7,
		    0x9C9D: 0x6083,
		    0x9C9E: 0x609A,
		    0x9C9F: 0x6084,
		    0x9CA0: 0x609B,
		    0x9CA1: 0x6096,
		    0x9CA2: 0x6097,
		    0x9CA3: 0x6092,
		    0x9CA4: 0x60A7,
		    0x9CA5: 0x608B,
		    0x9CA6: 0x60E1,
		    0x9CA7: 0x60B8,
		    0x9CA8: 0x60E0,
		    0x9CA9: 0x60D3,
		    0x9CAA: 0x60B4,
		    0x9CAB: 0x5FF0,
		    0x9CAC: 0x60BD,
		    0x9CAD: 0x60C6,
		    0x9CAE: 0x60B5,
		    0x9CAF: 0x60D8,
		    0x9CB0: 0x614D,
		    0x9CB1: 0x6115,
		    0x9CB2: 0x6106,
		    0x9CB3: 0x60F6,
		    0x9CB4: 0x60F7,
		    0x9CB5: 0x6100,
		    0x9CB6: 0x60F4,
		    0x9CB7: 0x60FA,
		    0x9CB8: 0x6103,
		    0x9CB9: 0x6121,
		    0x9CBA: 0x60FB,
		    0x9CBB: 0x60F1,
		    0x9CBC: 0x610D,
		    0x9CBD: 0x610E,
		    0x9CBE: 0x6147,
		    0x9CBF: 0x613E,
		    0x9CC0: 0x6128,
		    0x9CC1: 0x6127,
		    0x9CC2: 0x614A,
		    0x9CC3: 0x613F,
		    0x9CC4: 0x613C,
		    0x9CC5: 0x612C,
		    0x9CC6: 0x6134,
		    0x9CC7: 0x613D,
		    0x9CC8: 0x6142,
		    0x9CC9: 0x6144,
		    0x9CCA: 0x6173,
		    0x9CCB: 0x6177,
		    0x9CCC: 0x6158,
		    0x9CCD: 0x6159,
		    0x9CCE: 0x615A,
		    0x9CCF: 0x616B,
		    0x9CD0: 0x6174,
		    0x9CD1: 0x616F,
		    0x9CD2: 0x6165,
		    0x9CD3: 0x6171,
		    0x9CD4: 0x615F,
		    0x9CD5: 0x615D,
		    0x9CD6: 0x6153,
		    0x9CD7: 0x6175,
		    0x9CD8: 0x6199,
		    0x9CD9: 0x6196,
		    0x9CDA: 0x6187,
		    0x9CDB: 0x61AC,
		    0x9CDC: 0x6194,
		    0x9CDD: 0x619A,
		    0x9CDE: 0x618A,
		    0x9CDF: 0x6191,
		    0x9CE0: 0x61AB,
		    0x9CE1: 0x61AE,
		    0x9CE2: 0x61CC,
		    0x9CE3: 0x61CA,
		    0x9CE4: 0x61C9,
		    0x9CE5: 0x61F7,
		    0x9CE6: 0x61C8,
		    0x9CE7: 0x61C3,
		    0x9CE8: 0x61C6,
		    0x9CE9: 0x61BA,
		    0x9CEA: 0x61CB,
		    0x9CEB: 0x7F79,
		    0x9CEC: 0x61CD,
		    0x9CED: 0x61E6,
		    0x9CEE: 0x61E3,
		    0x9CEF: 0x61F6,
		    0x9CF0: 0x61FA,
		    0x9CF1: 0x61F4,
		    0x9CF2: 0x61FF,
		    0x9CF3: 0x61FD,
		    0x9CF4: 0x61FC,
		    0x9CF5: 0x61FE,
		    0x9CF6: 0x6200,
		    0x9CF7: 0x6208,
		    0x9CF8: 0x6209,
		    0x9CF9: 0x620D,
		    0x9CFA: 0x620C,
		    0x9CFB: 0x6214,
		    0x9CFC: 0x621B,
		    0x9D40: 0x621E,
		    0x9D41: 0x6221,
		    0x9D42: 0x622A,
		    0x9D43: 0x622E,
		    0x9D44: 0x6230,
		    0x9D45: 0x6232,
		    0x9D46: 0x6233,
		    0x9D47: 0x6241,
		    0x9D48: 0x624E,
		    0x9D49: 0x625E,
		    0x9D4A: 0x6263,
		    0x9D4B: 0x625B,
		    0x9D4C: 0x6260,
		    0x9D4D: 0x6268,
		    0x9D4E: 0x627C,
		    0x9D4F: 0x6282,
		    0x9D50: 0x6289,
		    0x9D51: 0x627E,
		    0x9D52: 0x6292,
		    0x9D53: 0x6293,
		    0x9D54: 0x6296,
		    0x9D55: 0x62D4,
		    0x9D56: 0x6283,
		    0x9D57: 0x6294,
		    0x9D58: 0x62D7,
		    0x9D59: 0x62D1,
		    0x9D5A: 0x62BB,
		    0x9D5B: 0x62CF,
		    0x9D5C: 0x62FF,
		    0x9D5D: 0x62C6,
		    0x9D5E: 0x64D4,
		    0x9D5F: 0x62C8,
		    0x9D60: 0x62DC,
		    0x9D61: 0x62CC,
		    0x9D62: 0x62CA,
		    0x9D63: 0x62C2,
		    0x9D64: 0x62C7,
		    0x9D65: 0x629B,
		    0x9D66: 0x62C9,
		    0x9D67: 0x630C,
		    0x9D68: 0x62EE,
		    0x9D69: 0x62F1,
		    0x9D6A: 0x6327,
		    0x9D6B: 0x6302,
		    0x9D6C: 0x6308,
		    0x9D6D: 0x62EF,
		    0x9D6E: 0x62F5,
		    0x9D6F: 0x6350,
		    0x9D70: 0x633E,
		    0x9D71: 0x634D,
		    0x9D72: 0x641C,
		    0x9D73: 0x634F,
		    0x9D74: 0x6396,
		    0x9D75: 0x638E,
		    0x9D76: 0x6380,
		    0x9D77: 0x63AB,
		    0x9D78: 0x6376,
		    0x9D79: 0x63A3,
		    0x9D7A: 0x638F,
		    0x9D7B: 0x6389,
		    0x9D7C: 0x639F,
		    0x9D7D: 0x63B5,
		    0x9D7E: 0x636B,
		    0x9D80: 0x6369,
		    0x9D81: 0x63BE,
		    0x9D82: 0x63E9,
		    0x9D83: 0x63C0,
		    0x9D84: 0x63C6,
		    0x9D85: 0x63E3,
		    0x9D86: 0x63C9,
		    0x9D87: 0x63D2,
		    0x9D88: 0x63F6,
		    0x9D89: 0x63C4,
		    0x9D8A: 0x6416,
		    0x9D8B: 0x6434,
		    0x9D8C: 0x6406,
		    0x9D8D: 0x6413,
		    0x9D8E: 0x6426,
		    0x9D8F: 0x6436,
		    0x9D90: 0x651D,
		    0x9D91: 0x6417,
		    0x9D92: 0x6428,
		    0x9D93: 0x640F,
		    0x9D94: 0x6467,
		    0x9D95: 0x646F,
		    0x9D96: 0x6476,
		    0x9D97: 0x644E,
		    0x9D98: 0x652A,
		    0x9D99: 0x6495,
		    0x9D9A: 0x6493,
		    0x9D9B: 0x64A5,
		    0x9D9C: 0x64A9,
		    0x9D9D: 0x6488,
		    0x9D9E: 0x64BC,
		    0x9D9F: 0x64DA,
		    0x9DA0: 0x64D2,
		    0x9DA1: 0x64C5,
		    0x9DA2: 0x64C7,
		    0x9DA3: 0x64BB,
		    0x9DA4: 0x64D8,
		    0x9DA5: 0x64C2,
		    0x9DA6: 0x64F1,
		    0x9DA7: 0x64E7,
		    0x9DA8: 0x8209,
		    0x9DA9: 0x64E0,
		    0x9DAA: 0x64E1,
		    0x9DAB: 0x62AC,
		    0x9DAC: 0x64E3,
		    0x9DAD: 0x64EF,
		    0x9DAE: 0x652C,
		    0x9DAF: 0x64F6,
		    0x9DB0: 0x64F4,
		    0x9DB1: 0x64F2,
		    0x9DB2: 0x64FA,
		    0x9DB3: 0x6500,
		    0x9DB4: 0x64FD,
		    0x9DB5: 0x6518,
		    0x9DB6: 0x651C,
		    0x9DB7: 0x6505,
		    0x9DB8: 0x6524,
		    0x9DB9: 0x6523,
		    0x9DBA: 0x652B,
		    0x9DBB: 0x6534,
		    0x9DBC: 0x6535,
		    0x9DBD: 0x6537,
		    0x9DBE: 0x6536,
		    0x9DBF: 0x6538,
		    0x9DC0: 0x754B,
		    0x9DC1: 0x6548,
		    0x9DC2: 0x6556,
		    0x9DC3: 0x6555,
		    0x9DC4: 0x654D,
		    0x9DC5: 0x6558,
		    0x9DC6: 0x655E,
		    0x9DC7: 0x655D,
		    0x9DC8: 0x6572,
		    0x9DC9: 0x6578,
		    0x9DCA: 0x6582,
		    0x9DCB: 0x6583,
		    0x9DCC: 0x8B8A,
		    0x9DCD: 0x659B,
		    0x9DCE: 0x659F,
		    0x9DCF: 0x65AB,
		    0x9DD0: 0x65B7,
		    0x9DD1: 0x65C3,
		    0x9DD2: 0x65C6,
		    0x9DD3: 0x65C1,
		    0x9DD4: 0x65C4,
		    0x9DD5: 0x65CC,
		    0x9DD6: 0x65D2,
		    0x9DD7: 0x65DB,
		    0x9DD8: 0x65D9,
		    0x9DD9: 0x65E0,
		    0x9DDA: 0x65E1,
		    0x9DDB: 0x65F1,
		    0x9DDC: 0x6772,
		    0x9DDD: 0x660A,
		    0x9DDE: 0x6603,
		    0x9DDF: 0x65FB,
		    0x9DE0: 0x6773,
		    0x9DE1: 0x6635,
		    0x9DE2: 0x6636,
		    0x9DE3: 0x6634,
		    0x9DE4: 0x661C,
		    0x9DE5: 0x664F,
		    0x9DE6: 0x6644,
		    0x9DE7: 0x6649,
		    0x9DE8: 0x6641,
		    0x9DE9: 0x665E,
		    0x9DEA: 0x665D,
		    0x9DEB: 0x6664,
		    0x9DEC: 0x6667,
		    0x9DED: 0x6668,
		    0x9DEE: 0x665F,
		    0x9DEF: 0x6662,
		    0x9DF0: 0x6670,
		    0x9DF1: 0x6683,
		    0x9DF2: 0x6688,
		    0x9DF3: 0x668E,
		    0x9DF4: 0x6689,
		    0x9DF5: 0x6684,
		    0x9DF6: 0x6698,
		    0x9DF7: 0x669D,
		    0x9DF8: 0x66C1,
		    0x9DF9: 0x66B9,
		    0x9DFA: 0x66C9,
		    0x9DFB: 0x66BE,
		    0x9DFC: 0x66BC,
		    0x9E40: 0x66C4,
		    0x9E41: 0x66B8,
		    0x9E42: 0x66D6,
		    0x9E43: 0x66DA,
		    0x9E44: 0x66E0,
		    0x9E45: 0x663F,
		    0x9E46: 0x66E6,
		    0x9E47: 0x66E9,
		    0x9E48: 0x66F0,
		    0x9E49: 0x66F5,
		    0x9E4A: 0x66F7,
		    0x9E4B: 0x670F,
		    0x9E4C: 0x6716,
		    0x9E4D: 0x671E,
		    0x9E4E: 0x6726,
		    0x9E4F: 0x6727,
		    0x9E50: 0x9738,
		    0x9E51: 0x672E,
		    0x9E52: 0x673F,
		    0x9E53: 0x6736,
		    0x9E54: 0x6741,
		    0x9E55: 0x6738,
		    0x9E56: 0x6737,
		    0x9E57: 0x6746,
		    0x9E58: 0x675E,
		    0x9E59: 0x6760,
		    0x9E5A: 0x6759,
		    0x9E5B: 0x6763,
		    0x9E5C: 0x6764,
		    0x9E5D: 0x6789,
		    0x9E5E: 0x6770,
		    0x9E5F: 0x67A9,
		    0x9E60: 0x677C,
		    0x9E61: 0x676A,
		    0x9E62: 0x678C,
		    0x9E63: 0x678B,
		    0x9E64: 0x67A6,
		    0x9E65: 0x67A1,
		    0x9E66: 0x6785,
		    0x9E67: 0x67B7,
		    0x9E68: 0x67EF,
		    0x9E69: 0x67B4,
		    0x9E6A: 0x67EC,
		    0x9E6B: 0x67B3,
		    0x9E6C: 0x67E9,
		    0x9E6D: 0x67B8,
		    0x9E6E: 0x67E4,
		    0x9E6F: 0x67DE,
		    0x9E70: 0x67DD,
		    0x9E71: 0x67E2,
		    0x9E72: 0x67EE,
		    0x9E73: 0x67B9,
		    0x9E74: 0x67CE,
		    0x9E75: 0x67C6,
		    0x9E76: 0x67E7,
		    0x9E77: 0x6A9C,
		    0x9E78: 0x681E,
		    0x9E79: 0x6846,
		    0x9E7A: 0x6829,
		    0x9E7B: 0x6840,
		    0x9E7C: 0x684D,
		    0x9E7D: 0x6832,
		    0x9E7E: 0x684E,
		    0x9E80: 0x68B3,
		    0x9E81: 0x682B,
		    0x9E82: 0x6859,
		    0x9E83: 0x6863,
		    0x9E84: 0x6877,
		    0x9E85: 0x687F,
		    0x9E86: 0x689F,
		    0x9E87: 0x688F,
		    0x9E88: 0x68AD,
		    0x9E89: 0x6894,
		    0x9E8A: 0x689D,
		    0x9E8B: 0x689B,
		    0x9E8C: 0x6883,
		    0x9E8D: 0x6AAE,
		    0x9E8E: 0x68B9,
		    0x9E8F: 0x6874,
		    0x9E90: 0x68B5,
		    0x9E91: 0x68A0,
		    0x9E92: 0x68BA,
		    0x9E93: 0x690F,
		    0x9E94: 0x688D,
		    0x9E95: 0x687E,
		    0x9E96: 0x6901,
		    0x9E97: 0x68CA,
		    0x9E98: 0x6908,
		    0x9E99: 0x68D8,
		    0x9E9A: 0x6922,
		    0x9E9B: 0x6926,
		    0x9E9C: 0x68E1,
		    0x9E9D: 0x690C,
		    0x9E9E: 0x68CD,
		    0x9E9F: 0x68D4,
		    0x9EA0: 0x68E7,
		    0x9EA1: 0x68D5,
		    0x9EA2: 0x6936,
		    0x9EA3: 0x6912,
		    0x9EA4: 0x6904,
		    0x9EA5: 0x68D7,
		    0x9EA6: 0x68E3,
		    0x9EA7: 0x6925,
		    0x9EA8: 0x68F9,
		    0x9EA9: 0x68E0,
		    0x9EAA: 0x68EF,
		    0x9EAB: 0x6928,
		    0x9EAC: 0x692A,
		    0x9EAD: 0x691A,
		    0x9EAE: 0x6923,
		    0x9EAF: 0x6921,
		    0x9EB0: 0x68C6,
		    0x9EB1: 0x6979,
		    0x9EB2: 0x6977,
		    0x9EB3: 0x695C,
		    0x9EB4: 0x6978,
		    0x9EB5: 0x696B,
		    0x9EB6: 0x6954,
		    0x9EB7: 0x697E,
		    0x9EB8: 0x696E,
		    0x9EB9: 0x6939,
		    0x9EBA: 0x6974,
		    0x9EBB: 0x693D,
		    0x9EBC: 0x6959,
		    0x9EBD: 0x6930,
		    0x9EBE: 0x6961,
		    0x9EBF: 0x695E,
		    0x9EC0: 0x695D,
		    0x9EC1: 0x6981,
		    0x9EC2: 0x696A,
		    0x9EC3: 0x69B2,
		    0x9EC4: 0x69AE,
		    0x9EC5: 0x69D0,
		    0x9EC6: 0x69BF,
		    0x9EC7: 0x69C1,
		    0x9EC8: 0x69D3,
		    0x9EC9: 0x69BE,
		    0x9ECA: 0x69CE,
		    0x9ECB: 0x5BE8,
		    0x9ECC: 0x69CA,
		    0x9ECD: 0x69DD,
		    0x9ECE: 0x69BB,
		    0x9ECF: 0x69C3,
		    0x9ED0: 0x69A7,
		    0x9ED1: 0x6A2E,
		    0x9ED2: 0x6991,
		    0x9ED3: 0x69A0,
		    0x9ED4: 0x699C,
		    0x9ED5: 0x6995,
		    0x9ED6: 0x69B4,
		    0x9ED7: 0x69DE,
		    0x9ED8: 0x69E8,
		    0x9ED9: 0x6A02,
		    0x9EDA: 0x6A1B,
		    0x9EDB: 0x69FF,
		    0x9EDC: 0x6B0A,
		    0x9EDD: 0x69F9,
		    0x9EDE: 0x69F2,
		    0x9EDF: 0x69E7,
		    0x9EE0: 0x6A05,
		    0x9EE1: 0x69B1,
		    0x9EE2: 0x6A1E,
		    0x9EE3: 0x69ED,
		    0x9EE4: 0x6A14,
		    0x9EE5: 0x69EB,
		    0x9EE6: 0x6A0A,
		    0x9EE7: 0x6A12,
		    0x9EE8: 0x6AC1,
		    0x9EE9: 0x6A23,
		    0x9EEA: 0x6A13,
		    0x9EEB: 0x6A44,
		    0x9EEC: 0x6A0C,
		    0x9EED: 0x6A72,
		    0x9EEE: 0x6A36,
		    0x9EEF: 0x6A78,
		    0x9EF0: 0x6A47,
		    0x9EF1: 0x6A62,
		    0x9EF2: 0x6A59,
		    0x9EF3: 0x6A66,
		    0x9EF4: 0x6A48,
		    0x9EF5: 0x6A38,
		    0x9EF6: 0x6A22,
		    0x9EF7: 0x6A90,
		    0x9EF8: 0x6A8D,
		    0x9EF9: 0x6AA0,
		    0x9EFA: 0x6A84,
		    0x9EFB: 0x6AA2,
		    0x9EFC: 0x6AA3,
		    0x9F40: 0x6A97,
		    0x9F41: 0x8617,
		    0x9F42: 0x6ABB,
		    0x9F43: 0x6AC3,
		    0x9F44: 0x6AC2,
		    0x9F45: 0x6AB8,
		    0x9F46: 0x6AB3,
		    0x9F47: 0x6AAC,
		    0x9F48: 0x6ADE,
		    0x9F49: 0x6AD1,
		    0x9F4A: 0x6ADF,
		    0x9F4B: 0x6AAA,
		    0x9F4C: 0x6ADA,
		    0x9F4D: 0x6AEA,
		    0x9F4E: 0x6AFB,
		    0x9F4F: 0x6B05,
		    0x9F50: 0x8616,
		    0x9F51: 0x6AFA,
		    0x9F52: 0x6B12,
		    0x9F53: 0x6B16,
		    0x9F54: 0x9B31,
		    0x9F55: 0x6B1F,
		    0x9F56: 0x6B38,
		    0x9F57: 0x6B37,
		    0x9F58: 0x76DC,
		    0x9F59: 0x6B39,
		    0x9F5A: 0x98EE,
		    0x9F5B: 0x6B47,
		    0x9F5C: 0x6B43,
		    0x9F5D: 0x6B49,
		    0x9F5E: 0x6B50,
		    0x9F5F: 0x6B59,
		    0x9F60: 0x6B54,
		    0x9F61: 0x6B5B,
		    0x9F62: 0x6B5F,
		    0x9F63: 0x6B61,
		    0x9F64: 0x6B78,
		    0x9F65: 0x6B79,
		    0x9F66: 0x6B7F,
		    0x9F67: 0x6B80,
		    0x9F68: 0x6B84,
		    0x9F69: 0x6B83,
		    0x9F6A: 0x6B8D,
		    0x9F6B: 0x6B98,
		    0x9F6C: 0x6B95,
		    0x9F6D: 0x6B9E,
		    0x9F6E: 0x6BA4,
		    0x9F6F: 0x6BAA,
		    0x9F70: 0x6BAB,
		    0x9F71: 0x6BAF,
		    0x9F72: 0x6BB2,
		    0x9F73: 0x6BB1,
		    0x9F74: 0x6BB3,
		    0x9F75: 0x6BB7,
		    0x9F76: 0x6BBC,
		    0x9F77: 0x6BC6,
		    0x9F78: 0x6BCB,
		    0x9F79: 0x6BD3,
		    0x9F7A: 0x6BDF,
		    0x9F7B: 0x6BEC,
		    0x9F7C: 0x6BEB,
		    0x9F7D: 0x6BF3,
		    0x9F7E: 0x6BEF,
		    0x9F80: 0x9EBE,
		    0x9F81: 0x6C08,
		    0x9F82: 0x6C13,
		    0x9F83: 0x6C14,
		    0x9F84: 0x6C1B,
		    0x9F85: 0x6C24,
		    0x9F86: 0x6C23,
		    0x9F87: 0x6C5E,
		    0x9F88: 0x6C55,
		    0x9F89: 0x6C62,
		    0x9F8A: 0x6C6A,
		    0x9F8B: 0x6C82,
		    0x9F8C: 0x6C8D,
		    0x9F8D: 0x6C9A,
		    0x9F8E: 0x6C81,
		    0x9F8F: 0x6C9B,
		    0x9F90: 0x6C7E,
		    0x9F91: 0x6C68,
		    0x9F92: 0x6C73,
		    0x9F93: 0x6C92,
		    0x9F94: 0x6C90,
		    0x9F95: 0x6CC4,
		    0x9F96: 0x6CF1,
		    0x9F97: 0x6CD3,
		    0x9F98: 0x6CBD,
		    0x9F99: 0x6CD7,
		    0x9F9A: 0x6CC5,
		    0x9F9B: 0x6CDD,
		    0x9F9C: 0x6CAE,
		    0x9F9D: 0x6CB1,
		    0x9F9E: 0x6CBE,
		    0x9F9F: 0x6CBA,
		    0x9FA0: 0x6CDB,
		    0x9FA1: 0x6CEF,
		    0x9FA2: 0x6CD9,
		    0x9FA3: 0x6CEA,
		    0x9FA4: 0x6D1F,
		    0x9FA5: 0x884D,
		    0x9FA6: 0x6D36,
		    0x9FA7: 0x6D2B,
		    0x9FA8: 0x6D3D,
		    0x9FA9: 0x6D38,
		    0x9FAA: 0x6D19,
		    0x9FAB: 0x6D35,
		    0x9FAC: 0x6D33,
		    0x9FAD: 0x6D12,
		    0x9FAE: 0x6D0C,
		    0x9FAF: 0x6D63,
		    0x9FB0: 0x6D93,
		    0x9FB1: 0x6D64,
		    0x9FB2: 0x6D5A,
		    0x9FB3: 0x6D79,
		    0x9FB4: 0x6D59,
		    0x9FB5: 0x6D8E,
		    0x9FB6: 0x6D95,
		    0x9FB7: 0x6FE4,
		    0x9FB8: 0x6D85,
		    0x9FB9: 0x6DF9,
		    0x9FBA: 0x6E15,
		    0x9FBB: 0x6E0A,
		    0x9FBC: 0x6DB5,
		    0x9FBD: 0x6DC7,
		    0x9FBE: 0x6DE6,
		    0x9FBF: 0x6DB8,
		    0x9FC0: 0x6DC6,
		    0x9FC1: 0x6DEC,
		    0x9FC2: 0x6DDE,
		    0x9FC3: 0x6DCC,
		    0x9FC4: 0x6DE8,
		    0x9FC5: 0x6DD2,
		    0x9FC6: 0x6DC5,
		    0x9FC7: 0x6DFA,
		    0x9FC8: 0x6DD9,
		    0x9FC9: 0x6DE4,
		    0x9FCA: 0x6DD5,
		    0x9FCB: 0x6DEA,
		    0x9FCC: 0x6DEE,
		    0x9FCD: 0x6E2D,
		    0x9FCE: 0x6E6E,
		    0x9FCF: 0x6E2E,
		    0x9FD0: 0x6E19,
		    0x9FD1: 0x6E72,
		    0x9FD2: 0x6E5F,
		    0x9FD3: 0x6E3E,
		    0x9FD4: 0x6E23,
		    0x9FD5: 0x6E6B,
		    0x9FD6: 0x6E2B,
		    0x9FD7: 0x6E76,
		    0x9FD8: 0x6E4D,
		    0x9FD9: 0x6E1F,
		    0x9FDA: 0x6E43,
		    0x9FDB: 0x6E3A,
		    0x9FDC: 0x6E4E,
		    0x9FDD: 0x6E24,
		    0x9FDE: 0x6EFF,
		    0x9FDF: 0x6E1D,
		    0x9FE0: 0x6E38,
		    0x9FE1: 0x6E82,
		    0x9FE2: 0x6EAA,
		    0x9FE3: 0x6E98,
		    0x9FE4: 0x6EC9,
		    0x9FE5: 0x6EB7,
		    0x9FE6: 0x6ED3,
		    0x9FE7: 0x6EBD,
		    0x9FE8: 0x6EAF,
		    0x9FE9: 0x6EC4,
		    0x9FEA: 0x6EB2,
		    0x9FEB: 0x6ED4,
		    0x9FEC: 0x6ED5,
		    0x9FED: 0x6E8F,
		    0x9FEE: 0x6EA5,
		    0x9FEF: 0x6EC2,
		    0x9FF0: 0x6E9F,
		    0x9FF1: 0x6F41,
		    0x9FF2: 0x6F11,
		    0x9FF3: 0x704C,
		    0x9FF4: 0x6EEC,
		    0x9FF5: 0x6EF8,
		    0x9FF6: 0x6EFE,
		    0x9FF7: 0x6F3F,
		    0x9FF8: 0x6EF2,
		    0x9FF9: 0x6F31,
		    0x9FFA: 0x6EEF,
		    0x9FFB: 0x6F32,
		    0x9FFC: 0x6ECC,
		    0xA1: 0xFF61,
		    0xA2: 0xFF62,
		    0xA3: 0xFF63,
		    0xA4: 0xFF64,
		    0xA5: 0xFF65,
		    0xA6: 0xFF66,
		    0xA7: 0xFF67,
		    0xA8: 0xFF68,
		    0xA9: 0xFF69,
		    0xAA: 0xFF6A,
		    0xAB: 0xFF6B,
		    0xAC: 0xFF6C,
		    0xAD: 0xFF6D,
		    0xAE: 0xFF6E,
		    0xAF: 0xFF6F,
		    0xB0: 0xFF70,
		    0xB1: 0xFF71,
		    0xB2: 0xFF72,
		    0xB3: 0xFF73,
		    0xB4: 0xFF74,
		    0xB5: 0xFF75,
		    0xB6: 0xFF76,
		    0xB7: 0xFF77,
		    0xB8: 0xFF78,
		    0xB9: 0xFF79,
		    0xBA: 0xFF7A,
		    0xBB: 0xFF7B,
		    0xBC: 0xFF7C,
		    0xBD: 0xFF7D,
		    0xBE: 0xFF7E,
		    0xBF: 0xFF7F,
		    0xC0: 0xFF80,
		    0xC1: 0xFF81,
		    0xC2: 0xFF82,
		    0xC3: 0xFF83,
		    0xC4: 0xFF84,
		    0xC5: 0xFF85,
		    0xC6: 0xFF86,
		    0xC7: 0xFF87,
		    0xC8: 0xFF88,
		    0xC9: 0xFF89,
		    0xCA: 0xFF8A,
		    0xCB: 0xFF8B,
		    0xCC: 0xFF8C,
		    0xCD: 0xFF8D,
		    0xCE: 0xFF8E,
		    0xCF: 0xFF8F,
		    0xD0: 0xFF90,
		    0xD1: 0xFF91,
		    0xD2: 0xFF92,
		    0xD3: 0xFF93,
		    0xD4: 0xFF94,
		    0xD5: 0xFF95,
		    0xD6: 0xFF96,
		    0xD7: 0xFF97,
		    0xD8: 0xFF98,
		    0xD9: 0xFF99,
		    0xDA: 0xFF9A,
		    0xDB: 0xFF9B,
		    0xDC: 0xFF9C,
		    0xDD: 0xFF9D,
		    0xDE: 0xFF9E,
		    0xDF: 0xFF9F,
		    0xE040: 0x6F3E,
		    0xE041: 0x6F13,
		    0xE042: 0x6EF7,
		    0xE043: 0x6F86,
		    0xE044: 0x6F7A,
		    0xE045: 0x6F78,
		    0xE046: 0x6F81,
		    0xE047: 0x6F80,
		    0xE048: 0x6F6F,
		    0xE049: 0x6F5B,
		    0xE04A: 0x6FF3,
		    0xE04B: 0x6F6D,
		    0xE04C: 0x6F82,
		    0xE04D: 0x6F7C,
		    0xE04E: 0x6F58,
		    0xE04F: 0x6F8E,
		    0xE050: 0x6F91,
		    0xE051: 0x6FC2,
		    0xE052: 0x6F66,
		    0xE053: 0x6FB3,
		    0xE054: 0x6FA3,
		    0xE055: 0x6FA1,
		    0xE056: 0x6FA4,
		    0xE057: 0x6FB9,
		    0xE058: 0x6FC6,
		    0xE059: 0x6FAA,
		    0xE05A: 0x6FDF,
		    0xE05B: 0x6FD5,
		    0xE05C: 0x6FEC,
		    0xE05D: 0x6FD4,
		    0xE05E: 0x6FD8,
		    0xE05F: 0x6FF1,
		    0xE060: 0x6FEE,
		    0xE061: 0x6FDB,
		    0xE062: 0x7009,
		    0xE063: 0x700B,
		    0xE064: 0x6FFA,
		    0xE065: 0x7011,
		    0xE066: 0x7001,
		    0xE067: 0x700F,
		    0xE068: 0x6FFE,
		    0xE069: 0x701B,
		    0xE06A: 0x701A,
		    0xE06B: 0x6F74,
		    0xE06C: 0x701D,
		    0xE06D: 0x7018,
		    0xE06E: 0x701F,
		    0xE06F: 0x7030,
		    0xE070: 0x703E,
		    0xE071: 0x7032,
		    0xE072: 0x7051,
		    0xE073: 0x7063,
		    0xE074: 0x7099,
		    0xE075: 0x7092,
		    0xE076: 0x70AF,
		    0xE077: 0x70F1,
		    0xE078: 0x70AC,
		    0xE079: 0x70B8,
		    0xE07A: 0x70B3,
		    0xE07B: 0x70AE,
		    0xE07C: 0x70DF,
		    0xE07D: 0x70CB,
		    0xE07E: 0x70DD,
		    0xE080: 0x70D9,
		    0xE081: 0x7109,
		    0xE082: 0x70FD,
		    0xE083: 0x711C,
		    0xE084: 0x7119,
		    0xE085: 0x7165,
		    0xE086: 0x7155,
		    0xE087: 0x7188,
		    0xE088: 0x7166,
		    0xE089: 0x7162,
		    0xE08A: 0x714C,
		    0xE08B: 0x7156,
		    0xE08C: 0x716C,
		    0xE08D: 0x718F,
		    0xE08E: 0x71FB,
		    0xE08F: 0x7184,
		    0xE090: 0x7195,
		    0xE091: 0x71A8,
		    0xE092: 0x71AC,
		    0xE093: 0x71D7,
		    0xE094: 0x71B9,
		    0xE095: 0x71BE,
		    0xE096: 0x71D2,
		    0xE097: 0x71C9,
		    0xE098: 0x71D4,
		    0xE099: 0x71CE,
		    0xE09A: 0x71E0,
		    0xE09B: 0x71EC,
		    0xE09C: 0x71E7,
		    0xE09D: 0x71F5,
		    0xE09E: 0x71FC,
		    0xE09F: 0x71F9,
		    0xE0A0: 0x71FF,
		    0xE0A1: 0x720D,
		    0xE0A2: 0x7210,
		    0xE0A3: 0x721B,
		    0xE0A4: 0x7228,
		    0xE0A5: 0x722D,
		    0xE0A6: 0x722C,
		    0xE0A7: 0x7230,
		    0xE0A8: 0x7232,
		    0xE0A9: 0x723B,
		    0xE0AA: 0x723C,
		    0xE0AB: 0x723F,
		    0xE0AC: 0x7240,
		    0xE0AD: 0x7246,
		    0xE0AE: 0x724B,
		    0xE0AF: 0x7258,
		    0xE0B0: 0x7274,
		    0xE0B1: 0x727E,
		    0xE0B2: 0x7282,
		    0xE0B3: 0x7281,
		    0xE0B4: 0x7287,
		    0xE0B5: 0x7292,
		    0xE0B6: 0x7296,
		    0xE0B7: 0x72A2,
		    0xE0B8: 0x72A7,
		    0xE0B9: 0x72B9,
		    0xE0BA: 0x72B2,
		    0xE0BB: 0x72C3,
		    0xE0BC: 0x72C6,
		    0xE0BD: 0x72C4,
		    0xE0BE: 0x72CE,
		    0xE0BF: 0x72D2,
		    0xE0C0: 0x72E2,
		    0xE0C1: 0x72E0,
		    0xE0C2: 0x72E1,
		    0xE0C3: 0x72F9,
		    0xE0C4: 0x72F7,
		    0xE0C5: 0x500F,
		    0xE0C6: 0x7317,
		    0xE0C7: 0x730A,
		    0xE0C8: 0x731C,
		    0xE0C9: 0x7316,
		    0xE0CA: 0x731D,
		    0xE0CB: 0x7334,
		    0xE0CC: 0x732F,
		    0xE0CD: 0x7329,
		    0xE0CE: 0x7325,
		    0xE0CF: 0x733E,
		    0xE0D0: 0x734E,
		    0xE0D1: 0x734F,
		    0xE0D2: 0x9ED8,
		    0xE0D3: 0x7357,
		    0xE0D4: 0x736A,
		    0xE0D5: 0x7368,
		    0xE0D6: 0x7370,
		    0xE0D7: 0x7378,
		    0xE0D8: 0x7375,
		    0xE0D9: 0x737B,
		    0xE0DA: 0x737A,
		    0xE0DB: 0x73C8,
		    0xE0DC: 0x73B3,
		    0xE0DD: 0x73CE,
		    0xE0DE: 0x73BB,
		    0xE0DF: 0x73C0,
		    0xE0E0: 0x73E5,
		    0xE0E1: 0x73EE,
		    0xE0E2: 0x73DE,
		    0xE0E3: 0x74A2,
		    0xE0E4: 0x7405,
		    0xE0E5: 0x746F,
		    0xE0E6: 0x7425,
		    0xE0E7: 0x73F8,
		    0xE0E8: 0x7432,
		    0xE0E9: 0x743A,
		    0xE0EA: 0x7455,
		    0xE0EB: 0x743F,
		    0xE0EC: 0x745F,
		    0xE0ED: 0x7459,
		    0xE0EE: 0x7441,
		    0xE0EF: 0x745C,
		    0xE0F0: 0x7469,
		    0xE0F1: 0x7470,
		    0xE0F2: 0x7463,
		    0xE0F3: 0x746A,
		    0xE0F4: 0x7476,
		    0xE0F5: 0x747E,
		    0xE0F6: 0x748B,
		    0xE0F7: 0x749E,
		    0xE0F8: 0x74A7,
		    0xE0F9: 0x74CA,
		    0xE0FA: 0x74CF,
		    0xE0FB: 0x74D4,
		    0xE0FC: 0x73F1,
		    0xE140: 0x74E0,
		    0xE141: 0x74E3,
		    0xE142: 0x74E7,
		    0xE143: 0x74E9,
		    0xE144: 0x74EE,
		    0xE145: 0x74F2,
		    0xE146: 0x74F0,
		    0xE147: 0x74F1,
		    0xE148: 0x74F8,
		    0xE149: 0x74F7,
		    0xE14A: 0x7504,
		    0xE14B: 0x7503,
		    0xE14C: 0x7505,
		    0xE14D: 0x750C,
		    0xE14E: 0x750E,
		    0xE14F: 0x750D,
		    0xE150: 0x7515,
		    0xE151: 0x7513,
		    0xE152: 0x751E,
		    0xE153: 0x7526,
		    0xE154: 0x752C,
		    0xE155: 0x753C,
		    0xE156: 0x7544,
		    0xE157: 0x754D,
		    0xE158: 0x754A,
		    0xE159: 0x7549,
		    0xE15A: 0x755B,
		    0xE15B: 0x7546,
		    0xE15C: 0x755A,
		    0xE15D: 0x7569,
		    0xE15E: 0x7564,
		    0xE15F: 0x7567,
		    0xE160: 0x756B,
		    0xE161: 0x756D,
		    0xE162: 0x7578,
		    0xE163: 0x7576,
		    0xE164: 0x7586,
		    0xE165: 0x7587,
		    0xE166: 0x7574,
		    0xE167: 0x758A,
		    0xE168: 0x7589,
		    0xE169: 0x7582,
		    0xE16A: 0x7594,
		    0xE16B: 0x759A,
		    0xE16C: 0x759D,
		    0xE16D: 0x75A5,
		    0xE16E: 0x75A3,
		    0xE16F: 0x75C2,
		    0xE170: 0x75B3,
		    0xE171: 0x75C3,
		    0xE172: 0x75B5,
		    0xE173: 0x75BD,
		    0xE174: 0x75B8,
		    0xE175: 0x75BC,
		    0xE176: 0x75B1,
		    0xE177: 0x75CD,
		    0xE178: 0x75CA,
		    0xE179: 0x75D2,
		    0xE17A: 0x75D9,
		    0xE17B: 0x75E3,
		    0xE17C: 0x75DE,
		    0xE17D: 0x75FE,
		    0xE17E: 0x75FF,
		    0xE180: 0x75FC,
		    0xE181: 0x7601,
		    0xE182: 0x75F0,
		    0xE183: 0x75FA,
		    0xE184: 0x75F2,
		    0xE185: 0x75F3,
		    0xE186: 0x760B,
		    0xE187: 0x760D,
		    0xE188: 0x7609,
		    0xE189: 0x761F,
		    0xE18A: 0x7627,
		    0xE18B: 0x7620,
		    0xE18C: 0x7621,
		    0xE18D: 0x7622,
		    0xE18E: 0x7624,
		    0xE18F: 0x7634,
		    0xE190: 0x7630,
		    0xE191: 0x763B,
		    0xE192: 0x7647,
		    0xE193: 0x7648,
		    0xE194: 0x7646,
		    0xE195: 0x765C,
		    0xE196: 0x7658,
		    0xE197: 0x7661,
		    0xE198: 0x7662,
		    0xE199: 0x7668,
		    0xE19A: 0x7669,
		    0xE19B: 0x766A,
		    0xE19C: 0x7667,
		    0xE19D: 0x766C,
		    0xE19E: 0x7670,
		    0xE19F: 0x7672,
		    0xE1A0: 0x7676,
		    0xE1A1: 0x7678,
		    0xE1A2: 0x767C,
		    0xE1A3: 0x7680,
		    0xE1A4: 0x7683,
		    0xE1A5: 0x7688,
		    0xE1A6: 0x768B,
		    0xE1A7: 0x768E,
		    0xE1A8: 0x7696,
		    0xE1A9: 0x7693,
		    0xE1AA: 0x7699,
		    0xE1AB: 0x769A,
		    0xE1AC: 0x76B0,
		    0xE1AD: 0x76B4,
		    0xE1AE: 0x76B8,
		    0xE1AF: 0x76B9,
		    0xE1B0: 0x76BA,
		    0xE1B1: 0x76C2,
		    0xE1B2: 0x76CD,
		    0xE1B3: 0x76D6,
		    0xE1B4: 0x76D2,
		    0xE1B5: 0x76DE,
		    0xE1B6: 0x76E1,
		    0xE1B7: 0x76E5,
		    0xE1B8: 0x76E7,
		    0xE1B9: 0x76EA,
		    0xE1BA: 0x862F,
		    0xE1BB: 0x76FB,
		    0xE1BC: 0x7708,
		    0xE1BD: 0x7707,
		    0xE1BE: 0x7704,
		    0xE1BF: 0x7729,
		    0xE1C0: 0x7724,
		    0xE1C1: 0x771E,
		    0xE1C2: 0x7725,
		    0xE1C3: 0x7726,
		    0xE1C4: 0x771B,
		    0xE1C5: 0x7737,
		    0xE1C6: 0x7738,
		    0xE1C7: 0x7747,
		    0xE1C8: 0x775A,
		    0xE1C9: 0x7768,
		    0xE1CA: 0x776B,
		    0xE1CB: 0x775B,
		    0xE1CC: 0x7765,
		    0xE1CD: 0x777F,
		    0xE1CE: 0x777E,
		    0xE1CF: 0x7779,
		    0xE1D0: 0x778E,
		    0xE1D1: 0x778B,
		    0xE1D2: 0x7791,
		    0xE1D3: 0x77A0,
		    0xE1D4: 0x779E,
		    0xE1D5: 0x77B0,
		    0xE1D6: 0x77B6,
		    0xE1D7: 0x77B9,
		    0xE1D8: 0x77BF,
		    0xE1D9: 0x77BC,
		    0xE1DA: 0x77BD,
		    0xE1DB: 0x77BB,
		    0xE1DC: 0x77C7,
		    0xE1DD: 0x77CD,
		    0xE1DE: 0x77D7,
		    0xE1DF: 0x77DA,
		    0xE1E0: 0x77DC,
		    0xE1E1: 0x77E3,
		    0xE1E2: 0x77EE,
		    0xE1E3: 0x77FC,
		    0xE1E4: 0x780C,
		    0xE1E5: 0x7812,
		    0xE1E6: 0x7926,
		    0xE1E7: 0x7820,
		    0xE1E8: 0x792A,
		    0xE1E9: 0x7845,
		    0xE1EA: 0x788E,
		    0xE1EB: 0x7874,
		    0xE1EC: 0x7886,
		    0xE1ED: 0x787C,
		    0xE1EE: 0x789A,
		    0xE1EF: 0x788C,
		    0xE1F0: 0x78A3,
		    0xE1F1: 0x78B5,
		    0xE1F2: 0x78AA,
		    0xE1F3: 0x78AF,
		    0xE1F4: 0x78D1,
		    0xE1F5: 0x78C6,
		    0xE1F6: 0x78CB,
		    0xE1F7: 0x78D4,
		    0xE1F8: 0x78BE,
		    0xE1F9: 0x78BC,
		    0xE1FA: 0x78C5,
		    0xE1FB: 0x78CA,
		    0xE1FC: 0x78EC,
		    0xE240: 0x78E7,
		    0xE241: 0x78DA,
		    0xE242: 0x78FD,
		    0xE243: 0x78F4,
		    0xE244: 0x7907,
		    0xE245: 0x7912,
		    0xE246: 0x7911,
		    0xE247: 0x7919,
		    0xE248: 0x792C,
		    0xE249: 0x792B,
		    0xE24A: 0x7940,
		    0xE24B: 0x7960,
		    0xE24C: 0x7957,
		    0xE24D: 0x795F,
		    0xE24E: 0x795A,
		    0xE24F: 0x7955,
		    0xE250: 0x7953,
		    0xE251: 0x797A,
		    0xE252: 0x797F,
		    0xE253: 0x798A,
		    0xE254: 0x799D,
		    0xE255: 0x79A7,
		    0xE256: 0x9F4B,
		    0xE257: 0x79AA,
		    0xE258: 0x79AE,
		    0xE259: 0x79B3,
		    0xE25A: 0x79B9,
		    0xE25B: 0x79BA,
		    0xE25C: 0x79C9,
		    0xE25D: 0x79D5,
		    0xE25E: 0x79E7,
		    0xE25F: 0x79EC,
		    0xE260: 0x79E1,
		    0xE261: 0x79E3,
		    0xE262: 0x7A08,
		    0xE263: 0x7A0D,
		    0xE264: 0x7A18,
		    0xE265: 0x7A19,
		    0xE266: 0x7A20,
		    0xE267: 0x7A1F,
		    0xE268: 0x7980,
		    0xE269: 0x7A31,
		    0xE26A: 0x7A3B,
		    0xE26B: 0x7A3E,
		    0xE26C: 0x7A37,
		    0xE26D: 0x7A43,
		    0xE26E: 0x7A57,
		    0xE26F: 0x7A49,
		    0xE270: 0x7A61,
		    0xE271: 0x7A62,
		    0xE272: 0x7A69,
		    0xE273: 0x9F9D,
		    0xE274: 0x7A70,
		    0xE275: 0x7A79,
		    0xE276: 0x7A7D,
		    0xE277: 0x7A88,
		    0xE278: 0x7A97,
		    0xE279: 0x7A95,
		    0xE27A: 0x7A98,
		    0xE27B: 0x7A96,
		    0xE27C: 0x7AA9,
		    0xE27D: 0x7AC8,
		    0xE27E: 0x7AB0,
		    0xE280: 0x7AB6,
		    0xE281: 0x7AC5,
		    0xE282: 0x7AC4,
		    0xE283: 0x7ABF,
		    0xE284: 0x9083,
		    0xE285: 0x7AC7,
		    0xE286: 0x7ACA,
		    0xE287: 0x7ACD,
		    0xE288: 0x7ACF,
		    0xE289: 0x7AD5,
		    0xE28A: 0x7AD3,
		    0xE28B: 0x7AD9,
		    0xE28C: 0x7ADA,
		    0xE28D: 0x7ADD,
		    0xE28E: 0x7AE1,
		    0xE28F: 0x7AE2,
		    0xE290: 0x7AE6,
		    0xE291: 0x7AED,
		    0xE292: 0x7AF0,
		    0xE293: 0x7B02,
		    0xE294: 0x7B0F,
		    0xE295: 0x7B0A,
		    0xE296: 0x7B06,
		    0xE297: 0x7B33,
		    0xE298: 0x7B18,
		    0xE299: 0x7B19,
		    0xE29A: 0x7B1E,
		    0xE29B: 0x7B35,
		    0xE29C: 0x7B28,
		    0xE29D: 0x7B36,
		    0xE29E: 0x7B50,
		    0xE29F: 0x7B7A,
		    0xE2A0: 0x7B04,
		    0xE2A1: 0x7B4D,
		    0xE2A2: 0x7B0B,
		    0xE2A3: 0x7B4C,
		    0xE2A4: 0x7B45,
		    0xE2A5: 0x7B75,
		    0xE2A6: 0x7B65,
		    0xE2A7: 0x7B74,
		    0xE2A8: 0x7B67,
		    0xE2A9: 0x7B70,
		    0xE2AA: 0x7B71,
		    0xE2AB: 0x7B6C,
		    0xE2AC: 0x7B6E,
		    0xE2AD: 0x7B9D,
		    0xE2AE: 0x7B98,
		    0xE2AF: 0x7B9F,
		    0xE2B0: 0x7B8D,
		    0xE2B1: 0x7B9C,
		    0xE2B2: 0x7B9A,
		    0xE2B3: 0x7B8B,
		    0xE2B4: 0x7B92,
		    0xE2B5: 0x7B8F,
		    0xE2B6: 0x7B5D,
		    0xE2B7: 0x7B99,
		    0xE2B8: 0x7BCB,
		    0xE2B9: 0x7BC1,
		    0xE2BA: 0x7BCC,
		    0xE2BB: 0x7BCF,
		    0xE2BC: 0x7BB4,
		    0xE2BD: 0x7BC6,
		    0xE2BE: 0x7BDD,
		    0xE2BF: 0x7BE9,
		    0xE2C0: 0x7C11,
		    0xE2C1: 0x7C14,
		    0xE2C2: 0x7BE6,
		    0xE2C3: 0x7BE5,
		    0xE2C4: 0x7C60,
		    0xE2C5: 0x7C00,
		    0xE2C6: 0x7C07,
		    0xE2C7: 0x7C13,
		    0xE2C8: 0x7BF3,
		    0xE2C9: 0x7BF7,
		    0xE2CA: 0x7C17,
		    0xE2CB: 0x7C0D,
		    0xE2CC: 0x7BF6,
		    0xE2CD: 0x7C23,
		    0xE2CE: 0x7C27,
		    0xE2CF: 0x7C2A,
		    0xE2D0: 0x7C1F,
		    0xE2D1: 0x7C37,
		    0xE2D2: 0x7C2B,
		    0xE2D3: 0x7C3D,
		    0xE2D4: 0x7C4C,
		    0xE2D5: 0x7C43,
		    0xE2D6: 0x7C54,
		    0xE2D7: 0x7C4F,
		    0xE2D8: 0x7C40,
		    0xE2D9: 0x7C50,
		    0xE2DA: 0x7C58,
		    0xE2DB: 0x7C5F,
		    0xE2DC: 0x7C64,
		    0xE2DD: 0x7C56,
		    0xE2DE: 0x7C65,
		    0xE2DF: 0x7C6C,
		    0xE2E0: 0x7C75,
		    0xE2E1: 0x7C83,
		    0xE2E2: 0x7C90,
		    0xE2E3: 0x7CA4,
		    0xE2E4: 0x7CAD,
		    0xE2E5: 0x7CA2,
		    0xE2E6: 0x7CAB,
		    0xE2E7: 0x7CA1,
		    0xE2E8: 0x7CA8,
		    0xE2E9: 0x7CB3,
		    0xE2EA: 0x7CB2,
		    0xE2EB: 0x7CB1,
		    0xE2EC: 0x7CAE,
		    0xE2ED: 0x7CB9,
		    0xE2EE: 0x7CBD,
		    0xE2EF: 0x7CC0,
		    0xE2F0: 0x7CC5,
		    0xE2F1: 0x7CC2,
		    0xE2F2: 0x7CD8,
		    0xE2F3: 0x7CD2,
		    0xE2F4: 0x7CDC,
		    0xE2F5: 0x7CE2,
		    0xE2F6: 0x9B3B,
		    0xE2F7: 0x7CEF,
		    0xE2F8: 0x7CF2,
		    0xE2F9: 0x7CF4,
		    0xE2FA: 0x7CF6,
		    0xE2FB: 0x7CFA,
		    0xE2FC: 0x7D06,
		    0xE340: 0x7D02,
		    0xE341: 0x7D1C,
		    0xE342: 0x7D15,
		    0xE343: 0x7D0A,
		    0xE344: 0x7D45,
		    0xE345: 0x7D4B,
		    0xE346: 0x7D2E,
		    0xE347: 0x7D32,
		    0xE348: 0x7D3F,
		    0xE349: 0x7D35,
		    0xE34A: 0x7D46,
		    0xE34B: 0x7D73,
		    0xE34C: 0x7D56,
		    0xE34D: 0x7D4E,
		    0xE34E: 0x7D72,
		    0xE34F: 0x7D68,
		    0xE350: 0x7D6E,
		    0xE351: 0x7D4F,
		    0xE352: 0x7D63,
		    0xE353: 0x7D93,
		    0xE354: 0x7D89,
		    0xE355: 0x7D5B,
		    0xE356: 0x7D8F,
		    0xE357: 0x7D7D,
		    0xE358: 0x7D9B,
		    0xE359: 0x7DBA,
		    0xE35A: 0x7DAE,
		    0xE35B: 0x7DA3,
		    0xE35C: 0x7DB5,
		    0xE35D: 0x7DC7,
		    0xE35E: 0x7DBD,
		    0xE35F: 0x7DAB,
		    0xE360: 0x7E3D,
		    0xE361: 0x7DA2,
		    0xE362: 0x7DAF,
		    0xE363: 0x7DDC,
		    0xE364: 0x7DB8,
		    0xE365: 0x7D9F,
		    0xE366: 0x7DB0,
		    0xE367: 0x7DD8,
		    0xE368: 0x7DDD,
		    0xE369: 0x7DE4,
		    0xE36A: 0x7DDE,
		    0xE36B: 0x7DFB,
		    0xE36C: 0x7DF2,
		    0xE36D: 0x7DE1,
		    0xE36E: 0x7E05,
		    0xE36F: 0x7E0A,
		    0xE370: 0x7E23,
		    0xE371: 0x7E21,
		    0xE372: 0x7E12,
		    0xE373: 0x7E31,
		    0xE374: 0x7E1F,
		    0xE375: 0x7E09,
		    0xE376: 0x7E0B,
		    0xE377: 0x7E22,
		    0xE378: 0x7E46,
		    0xE379: 0x7E66,
		    0xE37A: 0x7E3B,
		    0xE37B: 0x7E35,
		    0xE37C: 0x7E39,
		    0xE37D: 0x7E43,
		    0xE37E: 0x7E37,
		    0xE380: 0x7E32,
		    0xE381: 0x7E3A,
		    0xE382: 0x7E67,
		    0xE383: 0x7E5D,
		    0xE384: 0x7E56,
		    0xE385: 0x7E5E,
		    0xE386: 0x7E59,
		    0xE387: 0x7E5A,
		    0xE388: 0x7E79,
		    0xE389: 0x7E6A,
		    0xE38A: 0x7E69,
		    0xE38B: 0x7E7C,
		    0xE38C: 0x7E7B,
		    0xE38D: 0x7E83,
		    0xE38E: 0x7DD5,
		    0xE38F: 0x7E7D,
		    0xE390: 0x8FAE,
		    0xE391: 0x7E7F,
		    0xE392: 0x7E88,
		    0xE393: 0x7E89,
		    0xE394: 0x7E8C,
		    0xE395: 0x7E92,
		    0xE396: 0x7E90,
		    0xE397: 0x7E93,
		    0xE398: 0x7E94,
		    0xE399: 0x7E96,
		    0xE39A: 0x7E8E,
		    0xE39B: 0x7E9B,
		    0xE39C: 0x7E9C,
		    0xE39D: 0x7F38,
		    0xE39E: 0x7F3A,
		    0xE39F: 0x7F45,
		    0xE3A0: 0x7F4C,
		    0xE3A1: 0x7F4D,
		    0xE3A2: 0x7F4E,
		    0xE3A3: 0x7F50,
		    0xE3A4: 0x7F51,
		    0xE3A5: 0x7F55,
		    0xE3A6: 0x7F54,
		    0xE3A7: 0x7F58,
		    0xE3A8: 0x7F5F,
		    0xE3A9: 0x7F60,
		    0xE3AA: 0x7F68,
		    0xE3AB: 0x7F69,
		    0xE3AC: 0x7F67,
		    0xE3AD: 0x7F78,
		    0xE3AE: 0x7F82,
		    0xE3AF: 0x7F86,
		    0xE3B0: 0x7F83,
		    0xE3B1: 0x7F88,
		    0xE3B2: 0x7F87,
		    0xE3B3: 0x7F8C,
		    0xE3B4: 0x7F94,
		    0xE3B5: 0x7F9E,
		    0xE3B6: 0x7F9D,
		    0xE3B7: 0x7F9A,
		    0xE3B8: 0x7FA3,
		    0xE3B9: 0x7FAF,
		    0xE3BA: 0x7FB2,
		    0xE3BB: 0x7FB9,
		    0xE3BC: 0x7FAE,
		    0xE3BD: 0x7FB6,
		    0xE3BE: 0x7FB8,
		    0xE3BF: 0x8B71,
		    0xE3C0: 0x7FC5,
		    0xE3C1: 0x7FC6,
		    0xE3C2: 0x7FCA,
		    0xE3C3: 0x7FD5,
		    0xE3C4: 0x7FD4,
		    0xE3C5: 0x7FE1,
		    0xE3C6: 0x7FE6,
		    0xE3C7: 0x7FE9,
		    0xE3C8: 0x7FF3,
		    0xE3C9: 0x7FF9,
		    0xE3CA: 0x98DC,
		    0xE3CB: 0x8006,
		    0xE3CC: 0x8004,
		    0xE3CD: 0x800B,
		    0xE3CE: 0x8012,
		    0xE3CF: 0x8018,
		    0xE3D0: 0x8019,
		    0xE3D1: 0x801C,
		    0xE3D2: 0x8021,
		    0xE3D3: 0x8028,
		    0xE3D4: 0x803F,
		    0xE3D5: 0x803B,
		    0xE3D6: 0x804A,
		    0xE3D7: 0x8046,
		    0xE3D8: 0x8052,
		    0xE3D9: 0x8058,
		    0xE3DA: 0x805A,
		    0xE3DB: 0x805F,
		    0xE3DC: 0x8062,
		    0xE3DD: 0x8068,
		    0xE3DE: 0x8073,
		    0xE3DF: 0x8072,
		    0xE3E0: 0x8070,
		    0xE3E1: 0x8076,
		    0xE3E2: 0x8079,
		    0xE3E3: 0x807D,
		    0xE3E4: 0x807F,
		    0xE3E5: 0x8084,
		    0xE3E6: 0x8086,
		    0xE3E7: 0x8085,
		    0xE3E8: 0x809B,
		    0xE3E9: 0x8093,
		    0xE3EA: 0x809A,
		    0xE3EB: 0x80AD,
		    0xE3EC: 0x5190,
		    0xE3ED: 0x80AC,
		    0xE3EE: 0x80DB,
		    0xE3EF: 0x80E5,
		    0xE3F0: 0x80D9,
		    0xE3F1: 0x80DD,
		    0xE3F2: 0x80C4,
		    0xE3F3: 0x80DA,
		    0xE3F4: 0x80D6,
		    0xE3F5: 0x8109,
		    0xE3F6: 0x80EF,
		    0xE3F7: 0x80F1,
		    0xE3F8: 0x811B,
		    0xE3F9: 0x8129,
		    0xE3FA: 0x8123,
		    0xE3FB: 0x812F,
		    0xE3FC: 0x814B,
		    0xE440: 0x968B,
		    0xE441: 0x8146,
		    0xE442: 0x813E,
		    0xE443: 0x8153,
		    0xE444: 0x8151,
		    0xE445: 0x80FC,
		    0xE446: 0x8171,
		    0xE447: 0x816E,
		    0xE448: 0x8165,
		    0xE449: 0x8166,
		    0xE44A: 0x8174,
		    0xE44B: 0x8183,
		    0xE44C: 0x8188,
		    0xE44D: 0x818A,
		    0xE44E: 0x8180,
		    0xE44F: 0x8182,
		    0xE450: 0x81A0,
		    0xE451: 0x8195,
		    0xE452: 0x81A4,
		    0xE453: 0x81A3,
		    0xE454: 0x815F,
		    0xE455: 0x8193,
		    0xE456: 0x81A9,
		    0xE457: 0x81B0,
		    0xE458: 0x81B5,
		    0xE459: 0x81BE,
		    0xE45A: 0x81B8,
		    0xE45B: 0x81BD,
		    0xE45C: 0x81C0,
		    0xE45D: 0x81C2,
		    0xE45E: 0x81BA,
		    0xE45F: 0x81C9,
		    0xE460: 0x81CD,
		    0xE461: 0x81D1,
		    0xE462: 0x81D9,
		    0xE463: 0x81D8,
		    0xE464: 0x81C8,
		    0xE465: 0x81DA,
		    0xE466: 0x81DF,
		    0xE467: 0x81E0,
		    0xE468: 0x81E7,
		    0xE469: 0x81FA,
		    0xE46A: 0x81FB,
		    0xE46B: 0x81FE,
		    0xE46C: 0x8201,
		    0xE46D: 0x8202,
		    0xE46E: 0x8205,
		    0xE46F: 0x8207,
		    0xE470: 0x820A,
		    0xE471: 0x820D,
		    0xE472: 0x8210,
		    0xE473: 0x8216,
		    0xE474: 0x8229,
		    0xE475: 0x822B,
		    0xE476: 0x8238,
		    0xE477: 0x8233,
		    0xE478: 0x8240,
		    0xE479: 0x8259,
		    0xE47A: 0x8258,
		    0xE47B: 0x825D,
		    0xE47C: 0x825A,
		    0xE47D: 0x825F,
		    0xE47E: 0x8264,
		    0xE480: 0x8262,
		    0xE481: 0x8268,
		    0xE482: 0x826A,
		    0xE483: 0x826B,
		    0xE484: 0x822E,
		    0xE485: 0x8271,
		    0xE486: 0x8277,
		    0xE487: 0x8278,
		    0xE488: 0x827E,
		    0xE489: 0x828D,
		    0xE48A: 0x8292,
		    0xE48B: 0x82AB,
		    0xE48C: 0x829F,
		    0xE48D: 0x82BB,
		    0xE48E: 0x82AC,
		    0xE48F: 0x82E1,
		    0xE490: 0x82E3,
		    0xE491: 0x82DF,
		    0xE492: 0x82D2,
		    0xE493: 0x82F4,
		    0xE494: 0x82F3,
		    0xE495: 0x82FA,
		    0xE496: 0x8393,
		    0xE497: 0x8303,
		    0xE498: 0x82FB,
		    0xE499: 0x82F9,
		    0xE49A: 0x82DE,
		    0xE49B: 0x8306,
		    0xE49C: 0x82DC,
		    0xE49D: 0x8309,
		    0xE49E: 0x82D9,
		    0xE49F: 0x8335,
		    0xE4A0: 0x8334,
		    0xE4A1: 0x8316,
		    0xE4A2: 0x8332,
		    0xE4A3: 0x8331,
		    0xE4A4: 0x8340,
		    0xE4A5: 0x8339,
		    0xE4A6: 0x8350,
		    0xE4A7: 0x8345,
		    0xE4A8: 0x832F,
		    0xE4A9: 0x832B,
		    0xE4AA: 0x8317,
		    0xE4AB: 0x8318,
		    0xE4AC: 0x8385,
		    0xE4AD: 0x839A,
		    0xE4AE: 0x83AA,
		    0xE4AF: 0x839F,
		    0xE4B0: 0x83A2,
		    0xE4B1: 0x8396,
		    0xE4B2: 0x8323,
		    0xE4B3: 0x838E,
		    0xE4B4: 0x8387,
		    0xE4B5: 0x838A,
		    0xE4B6: 0x837C,
		    0xE4B7: 0x83B5,
		    0xE4B8: 0x8373,
		    0xE4B9: 0x8375,
		    0xE4BA: 0x83A0,
		    0xE4BB: 0x8389,
		    0xE4BC: 0x83A8,
		    0xE4BD: 0x83F4,
		    0xE4BE: 0x8413,
		    0xE4BF: 0x83EB,
		    0xE4C0: 0x83CE,
		    0xE4C1: 0x83FD,
		    0xE4C2: 0x8403,
		    0xE4C3: 0x83D8,
		    0xE4C4: 0x840B,
		    0xE4C5: 0x83C1,
		    0xE4C6: 0x83F7,
		    0xE4C7: 0x8407,
		    0xE4C8: 0x83E0,
		    0xE4C9: 0x83F2,
		    0xE4CA: 0x840D,
		    0xE4CB: 0x8422,
		    0xE4CC: 0x8420,
		    0xE4CD: 0x83BD,
		    0xE4CE: 0x8438,
		    0xE4CF: 0x8506,
		    0xE4D0: 0x83FB,
		    0xE4D1: 0x846D,
		    0xE4D2: 0x842A,
		    0xE4D3: 0x843C,
		    0xE4D4: 0x855A,
		    0xE4D5: 0x8484,
		    0xE4D6: 0x8477,
		    0xE4D7: 0x846B,
		    0xE4D8: 0x84AD,
		    0xE4D9: 0x846E,
		    0xE4DA: 0x8482,
		    0xE4DB: 0x8469,
		    0xE4DC: 0x8446,
		    0xE4DD: 0x842C,
		    0xE4DE: 0x846F,
		    0xE4DF: 0x8479,
		    0xE4E0: 0x8435,
		    0xE4E1: 0x84CA,
		    0xE4E2: 0x8462,
		    0xE4E3: 0x84B9,
		    0xE4E4: 0x84BF,
		    0xE4E5: 0x849F,
		    0xE4E6: 0x84D9,
		    0xE4E7: 0x84CD,
		    0xE4E8: 0x84BB,
		    0xE4E9: 0x84DA,
		    0xE4EA: 0x84D0,
		    0xE4EB: 0x84C1,
		    0xE4EC: 0x84C6,
		    0xE4ED: 0x84D6,
		    0xE4EE: 0x84A1,
		    0xE4EF: 0x8521,
		    0xE4F0: 0x84FF,
		    0xE4F1: 0x84F4,
		    0xE4F2: 0x8517,
		    0xE4F3: 0x8518,
		    0xE4F4: 0x852C,
		    0xE4F5: 0x851F,
		    0xE4F6: 0x8515,
		    0xE4F7: 0x8514,
		    0xE4F8: 0x84FC,
		    0xE4F9: 0x8540,
		    0xE4FA: 0x8563,
		    0xE4FB: 0x8558,
		    0xE4FC: 0x8548,
		    0xE540: 0x8541,
		    0xE541: 0x8602,
		    0xE542: 0x854B,
		    0xE543: 0x8555,
		    0xE544: 0x8580,
		    0xE545: 0x85A4,
		    0xE546: 0x8588,
		    0xE547: 0x8591,
		    0xE548: 0x858A,
		    0xE549: 0x85A8,
		    0xE54A: 0x856D,
		    0xE54B: 0x8594,
		    0xE54C: 0x859B,
		    0xE54D: 0x85EA,
		    0xE54E: 0x8587,
		    0xE54F: 0x859C,
		    0xE550: 0x8577,
		    0xE551: 0x857E,
		    0xE552: 0x8590,
		    0xE553: 0x85C9,
		    0xE554: 0x85BA,
		    0xE555: 0x85CF,
		    0xE556: 0x85B9,
		    0xE557: 0x85D0,
		    0xE558: 0x85D5,
		    0xE559: 0x85DD,
		    0xE55A: 0x85E5,
		    0xE55B: 0x85DC,
		    0xE55C: 0x85F9,
		    0xE55D: 0x860A,
		    0xE55E: 0x8613,
		    0xE55F: 0x860B,
		    0xE560: 0x85FE,
		    0xE561: 0x85FA,
		    0xE562: 0x8606,
		    0xE563: 0x8622,
		    0xE564: 0x861A,
		    0xE565: 0x8630,
		    0xE566: 0x863F,
		    0xE567: 0x864D,
		    0xE568: 0x4E55,
		    0xE569: 0x8654,
		    0xE56A: 0x865F,
		    0xE56B: 0x8667,
		    0xE56C: 0x8671,
		    0xE56D: 0x8693,
		    0xE56E: 0x86A3,
		    0xE56F: 0x86A9,
		    0xE570: 0x86AA,
		    0xE571: 0x868B,
		    0xE572: 0x868C,
		    0xE573: 0x86B6,
		    0xE574: 0x86AF,
		    0xE575: 0x86C4,
		    0xE576: 0x86C6,
		    0xE577: 0x86B0,
		    0xE578: 0x86C9,
		    0xE579: 0x8823,
		    0xE57A: 0x86AB,
		    0xE57B: 0x86D4,
		    0xE57C: 0x86DE,
		    0xE57D: 0x86E9,
		    0xE57E: 0x86EC,
		    0xE580: 0x86DF,
		    0xE581: 0x86DB,
		    0xE582: 0x86EF,
		    0xE583: 0x8712,
		    0xE584: 0x8706,
		    0xE585: 0x8708,
		    0xE586: 0x8700,
		    0xE587: 0x8703,
		    0xE588: 0x86FB,
		    0xE589: 0x8711,
		    0xE58A: 0x8709,
		    0xE58B: 0x870D,
		    0xE58C: 0x86F9,
		    0xE58D: 0x870A,
		    0xE58E: 0x8734,
		    0xE58F: 0x873F,
		    0xE590: 0x8737,
		    0xE591: 0x873B,
		    0xE592: 0x8725,
		    0xE593: 0x8729,
		    0xE594: 0x871A,
		    0xE595: 0x8760,
		    0xE596: 0x875F,
		    0xE597: 0x8778,
		    0xE598: 0x874C,
		    0xE599: 0x874E,
		    0xE59A: 0x8774,
		    0xE59B: 0x8757,
		    0xE59C: 0x8768,
		    0xE59D: 0x876E,
		    0xE59E: 0x8759,
		    0xE59F: 0x8753,
		    0xE5A0: 0x8763,
		    0xE5A1: 0x876A,
		    0xE5A2: 0x8805,
		    0xE5A3: 0x87A2,
		    0xE5A4: 0x879F,
		    0xE5A5: 0x8782,
		    0xE5A6: 0x87AF,
		    0xE5A7: 0x87CB,
		    0xE5A8: 0x87BD,
		    0xE5A9: 0x87C0,
		    0xE5AA: 0x87D0,
		    0xE5AB: 0x96D6,
		    0xE5AC: 0x87AB,
		    0xE5AD: 0x87C4,
		    0xE5AE: 0x87B3,
		    0xE5AF: 0x87C7,
		    0xE5B0: 0x87C6,
		    0xE5B1: 0x87BB,
		    0xE5B2: 0x87EF,
		    0xE5B3: 0x87F2,
		    0xE5B4: 0x87E0,
		    0xE5B5: 0x880F,
		    0xE5B6: 0x880D,
		    0xE5B7: 0x87FE,
		    0xE5B8: 0x87F6,
		    0xE5B9: 0x87F7,
		    0xE5BA: 0x880E,
		    0xE5BB: 0x87D2,
		    0xE5BC: 0x8811,
		    0xE5BD: 0x8816,
		    0xE5BE: 0x8815,
		    0xE5BF: 0x8822,
		    0xE5C0: 0x8821,
		    0xE5C1: 0x8831,
		    0xE5C2: 0x8836,
		    0xE5C3: 0x8839,
		    0xE5C4: 0x8827,
		    0xE5C5: 0x883B,
		    0xE5C6: 0x8844,
		    0xE5C7: 0x8842,
		    0xE5C8: 0x8852,
		    0xE5C9: 0x8859,
		    0xE5CA: 0x885E,
		    0xE5CB: 0x8862,
		    0xE5CC: 0x886B,
		    0xE5CD: 0x8881,
		    0xE5CE: 0x887E,
		    0xE5CF: 0x889E,
		    0xE5D0: 0x8875,
		    0xE5D1: 0x887D,
		    0xE5D2: 0x88B5,
		    0xE5D3: 0x8872,
		    0xE5D4: 0x8882,
		    0xE5D5: 0x8897,
		    0xE5D6: 0x8892,
		    0xE5D7: 0x88AE,
		    0xE5D8: 0x8899,
		    0xE5D9: 0x88A2,
		    0xE5DA: 0x888D,
		    0xE5DB: 0x88A4,
		    0xE5DC: 0x88B0,
		    0xE5DD: 0x88BF,
		    0xE5DE: 0x88B1,
		    0xE5DF: 0x88C3,
		    0xE5E0: 0x88C4,
		    0xE5E1: 0x88D4,
		    0xE5E2: 0x88D8,
		    0xE5E3: 0x88D9,
		    0xE5E4: 0x88DD,
		    0xE5E5: 0x88F9,
		    0xE5E6: 0x8902,
		    0xE5E7: 0x88FC,
		    0xE5E8: 0x88F4,
		    0xE5E9: 0x88E8,
		    0xE5EA: 0x88F2,
		    0xE5EB: 0x8904,
		    0xE5EC: 0x890C,
		    0xE5ED: 0x890A,
		    0xE5EE: 0x8913,
		    0xE5EF: 0x8943,
		    0xE5F0: 0x891E,
		    0xE5F1: 0x8925,
		    0xE5F2: 0x892A,
		    0xE5F3: 0x892B,
		    0xE5F4: 0x8941,
		    0xE5F5: 0x8944,
		    0xE5F6: 0x893B,
		    0xE5F7: 0x8936,
		    0xE5F8: 0x8938,
		    0xE5F9: 0x894C,
		    0xE5FA: 0x891D,
		    0xE5FB: 0x8960,
		    0xE5FC: 0x895E,
		    0xE640: 0x8966,
		    0xE641: 0x8964,
		    0xE642: 0x896D,
		    0xE643: 0x896A,
		    0xE644: 0x896F,
		    0xE645: 0x8974,
		    0xE646: 0x8977,
		    0xE647: 0x897E,
		    0xE648: 0x8983,
		    0xE649: 0x8988,
		    0xE64A: 0x898A,
		    0xE64B: 0x8993,
		    0xE64C: 0x8998,
		    0xE64D: 0x89A1,
		    0xE64E: 0x89A9,
		    0xE64F: 0x89A6,
		    0xE650: 0x89AC,
		    0xE651: 0x89AF,
		    0xE652: 0x89B2,
		    0xE653: 0x89BA,
		    0xE654: 0x89BD,
		    0xE655: 0x89BF,
		    0xE656: 0x89C0,
		    0xE657: 0x89DA,
		    0xE658: 0x89DC,
		    0xE659: 0x89DD,
		    0xE65A: 0x89E7,
		    0xE65B: 0x89F4,
		    0xE65C: 0x89F8,
		    0xE65D: 0x8A03,
		    0xE65E: 0x8A16,
		    0xE65F: 0x8A10,
		    0xE660: 0x8A0C,
		    0xE661: 0x8A1B,
		    0xE662: 0x8A1D,
		    0xE663: 0x8A25,
		    0xE664: 0x8A36,
		    0xE665: 0x8A41,
		    0xE666: 0x8A5B,
		    0xE667: 0x8A52,
		    0xE668: 0x8A46,
		    0xE669: 0x8A48,
		    0xE66A: 0x8A7C,
		    0xE66B: 0x8A6D,
		    0xE66C: 0x8A6C,
		    0xE66D: 0x8A62,
		    0xE66E: 0x8A85,
		    0xE66F: 0x8A82,
		    0xE670: 0x8A84,
		    0xE671: 0x8AA8,
		    0xE672: 0x8AA1,
		    0xE673: 0x8A91,
		    0xE674: 0x8AA5,
		    0xE675: 0x8AA6,
		    0xE676: 0x8A9A,
		    0xE677: 0x8AA3,
		    0xE678: 0x8AC4,
		    0xE679: 0x8ACD,
		    0xE67A: 0x8AC2,
		    0xE67B: 0x8ADA,
		    0xE67C: 0x8AEB,
		    0xE67D: 0x8AF3,
		    0xE67E: 0x8AE7,
		    0xE680: 0x8AE4,
		    0xE681: 0x8AF1,
		    0xE682: 0x8B14,
		    0xE683: 0x8AE0,
		    0xE684: 0x8AE2,
		    0xE685: 0x8AF7,
		    0xE686: 0x8ADE,
		    0xE687: 0x8ADB,
		    0xE688: 0x8B0C,
		    0xE689: 0x8B07,
		    0xE68A: 0x8B1A,
		    0xE68B: 0x8AE1,
		    0xE68C: 0x8B16,
		    0xE68D: 0x8B10,
		    0xE68E: 0x8B17,
		    0xE68F: 0x8B20,
		    0xE690: 0x8B33,
		    0xE691: 0x97AB,
		    0xE692: 0x8B26,
		    0xE693: 0x8B2B,
		    0xE694: 0x8B3E,
		    0xE695: 0x8B28,
		    0xE696: 0x8B41,
		    0xE697: 0x8B4C,
		    0xE698: 0x8B4F,
		    0xE699: 0x8B4E,
		    0xE69A: 0x8B49,
		    0xE69B: 0x8B56,
		    0xE69C: 0x8B5B,
		    0xE69D: 0x8B5A,
		    0xE69E: 0x8B6B,
		    0xE69F: 0x8B5F,
		    0xE6A0: 0x8B6C,
		    0xE6A1: 0x8B6F,
		    0xE6A2: 0x8B74,
		    0xE6A3: 0x8B7D,
		    0xE6A4: 0x8B80,
		    0xE6A5: 0x8B8C,
		    0xE6A6: 0x8B8E,
		    0xE6A7: 0x8B92,
		    0xE6A8: 0x8B93,
		    0xE6A9: 0x8B96,
		    0xE6AA: 0x8B99,
		    0xE6AB: 0x8B9A,
		    0xE6AC: 0x8C3A,
		    0xE6AD: 0x8C41,
		    0xE6AE: 0x8C3F,
		    0xE6AF: 0x8C48,
		    0xE6B0: 0x8C4C,
		    0xE6B1: 0x8C4E,
		    0xE6B2: 0x8C50,
		    0xE6B3: 0x8C55,
		    0xE6B4: 0x8C62,
		    0xE6B5: 0x8C6C,
		    0xE6B6: 0x8C78,
		    0xE6B7: 0x8C7A,
		    0xE6B8: 0x8C82,
		    0xE6B9: 0x8C89,
		    0xE6BA: 0x8C85,
		    0xE6BB: 0x8C8A,
		    0xE6BC: 0x8C8D,
		    0xE6BD: 0x8C8E,
		    0xE6BE: 0x8C94,
		    0xE6BF: 0x8C7C,
		    0xE6C0: 0x8C98,
		    0xE6C1: 0x621D,
		    0xE6C2: 0x8CAD,
		    0xE6C3: 0x8CAA,
		    0xE6C4: 0x8CBD,
		    0xE6C5: 0x8CB2,
		    0xE6C6: 0x8CB3,
		    0xE6C7: 0x8CAE,
		    0xE6C8: 0x8CB6,
		    0xE6C9: 0x8CC8,
		    0xE6CA: 0x8CC1,
		    0xE6CB: 0x8CE4,
		    0xE6CC: 0x8CE3,
		    0xE6CD: 0x8CDA,
		    0xE6CE: 0x8CFD,
		    0xE6CF: 0x8CFA,
		    0xE6D0: 0x8CFB,
		    0xE6D1: 0x8D04,
		    0xE6D2: 0x8D05,
		    0xE6D3: 0x8D0A,
		    0xE6D4: 0x8D07,
		    0xE6D5: 0x8D0F,
		    0xE6D6: 0x8D0D,
		    0xE6D7: 0x8D10,
		    0xE6D8: 0x9F4E,
		    0xE6D9: 0x8D13,
		    0xE6DA: 0x8CCD,
		    0xE6DB: 0x8D14,
		    0xE6DC: 0x8D16,
		    0xE6DD: 0x8D67,
		    0xE6DE: 0x8D6D,
		    0xE6DF: 0x8D71,
		    0xE6E0: 0x8D73,
		    0xE6E1: 0x8D81,
		    0xE6E2: 0x8D99,
		    0xE6E3: 0x8DC2,
		    0xE6E4: 0x8DBE,
		    0xE6E5: 0x8DBA,
		    0xE6E6: 0x8DCF,
		    0xE6E7: 0x8DDA,
		    0xE6E8: 0x8DD6,
		    0xE6E9: 0x8DCC,
		    0xE6EA: 0x8DDB,
		    0xE6EB: 0x8DCB,
		    0xE6EC: 0x8DEA,
		    0xE6ED: 0x8DEB,
		    0xE6EE: 0x8DDF,
		    0xE6EF: 0x8DE3,
		    0xE6F0: 0x8DFC,
		    0xE6F1: 0x8E08,
		    0xE6F2: 0x8E09,
		    0xE6F3: 0x8DFF,
		    0xE6F4: 0x8E1D,
		    0xE6F5: 0x8E1E,
		    0xE6F6: 0x8E10,
		    0xE6F7: 0x8E1F,
		    0xE6F8: 0x8E42,
		    0xE6F9: 0x8E35,
		    0xE6FA: 0x8E30,
		    0xE6FB: 0x8E34,
		    0xE6FC: 0x8E4A,
		    0xE740: 0x8E47,
		    0xE741: 0x8E49,
		    0xE742: 0x8E4C,
		    0xE743: 0x8E50,
		    0xE744: 0x8E48,
		    0xE745: 0x8E59,
		    0xE746: 0x8E64,
		    0xE747: 0x8E60,
		    0xE748: 0x8E2A,
		    0xE749: 0x8E63,
		    0xE74A: 0x8E55,
		    0xE74B: 0x8E76,
		    0xE74C: 0x8E72,
		    0xE74D: 0x8E7C,
		    0xE74E: 0x8E81,
		    0xE74F: 0x8E87,
		    0xE750: 0x8E85,
		    0xE751: 0x8E84,
		    0xE752: 0x8E8B,
		    0xE753: 0x8E8A,
		    0xE754: 0x8E93,
		    0xE755: 0x8E91,
		    0xE756: 0x8E94,
		    0xE757: 0x8E99,
		    0xE758: 0x8EAA,
		    0xE759: 0x8EA1,
		    0xE75A: 0x8EAC,
		    0xE75B: 0x8EB0,
		    0xE75C: 0x8EC6,
		    0xE75D: 0x8EB1,
		    0xE75E: 0x8EBE,
		    0xE75F: 0x8EC5,
		    0xE760: 0x8EC8,
		    0xE761: 0x8ECB,
		    0xE762: 0x8EDB,
		    0xE763: 0x8EE3,
		    0xE764: 0x8EFC,
		    0xE765: 0x8EFB,
		    0xE766: 0x8EEB,
		    0xE767: 0x8EFE,
		    0xE768: 0x8F0A,
		    0xE769: 0x8F05,
		    0xE76A: 0x8F15,
		    0xE76B: 0x8F12,
		    0xE76C: 0x8F19,
		    0xE76D: 0x8F13,
		    0xE76E: 0x8F1C,
		    0xE76F: 0x8F1F,
		    0xE770: 0x8F1B,
		    0xE771: 0x8F0C,
		    0xE772: 0x8F26,
		    0xE773: 0x8F33,
		    0xE774: 0x8F3B,
		    0xE775: 0x8F39,
		    0xE776: 0x8F45,
		    0xE777: 0x8F42,
		    0xE778: 0x8F3E,
		    0xE779: 0x8F4C,
		    0xE77A: 0x8F49,
		    0xE77B: 0x8F46,
		    0xE77C: 0x8F4E,
		    0xE77D: 0x8F57,
		    0xE77E: 0x8F5C,
		    0xE780: 0x8F62,
		    0xE781: 0x8F63,
		    0xE782: 0x8F64,
		    0xE783: 0x8F9C,
		    0xE784: 0x8F9F,
		    0xE785: 0x8FA3,
		    0xE786: 0x8FAD,
		    0xE787: 0x8FAF,
		    0xE788: 0x8FB7,
		    0xE789: 0x8FDA,
		    0xE78A: 0x8FE5,
		    0xE78B: 0x8FE2,
		    0xE78C: 0x8FEA,
		    0xE78D: 0x8FEF,
		    0xE78E: 0x9087,
		    0xE78F: 0x8FF4,
		    0xE790: 0x9005,
		    0xE791: 0x8FF9,
		    0xE792: 0x8FFA,
		    0xE793: 0x9011,
		    0xE794: 0x9015,
		    0xE795: 0x9021,
		    0xE796: 0x900D,
		    0xE797: 0x901E,
		    0xE798: 0x9016,
		    0xE799: 0x900B,
		    0xE79A: 0x9027,
		    0xE79B: 0x9036,
		    0xE79C: 0x9035,
		    0xE79D: 0x9039,
		    0xE79E: 0x8FF8,
		    0xE79F: 0x904F,
		    0xE7A0: 0x9050,
		    0xE7A1: 0x9051,
		    0xE7A2: 0x9052,
		    0xE7A3: 0x900E,
		    0xE7A4: 0x9049,
		    0xE7A5: 0x903E,
		    0xE7A6: 0x9056,
		    0xE7A7: 0x9058,
		    0xE7A8: 0x905E,
		    0xE7A9: 0x9068,
		    0xE7AA: 0x906F,
		    0xE7AB: 0x9076,
		    0xE7AC: 0x96A8,
		    0xE7AD: 0x9072,
		    0xE7AE: 0x9082,
		    0xE7AF: 0x907D,
		    0xE7B0: 0x9081,
		    0xE7B1: 0x9080,
		    0xE7B2: 0x908A,
		    0xE7B3: 0x9089,
		    0xE7B4: 0x908F,
		    0xE7B5: 0x90A8,
		    0xE7B6: 0x90AF,
		    0xE7B7: 0x90B1,
		    0xE7B8: 0x90B5,
		    0xE7B9: 0x90E2,
		    0xE7BA: 0x90E4,
		    0xE7BB: 0x6248,
		    0xE7BC: 0x90DB,
		    0xE7BD: 0x9102,
		    0xE7BE: 0x9112,
		    0xE7BF: 0x9119,
		    0xE7C0: 0x9132,
		    0xE7C1: 0x9130,
		    0xE7C2: 0x914A,
		    0xE7C3: 0x9156,
		    0xE7C4: 0x9158,
		    0xE7C5: 0x9163,
		    0xE7C6: 0x9165,
		    0xE7C7: 0x9169,
		    0xE7C8: 0x9173,
		    0xE7C9: 0x9172,
		    0xE7CA: 0x918B,
		    0xE7CB: 0x9189,
		    0xE7CC: 0x9182,
		    0xE7CD: 0x91A2,
		    0xE7CE: 0x91AB,
		    0xE7CF: 0x91AF,
		    0xE7D0: 0x91AA,
		    0xE7D1: 0x91B5,
		    0xE7D2: 0x91B4,
		    0xE7D3: 0x91BA,
		    0xE7D4: 0x91C0,
		    0xE7D5: 0x91C1,
		    0xE7D6: 0x91C9,
		    0xE7D7: 0x91CB,
		    0xE7D8: 0x91D0,
		    0xE7D9: 0x91D6,
		    0xE7DA: 0x91DF,
		    0xE7DB: 0x91E1,
		    0xE7DC: 0x91DB,
		    0xE7DD: 0x91FC,
		    0xE7DE: 0x91F5,
		    0xE7DF: 0x91F6,
		    0xE7E0: 0x921E,
		    0xE7E1: 0x91FF,
		    0xE7E2: 0x9214,
		    0xE7E3: 0x922C,
		    0xE7E4: 0x9215,
		    0xE7E5: 0x9211,
		    0xE7E6: 0x925E,
		    0xE7E7: 0x9257,
		    0xE7E8: 0x9245,
		    0xE7E9: 0x9249,
		    0xE7EA: 0x9264,
		    0xE7EB: 0x9248,
		    0xE7EC: 0x9295,
		    0xE7ED: 0x923F,
		    0xE7EE: 0x924B,
		    0xE7EF: 0x9250,
		    0xE7F0: 0x929C,
		    0xE7F1: 0x9296,
		    0xE7F2: 0x9293,
		    0xE7F3: 0x929B,
		    0xE7F4: 0x925A,
		    0xE7F5: 0x92CF,
		    0xE7F6: 0x92B9,
		    0xE7F7: 0x92B7,
		    0xE7F8: 0x92E9,
		    0xE7F9: 0x930F,
		    0xE7FA: 0x92FA,
		    0xE7FB: 0x9344,
		    0xE7FC: 0x932E,
		    0xE840: 0x9319,
		    0xE841: 0x9322,
		    0xE842: 0x931A,
		    0xE843: 0x9323,
		    0xE844: 0x933A,
		    0xE845: 0x9335,
		    0xE846: 0x933B,
		    0xE847: 0x935C,
		    0xE848: 0x9360,
		    0xE849: 0x937C,
		    0xE84A: 0x936E,
		    0xE84B: 0x9356,
		    0xE84C: 0x93B0,
		    0xE84D: 0x93AC,
		    0xE84E: 0x93AD,
		    0xE84F: 0x9394,
		    0xE850: 0x93B9,
		    0xE851: 0x93D6,
		    0xE852: 0x93D7,
		    0xE853: 0x93E8,
		    0xE854: 0x93E5,
		    0xE855: 0x93D8,
		    0xE856: 0x93C3,
		    0xE857: 0x93DD,
		    0xE858: 0x93D0,
		    0xE859: 0x93C8,
		    0xE85A: 0x93E4,
		    0xE85B: 0x941A,
		    0xE85C: 0x9414,
		    0xE85D: 0x9413,
		    0xE85E: 0x9403,
		    0xE85F: 0x9407,
		    0xE860: 0x9410,
		    0xE861: 0x9436,
		    0xE862: 0x942B,
		    0xE863: 0x9435,
		    0xE864: 0x9421,
		    0xE865: 0x943A,
		    0xE866: 0x9441,
		    0xE867: 0x9452,
		    0xE868: 0x9444,
		    0xE869: 0x945B,
		    0xE86A: 0x9460,
		    0xE86B: 0x9462,
		    0xE86C: 0x945E,
		    0xE86D: 0x946A,
		    0xE86E: 0x9229,
		    0xE86F: 0x9470,
		    0xE870: 0x9475,
		    0xE871: 0x9477,
		    0xE872: 0x947D,
		    0xE873: 0x945A,
		    0xE874: 0x947C,
		    0xE875: 0x947E,
		    0xE876: 0x9481,
		    0xE877: 0x947F,
		    0xE878: 0x9582,
		    0xE879: 0x9587,
		    0xE87A: 0x958A,
		    0xE87B: 0x9594,
		    0xE87C: 0x9596,
		    0xE87D: 0x9598,
		    0xE87E: 0x9599,
		    0xE880: 0x95A0,
		    0xE881: 0x95A8,
		    0xE882: 0x95A7,
		    0xE883: 0x95AD,
		    0xE884: 0x95BC,
		    0xE885: 0x95BB,
		    0xE886: 0x95B9,
		    0xE887: 0x95BE,
		    0xE888: 0x95CA,
		    0xE889: 0x6FF6,
		    0xE88A: 0x95C3,
		    0xE88B: 0x95CD,
		    0xE88C: 0x95CC,
		    0xE88D: 0x95D5,
		    0xE88E: 0x95D4,
		    0xE88F: 0x95D6,
		    0xE890: 0x95DC,
		    0xE891: 0x95E1,
		    0xE892: 0x95E5,
		    0xE893: 0x95E2,
		    0xE894: 0x9621,
		    0xE895: 0x9628,
		    0xE896: 0x962E,
		    0xE897: 0x962F,
		    0xE898: 0x9642,
		    0xE899: 0x964C,
		    0xE89A: 0x964F,
		    0xE89B: 0x964B,
		    0xE89C: 0x9677,
		    0xE89D: 0x965C,
		    0xE89E: 0x965E,
		    0xE89F: 0x965D,
		    0xE8A0: 0x965F,
		    0xE8A1: 0x9666,
		    0xE8A2: 0x9672,
		    0xE8A3: 0x966C,
		    0xE8A4: 0x968D,
		    0xE8A5: 0x9698,
		    0xE8A6: 0x9695,
		    0xE8A7: 0x9697,
		    0xE8A8: 0x96AA,
		    0xE8A9: 0x96A7,
		    0xE8AA: 0x96B1,
		    0xE8AB: 0x96B2,
		    0xE8AC: 0x96B0,
		    0xE8AD: 0x96B4,
		    0xE8AE: 0x96B6,
		    0xE8AF: 0x96B8,
		    0xE8B0: 0x96B9,
		    0xE8B1: 0x96CE,
		    0xE8B2: 0x96CB,
		    0xE8B3: 0x96C9,
		    0xE8B4: 0x96CD,
		    0xE8B5: 0x894D,
		    0xE8B6: 0x96DC,
		    0xE8B7: 0x970D,
		    0xE8B8: 0x96D5,
		    0xE8B9: 0x96F9,
		    0xE8BA: 0x9704,
		    0xE8BB: 0x9706,
		    0xE8BC: 0x9708,
		    0xE8BD: 0x9713,
		    0xE8BE: 0x970E,
		    0xE8BF: 0x9711,
		    0xE8C0: 0x970F,
		    0xE8C1: 0x9716,
		    0xE8C2: 0x9719,
		    0xE8C3: 0x9724,
		    0xE8C4: 0x972A,
		    0xE8C5: 0x9730,
		    0xE8C6: 0x9739,
		    0xE8C7: 0x973D,
		    0xE8C8: 0x973E,
		    0xE8C9: 0x9744,
		    0xE8CA: 0x9746,
		    0xE8CB: 0x9748,
		    0xE8CC: 0x9742,
		    0xE8CD: 0x9749,
		    0xE8CE: 0x975C,
		    0xE8CF: 0x9760,
		    0xE8D0: 0x9764,
		    0xE8D1: 0x9766,
		    0xE8D2: 0x9768,
		    0xE8D3: 0x52D2,
		    0xE8D4: 0x976B,
		    0xE8D5: 0x9771,
		    0xE8D6: 0x9779,
		    0xE8D7: 0x9785,
		    0xE8D8: 0x977C,
		    0xE8D9: 0x9781,
		    0xE8DA: 0x977A,
		    0xE8DB: 0x9786,
		    0xE8DC: 0x978B,
		    0xE8DD: 0x978F,
		    0xE8DE: 0x9790,
		    0xE8DF: 0x979C,
		    0xE8E0: 0x97A8,
		    0xE8E1: 0x97A6,
		    0xE8E2: 0x97A3,
		    0xE8E3: 0x97B3,
		    0xE8E4: 0x97B4,
		    0xE8E5: 0x97C3,
		    0xE8E6: 0x97C6,
		    0xE8E7: 0x97C8,
		    0xE8E8: 0x97CB,
		    0xE8E9: 0x97DC,
		    0xE8EA: 0x97ED,
		    0xE8EB: 0x9F4F,
		    0xE8EC: 0x97F2,
		    0xE8ED: 0x7ADF,
		    0xE8EE: 0x97F6,
		    0xE8EF: 0x97F5,
		    0xE8F0: 0x980F,
		    0xE8F1: 0x980C,
		    0xE8F2: 0x9838,
		    0xE8F3: 0x9824,
		    0xE8F4: 0x9821,
		    0xE8F5: 0x9837,
		    0xE8F6: 0x983D,
		    0xE8F7: 0x9846,
		    0xE8F8: 0x984F,
		    0xE8F9: 0x984B,
		    0xE8FA: 0x986B,
		    0xE8FB: 0x986F,
		    0xE8FC: 0x9870,
		    0xE940: 0x9871,
		    0xE941: 0x9874,
		    0xE942: 0x9873,
		    0xE943: 0x98AA,
		    0xE944: 0x98AF,
		    0xE945: 0x98B1,
		    0xE946: 0x98B6,
		    0xE947: 0x98C4,
		    0xE948: 0x98C3,
		    0xE949: 0x98C6,
		    0xE94A: 0x98E9,
		    0xE94B: 0x98EB,
		    0xE94C: 0x9903,
		    0xE94D: 0x9909,
		    0xE94E: 0x9912,
		    0xE94F: 0x9914,
		    0xE950: 0x9918,
		    0xE951: 0x9921,
		    0xE952: 0x991D,
		    0xE953: 0x991E,
		    0xE954: 0x9924,
		    0xE955: 0x9920,
		    0xE956: 0x992C,
		    0xE957: 0x992E,
		    0xE958: 0x993D,
		    0xE959: 0x993E,
		    0xE95A: 0x9942,
		    0xE95B: 0x9949,
		    0xE95C: 0x9945,
		    0xE95D: 0x9950,
		    0xE95E: 0x994B,
		    0xE95F: 0x9951,
		    0xE960: 0x9952,
		    0xE961: 0x994C,
		    0xE962: 0x9955,
		    0xE963: 0x9997,
		    0xE964: 0x9998,
		    0xE965: 0x99A5,
		    0xE966: 0x99AD,
		    0xE967: 0x99AE,
		    0xE968: 0x99BC,
		    0xE969: 0x99DF,
		    0xE96A: 0x99DB,
		    0xE96B: 0x99DD,
		    0xE96C: 0x99D8,
		    0xE96D: 0x99D1,
		    0xE96E: 0x99ED,
		    0xE96F: 0x99EE,
		    0xE970: 0x99F1,
		    0xE971: 0x99F2,
		    0xE972: 0x99FB,
		    0xE973: 0x99F8,
		    0xE974: 0x9A01,
		    0xE975: 0x9A0F,
		    0xE976: 0x9A05,
		    0xE977: 0x99E2,
		    0xE978: 0x9A19,
		    0xE979: 0x9A2B,
		    0xE97A: 0x9A37,
		    0xE97B: 0x9A45,
		    0xE97C: 0x9A42,
		    0xE97D: 0x9A40,
		    0xE97E: 0x9A43,
		    0xE980: 0x9A3E,
		    0xE981: 0x9A55,
		    0xE982: 0x9A4D,
		    0xE983: 0x9A5B,
		    0xE984: 0x9A57,
		    0xE985: 0x9A5F,
		    0xE986: 0x9A62,
		    0xE987: 0x9A65,
		    0xE988: 0x9A64,
		    0xE989: 0x9A69,
		    0xE98A: 0x9A6B,
		    0xE98B: 0x9A6A,
		    0xE98C: 0x9AAD,
		    0xE98D: 0x9AB0,
		    0xE98E: 0x9ABC,
		    0xE98F: 0x9AC0,
		    0xE990: 0x9ACF,
		    0xE991: 0x9AD1,
		    0xE992: 0x9AD3,
		    0xE993: 0x9AD4,
		    0xE994: 0x9ADE,
		    0xE995: 0x9ADF,
		    0xE996: 0x9AE2,
		    0xE997: 0x9AE3,
		    0xE998: 0x9AE6,
		    0xE999: 0x9AEF,
		    0xE99A: 0x9AEB,
		    0xE99B: 0x9AEE,
		    0xE99C: 0x9AF4,
		    0xE99D: 0x9AF1,
		    0xE99E: 0x9AF7,
		    0xE99F: 0x9AFB,
		    0xE9A0: 0x9B06,
		    0xE9A1: 0x9B18,
		    0xE9A2: 0x9B1A,
		    0xE9A3: 0x9B1F,
		    0xE9A4: 0x9B22,
		    0xE9A5: 0x9B23,
		    0xE9A6: 0x9B25,
		    0xE9A7: 0x9B27,
		    0xE9A8: 0x9B28,
		    0xE9A9: 0x9B29,
		    0xE9AA: 0x9B2A,
		    0xE9AB: 0x9B2E,
		    0xE9AC: 0x9B2F,
		    0xE9AD: 0x9B32,
		    0xE9AE: 0x9B44,
		    0xE9AF: 0x9B43,
		    0xE9B0: 0x9B4F,
		    0xE9B1: 0x9B4D,
		    0xE9B2: 0x9B4E,
		    0xE9B3: 0x9B51,
		    0xE9B4: 0x9B58,
		    0xE9B5: 0x9B74,
		    0xE9B6: 0x9B93,
		    0xE9B7: 0x9B83,
		    0xE9B8: 0x9B91,
		    0xE9B9: 0x9B96,
		    0xE9BA: 0x9B97,
		    0xE9BB: 0x9B9F,
		    0xE9BC: 0x9BA0,
		    0xE9BD: 0x9BA8,
		    0xE9BE: 0x9BB4,
		    0xE9BF: 0x9BC0,
		    0xE9C0: 0x9BCA,
		    0xE9C1: 0x9BB9,
		    0xE9C2: 0x9BC6,
		    0xE9C3: 0x9BCF,
		    0xE9C4: 0x9BD1,
		    0xE9C5: 0x9BD2,
		    0xE9C6: 0x9BE3,
		    0xE9C7: 0x9BE2,
		    0xE9C8: 0x9BE4,
		    0xE9C9: 0x9BD4,
		    0xE9CA: 0x9BE1,
		    0xE9CB: 0x9C3A,
		    0xE9CC: 0x9BF2,
		    0xE9CD: 0x9BF1,
		    0xE9CE: 0x9BF0,
		    0xE9CF: 0x9C15,
		    0xE9D0: 0x9C14,
		    0xE9D1: 0x9C09,
		    0xE9D2: 0x9C13,
		    0xE9D3: 0x9C0C,
		    0xE9D4: 0x9C06,
		    0xE9D5: 0x9C08,
		    0xE9D6: 0x9C12,
		    0xE9D7: 0x9C0A,
		    0xE9D8: 0x9C04,
		    0xE9D9: 0x9C2E,
		    0xE9DA: 0x9C1B,
		    0xE9DB: 0x9C25,
		    0xE9DC: 0x9C24,
		    0xE9DD: 0x9C21,
		    0xE9DE: 0x9C30,
		    0xE9DF: 0x9C47,
		    0xE9E0: 0x9C32,
		    0xE9E1: 0x9C46,
		    0xE9E2: 0x9C3E,
		    0xE9E3: 0x9C5A,
		    0xE9E4: 0x9C60,
		    0xE9E5: 0x9C67,
		    0xE9E6: 0x9C76,
		    0xE9E7: 0x9C78,
		    0xE9E8: 0x9CE7,
		    0xE9E9: 0x9CEC,
		    0xE9EA: 0x9CF0,
		    0xE9EB: 0x9D09,
		    0xE9EC: 0x9D08,
		    0xE9ED: 0x9CEB,
		    0xE9EE: 0x9D03,
		    0xE9EF: 0x9D06,
		    0xE9F0: 0x9D2A,
		    0xE9F1: 0x9D26,
		    0xE9F2: 0x9DAF,
		    0xE9F3: 0x9D23,
		    0xE9F4: 0x9D1F,
		    0xE9F5: 0x9D44,
		    0xE9F6: 0x9D15,
		    0xE9F7: 0x9D12,
		    0xE9F8: 0x9D41,
		    0xE9F9: 0x9D3F,
		    0xE9FA: 0x9D3E,
		    0xE9FB: 0x9D46,
		    0xE9FC: 0x9D48,
		    0xEA40: 0x9D5D,
		    0xEA41: 0x9D5E,
		    0xEA42: 0x9D64,
		    0xEA43: 0x9D51,
		    0xEA44: 0x9D50,
		    0xEA45: 0x9D59,
		    0xEA46: 0x9D72,
		    0xEA47: 0x9D89,
		    0xEA48: 0x9D87,
		    0xEA49: 0x9DAB,
		    0xEA4A: 0x9D6F,
		    0xEA4B: 0x9D7A,
		    0xEA4C: 0x9D9A,
		    0xEA4D: 0x9DA4,
		    0xEA4E: 0x9DA9,
		    0xEA4F: 0x9DB2,
		    0xEA50: 0x9DC4,
		    0xEA51: 0x9DC1,
		    0xEA52: 0x9DBB,
		    0xEA53: 0x9DB8,
		    0xEA54: 0x9DBA,
		    0xEA55: 0x9DC6,
		    0xEA56: 0x9DCF,
		    0xEA57: 0x9DC2,
		    0xEA58: 0x9DD9,
		    0xEA59: 0x9DD3,
		    0xEA5A: 0x9DF8,
		    0xEA5B: 0x9DE6,
		    0xEA5C: 0x9DED,
		    0xEA5D: 0x9DEF,
		    0xEA5E: 0x9DFD,
		    0xEA5F: 0x9E1A,
		    0xEA60: 0x9E1B,
		    0xEA61: 0x9E1E,
		    0xEA62: 0x9E75,
		    0xEA63: 0x9E79,
		    0xEA64: 0x9E7D,
		    0xEA65: 0x9E81,
		    0xEA66: 0x9E88,
		    0xEA67: 0x9E8B,
		    0xEA68: 0x9E8C,
		    0xEA69: 0x9E92,
		    0xEA6A: 0x9E95,
		    0xEA6B: 0x9E91,
		    0xEA6C: 0x9E9D,
		    0xEA6D: 0x9EA5,
		    0xEA6E: 0x9EA9,
		    0xEA6F: 0x9EB8,
		    0xEA70: 0x9EAA,
		    0xEA71: 0x9EAD,
		    0xEA72: 0x9761,
		    0xEA73: 0x9ECC,
		    0xEA74: 0x9ECE,
		    0xEA75: 0x9ECF,
		    0xEA76: 0x9ED0,
		    0xEA77: 0x9ED4,
		    0xEA78: 0x9EDC,
		    0xEA79: 0x9EDE,
		    0xEA7A: 0x9EDD,
		    0xEA7B: 0x9EE0,
		    0xEA7C: 0x9EE5,
		    0xEA7D: 0x9EE8,
		    0xEA7E: 0x9EEF,
		    0xEA80: 0x9EF4,
		    0xEA81: 0x9EF6,
		    0xEA82: 0x9EF7,
		    0xEA83: 0x9EF9,
		    0xEA84: 0x9EFB,
		    0xEA85: 0x9EFC,
		    0xEA86: 0x9EFD,
		    0xEA87: 0x9F07,
		    0xEA88: 0x9F08,
		    0xEA89: 0x76B7,
		    0xEA8A: 0x9F15,
		    0xEA8B: 0x9F21,
		    0xEA8C: 0x9F2C,
		    0xEA8D: 0x9F3E,
		    0xEA8E: 0x9F4A,
		    0xEA8F: 0x9F52,
		    0xEA90: 0x9F54,
		    0xEA91: 0x9F63,
		    0xEA92: 0x9F5F,
		    0xEA93: 0x9F60,
		    0xEA94: 0x9F61,
		    0xEA95: 0x9F66,
		    0xEA96: 0x9F67,
		    0xEA97: 0x9F6C,
		    0xEA98: 0x9F6A,
		    0xEA99: 0x9F77,
		    0xEA9A: 0x9F72,
		    0xEA9B: 0x9F76,
		    0xEA9C: 0x9F95,
		    0xEA9D: 0x9F9C,
		    0xEA9E: 0x9FA0,
		    0xEA9F: 0x582F,
		    0xEAA0: 0x69C7,
		    0xEAA1: 0x9059,
		    0xEAA2: 0x7464,
		    0xEAA3: 0x51DC,
		    0xEAA4: 0x7199,
		};


		/***/ }),
		/* 9 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var GenericGF_1 = __webpack_require__(1);
		var GenericGFPoly_1 = __webpack_require__(2);
		function runEuclideanAlgorithm(field, a, b, R) {
		    var _a;
		    // Assume a's degree is >= b's
		    if (a.degree() < b.degree()) {
		        _a = [b, a], a = _a[0], b = _a[1];
		    }
		    var rLast = a;
		    var r = b;
		    var tLast = field.zero;
		    var t = field.one;
		    // Run Euclidean algorithm until r's degree is less than R/2
		    while (r.degree() >= R / 2) {
		        var rLastLast = rLast;
		        var tLastLast = tLast;
		        rLast = r;
		        tLast = t;
		        // Divide rLastLast by rLast, with quotient in q and remainder in r
		        if (rLast.isZero()) {
		            // Euclidean algorithm already terminated?
		            return null;
		        }
		        r = rLastLast;
		        var q = field.zero;
		        var denominatorLeadingTerm = rLast.getCoefficient(rLast.degree());
		        var dltInverse = field.inverse(denominatorLeadingTerm);
		        while (r.degree() >= rLast.degree() && !r.isZero()) {
		            var degreeDiff = r.degree() - rLast.degree();
		            var scale = field.multiply(r.getCoefficient(r.degree()), dltInverse);
		            q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
		            r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
		        }
		        t = q.multiplyPoly(tLast).addOrSubtract(tLastLast);
		        if (r.degree() >= rLast.degree()) {
		            return null;
		        }
		    }
		    var sigmaTildeAtZero = t.getCoefficient(0);
		    if (sigmaTildeAtZero === 0) {
		        return null;
		    }
		    var inverse = field.inverse(sigmaTildeAtZero);
		    return [t.multiply(inverse), r.multiply(inverse)];
		}
		function findErrorLocations(field, errorLocator) {
		    // This is a direct application of Chien's search
		    var numErrors = errorLocator.degree();
		    if (numErrors === 1) {
		        return [errorLocator.getCoefficient(1)];
		    }
		    var result = new Array(numErrors);
		    var errorCount = 0;
		    for (var i = 1; i < field.size && errorCount < numErrors; i++) {
		        if (errorLocator.evaluateAt(i) === 0) {
		            result[errorCount] = field.inverse(i);
		            errorCount++;
		        }
		    }
		    if (errorCount !== numErrors) {
		        return null;
		    }
		    return result;
		}
		function findErrorMagnitudes(field, errorEvaluator, errorLocations) {
		    // This is directly applying Forney's Formula
		    var s = errorLocations.length;
		    var result = new Array(s);
		    for (var i = 0; i < s; i++) {
		        var xiInverse = field.inverse(errorLocations[i]);
		        var denominator = 1;
		        for (var j = 0; j < s; j++) {
		            if (i !== j) {
		                denominator = field.multiply(denominator, GenericGF_1.addOrSubtractGF(1, field.multiply(errorLocations[j], xiInverse)));
		            }
		        }
		        result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
		        if (field.generatorBase !== 0) {
		            result[i] = field.multiply(result[i], xiInverse);
		        }
		    }
		    return result;
		}
		function decode(bytes, twoS) {
		    var outputBytes = new Uint8ClampedArray(bytes.length);
		    outputBytes.set(bytes);
		    var field = new GenericGF_1.default(0x011D, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1
		    var poly = new GenericGFPoly_1.default(field, outputBytes);
		    var syndromeCoefficients = new Uint8ClampedArray(twoS);
		    var error = false;
		    for (var s = 0; s < twoS; s++) {
		        var evaluation = poly.evaluateAt(field.exp(s + field.generatorBase));
		        syndromeCoefficients[syndromeCoefficients.length - 1 - s] = evaluation;
		        if (evaluation !== 0) {
		            error = true;
		        }
		    }
		    if (!error) {
		        return outputBytes;
		    }
		    var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
		    var sigmaOmega = runEuclideanAlgorithm(field, field.buildMonomial(twoS, 1), syndrome, twoS);
		    if (sigmaOmega === null) {
		        return null;
		    }
		    var errorLocations = findErrorLocations(field, sigmaOmega[0]);
		    if (errorLocations == null) {
		        return null;
		    }
		    var errorMagnitudes = findErrorMagnitudes(field, sigmaOmega[1], errorLocations);
		    for (var i = 0; i < errorLocations.length; i++) {
		        var position = outputBytes.length - 1 - field.log(errorLocations[i]);
		        if (position < 0) {
		            return null;
		        }
		        outputBytes[position] = GenericGF_1.addOrSubtractGF(outputBytes[position], errorMagnitudes[i]);
		    }
		    return outputBytes;
		}
		exports$1.decode = decode;


		/***/ }),
		/* 10 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.VERSIONS = [
		    {
		        infoBits: null,
		        versionNumber: 1,
		        alignmentPatternCenters: [],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 7,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 19 }],
		            },
		            {
		                ecCodewordsPerBlock: 10,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }],
		            },
		            {
		                ecCodewordsPerBlock: 13,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 13 }],
		            },
		            {
		                ecCodewordsPerBlock: 17,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 9 }],
		            },
		        ],
		    },
		    {
		        infoBits: null,
		        versionNumber: 2,
		        alignmentPatternCenters: [6, 18],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 10,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 34 }],
		            },
		            {
		                ecCodewordsPerBlock: 16,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 28 }],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 22 }],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }],
		            },
		        ],
		    },
		    {
		        infoBits: null,
		        versionNumber: 3,
		        alignmentPatternCenters: [6, 22],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 15,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 55 }],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 44 }],
		            },
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 17 }],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 13 }],
		            },
		        ],
		    },
		    {
		        infoBits: null,
		        versionNumber: 4,
		        alignmentPatternCenters: [6, 26],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 20,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 80 }],
		            },
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 32 }],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 24 }],
		            },
		            {
		                ecCodewordsPerBlock: 16,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 9 }],
		            },
		        ],
		    },
		    {
		        infoBits: null,
		        versionNumber: 5,
		        alignmentPatternCenters: [6, 30],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 108 }],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 43 }],
		            },
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 16 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 11 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 12 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: null,
		        versionNumber: 6,
		        alignmentPatternCenters: [6, 34],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 68 }],
		            },
		            {
		                ecCodewordsPerBlock: 16,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 27 }],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 19 }],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 15 }],
		            },
		        ],
		    },
		    {
		        infoBits: 0x07C94,
		        versionNumber: 7,
		        alignmentPatternCenters: [6, 22, 38],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 20,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 78 }],
		            },
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 31 }],
		            },
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 14 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 15 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 13 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 14 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x085BC,
		        versionNumber: 8,
		        alignmentPatternCenters: [6, 24, 42],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 97 }],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 38 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 39 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 18 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 19 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 14 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 15 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x09A99,
		        versionNumber: 9,
		        alignmentPatternCenters: [6, 26, 46],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 116 }],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 36 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 37 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 20,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 16 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 17 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 12 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 13 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x0A4D3,
		        versionNumber: 10,
		        alignmentPatternCenters: [6, 28, 50],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 18,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 68 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 69 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 43 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 44 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 19 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 20 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x0BBF6,
		        versionNumber: 11,
		        alignmentPatternCenters: [6, 30, 54],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 20,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 81 }],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 1, dataCodewordsPerBlock: 50 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 51 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 22 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 23 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 12 },
		                    { numBlocks: 8, dataCodewordsPerBlock: 13 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x0C762,
		        versionNumber: 12,
		        alignmentPatternCenters: [6, 32, 58],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 92 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 93 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 36 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 37 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 20 },
		                    { numBlocks: 6, dataCodewordsPerBlock: 21 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 7, dataCodewordsPerBlock: 14 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 15 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x0D847,
		        versionNumber: 13,
		        alignmentPatternCenters: [6, 34, 62],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 107 }],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 8, dataCodewordsPerBlock: 37 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 38 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 8, dataCodewordsPerBlock: 20 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 21 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 12, dataCodewordsPerBlock: 11 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 12 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x0E60D,
		        versionNumber: 14,
		        alignmentPatternCenters: [6, 26, 46, 66],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 115 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 116 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 40 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 41 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 20,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 16 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 17 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 12 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 13 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x0F928,
		        versionNumber: 15,
		        alignmentPatternCenters: [6, 26, 48, 70],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 22,
		                ecBlocks: [
		                    { numBlocks: 5, dataCodewordsPerBlock: 87 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 88 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 5, dataCodewordsPerBlock: 41 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 42 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 5, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 12 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 13 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x10B78,
		        versionNumber: 16,
		        alignmentPatternCenters: [6, 26, 50, 74],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 5, dataCodewordsPerBlock: 98 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 99 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 7, dataCodewordsPerBlock: 45 },
		                    { numBlocks: 3, dataCodewordsPerBlock: 46 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [
		                    { numBlocks: 15, dataCodewordsPerBlock: 19 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 20 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 13, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1145D,
		        versionNumber: 17,
		        alignmentPatternCenters: [6, 30, 54, 78],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 1, dataCodewordsPerBlock: 107 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 108 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 10, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 1, dataCodewordsPerBlock: 22 },
		                    { numBlocks: 15, dataCodewordsPerBlock: 23 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 14 },
		                    { numBlocks: 17, dataCodewordsPerBlock: 15 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x12A17,
		        versionNumber: 18,
		        alignmentPatternCenters: [6, 30, 56, 82],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 5, dataCodewordsPerBlock: 120 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 121 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 9, dataCodewordsPerBlock: 43 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 44 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 17, dataCodewordsPerBlock: 22 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 23 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 14 },
		                    { numBlocks: 19, dataCodewordsPerBlock: 15 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x13532,
		        versionNumber: 19,
		        alignmentPatternCenters: [6, 30, 58, 86],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 113 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 114 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 44 },
		                    { numBlocks: 11, dataCodewordsPerBlock: 45 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 17, dataCodewordsPerBlock: 21 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 22 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 9, dataCodewordsPerBlock: 13 },
		                    { numBlocks: 16, dataCodewordsPerBlock: 14 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x149A6,
		        versionNumber: 20,
		        alignmentPatternCenters: [6, 34, 62, 90],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 107 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 108 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 41 },
		                    { numBlocks: 13, dataCodewordsPerBlock: 42 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 15, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 15, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 10, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x15683,
		        versionNumber: 21,
		        alignmentPatternCenters: [6, 28, 50, 72, 94],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 116 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 117 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 42 }],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 17, dataCodewordsPerBlock: 22 },
		                    { numBlocks: 6, dataCodewordsPerBlock: 23 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 19, dataCodewordsPerBlock: 16 },
		                    { numBlocks: 6, dataCodewordsPerBlock: 17 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x168C9,
		        versionNumber: 22,
		        alignmentPatternCenters: [6, 26, 50, 74, 98],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 111 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 112 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 46 }],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 7, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 16, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 24,
		                ecBlocks: [{ numBlocks: 34, dataCodewordsPerBlock: 13 }],
		            },
		        ],
		    },
		    {
		        infoBits: 0x177EC,
		        versionNumber: 23,
		        alignmentPatternCenters: [6, 30, 54, 74, 102],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 121 },
		                    { numBlocks: 5, dataCodewordsPerBlock: 122 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 16, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x18EC4,
		        versionNumber: 24,
		        alignmentPatternCenters: [6, 28, 54, 80, 106],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 117 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 118 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 45 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 46 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 16, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 30, dataCodewordsPerBlock: 16 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 17 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x191E1,
		        versionNumber: 25,
		        alignmentPatternCenters: [6, 32, 58, 84, 110],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 26,
		                ecBlocks: [
		                    { numBlocks: 8, dataCodewordsPerBlock: 106 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 107 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 8, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 13, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 7, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 22, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 22, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 13, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1AFAB,
		        versionNumber: 26,
		        alignmentPatternCenters: [6, 30, 58, 86, 114],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 10, dataCodewordsPerBlock: 114 },
		                    { numBlocks: 2, dataCodewordsPerBlock: 115 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 19, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 28, dataCodewordsPerBlock: 22 },
		                    { numBlocks: 6, dataCodewordsPerBlock: 23 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 33, dataCodewordsPerBlock: 16 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 17 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1B08E,
		        versionNumber: 27,
		        alignmentPatternCenters: [6, 34, 62, 90, 118],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 8, dataCodewordsPerBlock: 122 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 123 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 22, dataCodewordsPerBlock: 45 },
		                    { numBlocks: 3, dataCodewordsPerBlock: 46 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 8, dataCodewordsPerBlock: 23 },
		                    { numBlocks: 26, dataCodewordsPerBlock: 24 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 12, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 28, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1CC1A,
		        versionNumber: 28,
		        alignmentPatternCenters: [6, 26, 50, 74, 98, 122],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 117 },
		                    { numBlocks: 10, dataCodewordsPerBlock: 118 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 3, dataCodewordsPerBlock: 45 },
		                    { numBlocks: 23, dataCodewordsPerBlock: 46 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 31, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 31, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1D33F,
		        versionNumber: 29,
		        alignmentPatternCenters: [6, 30, 54, 78, 102, 126],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 7, dataCodewordsPerBlock: 116 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 117 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 21, dataCodewordsPerBlock: 45 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 46 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 1, dataCodewordsPerBlock: 23 },
		                    { numBlocks: 37, dataCodewordsPerBlock: 24 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 19, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 26, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1ED75,
		        versionNumber: 30,
		        alignmentPatternCenters: [6, 26, 52, 78, 104, 130],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 5, dataCodewordsPerBlock: 115 },
		                    { numBlocks: 10, dataCodewordsPerBlock: 116 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 19, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 10, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 15, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 25, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 23, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 25, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x1F250,
		        versionNumber: 31,
		        alignmentPatternCenters: [6, 30, 56, 82, 108, 134],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 13, dataCodewordsPerBlock: 115 },
		                    { numBlocks: 3, dataCodewordsPerBlock: 116 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 29, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 42, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 23, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 28, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x209D5,
		        versionNumber: 32,
		        alignmentPatternCenters: [6, 34, 60, 86, 112, 138],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 115 }],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 10, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 23, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 10, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 35, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 19, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 35, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x216F0,
		        versionNumber: 33,
		        alignmentPatternCenters: [6, 30, 58, 86, 114, 142],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 17, dataCodewordsPerBlock: 115 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 116 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 14, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 21, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 29, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 19, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 11, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 46, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x228BA,
		        versionNumber: 34,
		        alignmentPatternCenters: [6, 34, 62, 90, 118, 146],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 13, dataCodewordsPerBlock: 115 },
		                    { numBlocks: 6, dataCodewordsPerBlock: 116 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 14, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 23, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 44, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 59, dataCodewordsPerBlock: 16 },
		                    { numBlocks: 1, dataCodewordsPerBlock: 17 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x2379F,
		        versionNumber: 35,
		        alignmentPatternCenters: [6, 30, 54, 78, 102, 126, 150],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 12, dataCodewordsPerBlock: 121 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 122 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 12, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 26, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 39, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 22, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 41, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x24B0B,
		        versionNumber: 36,
		        alignmentPatternCenters: [6, 24, 50, 76, 102, 128, 154],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 121 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 122 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 6, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 34, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 46, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 10, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 2, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 64, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x2542E,
		        versionNumber: 37,
		        alignmentPatternCenters: [6, 28, 54, 80, 106, 132, 158],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 17, dataCodewordsPerBlock: 122 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 123 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 29, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 49, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 10, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 24, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 46, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x26A64,
		        versionNumber: 38,
		        alignmentPatternCenters: [6, 32, 58, 84, 110, 136, 162],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 4, dataCodewordsPerBlock: 122 },
		                    { numBlocks: 18, dataCodewordsPerBlock: 123 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 13, dataCodewordsPerBlock: 46 },
		                    { numBlocks: 32, dataCodewordsPerBlock: 47 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 48, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 14, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 42, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 32, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x27541,
		        versionNumber: 39,
		        alignmentPatternCenters: [6, 26, 54, 82, 110, 138, 166],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 20, dataCodewordsPerBlock: 117 },
		                    { numBlocks: 4, dataCodewordsPerBlock: 118 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 40, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 7, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 43, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 22, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 10, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 67, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		    {
		        infoBits: 0x28C69,
		        versionNumber: 40,
		        alignmentPatternCenters: [6, 30, 58, 86, 114, 142, 170],
		        errorCorrectionLevels: [
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 19, dataCodewordsPerBlock: 118 },
		                    { numBlocks: 6, dataCodewordsPerBlock: 119 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 28,
		                ecBlocks: [
		                    { numBlocks: 18, dataCodewordsPerBlock: 47 },
		                    { numBlocks: 31, dataCodewordsPerBlock: 48 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 34, dataCodewordsPerBlock: 24 },
		                    { numBlocks: 34, dataCodewordsPerBlock: 25 },
		                ],
		            },
		            {
		                ecCodewordsPerBlock: 30,
		                ecBlocks: [
		                    { numBlocks: 20, dataCodewordsPerBlock: 15 },
		                    { numBlocks: 61, dataCodewordsPerBlock: 16 },
		                ],
		            },
		        ],
		    },
		];


		/***/ }),
		/* 11 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var BitMatrix_1 = __webpack_require__(0);
		function squareToQuadrilateral(p1, p2, p3, p4) {
		    var dx3 = p1.x - p2.x + p3.x - p4.x;
		    var dy3 = p1.y - p2.y + p3.y - p4.y;
		    if (dx3 === 0 && dy3 === 0) { // Affine
		        return {
		            a11: p2.x - p1.x,
		            a12: p2.y - p1.y,
		            a13: 0,
		            a21: p3.x - p2.x,
		            a22: p3.y - p2.y,
		            a23: 0,
		            a31: p1.x,
		            a32: p1.y,
		            a33: 1,
		        };
		    }
		    else {
		        var dx1 = p2.x - p3.x;
		        var dx2 = p4.x - p3.x;
		        var dy1 = p2.y - p3.y;
		        var dy2 = p4.y - p3.y;
		        var denominator = dx1 * dy2 - dx2 * dy1;
		        var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
		        var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
		        return {
		            a11: p2.x - p1.x + a13 * p2.x,
		            a12: p2.y - p1.y + a13 * p2.y,
		            a13: a13,
		            a21: p4.x - p1.x + a23 * p4.x,
		            a22: p4.y - p1.y + a23 * p4.y,
		            a23: a23,
		            a31: p1.x,
		            a32: p1.y,
		            a33: 1,
		        };
		    }
		}
		function quadrilateralToSquare(p1, p2, p3, p4) {
		    // Here, the adjoint serves as the inverse:
		    var sToQ = squareToQuadrilateral(p1, p2, p3, p4);
		    return {
		        a11: sToQ.a22 * sToQ.a33 - sToQ.a23 * sToQ.a32,
		        a12: sToQ.a13 * sToQ.a32 - sToQ.a12 * sToQ.a33,
		        a13: sToQ.a12 * sToQ.a23 - sToQ.a13 * sToQ.a22,
		        a21: sToQ.a23 * sToQ.a31 - sToQ.a21 * sToQ.a33,
		        a22: sToQ.a11 * sToQ.a33 - sToQ.a13 * sToQ.a31,
		        a23: sToQ.a13 * sToQ.a21 - sToQ.a11 * sToQ.a23,
		        a31: sToQ.a21 * sToQ.a32 - sToQ.a22 * sToQ.a31,
		        a32: sToQ.a12 * sToQ.a31 - sToQ.a11 * sToQ.a32,
		        a33: sToQ.a11 * sToQ.a22 - sToQ.a12 * sToQ.a21,
		    };
		}
		function times(a, b) {
		    return {
		        a11: a.a11 * b.a11 + a.a21 * b.a12 + a.a31 * b.a13,
		        a12: a.a12 * b.a11 + a.a22 * b.a12 + a.a32 * b.a13,
		        a13: a.a13 * b.a11 + a.a23 * b.a12 + a.a33 * b.a13,
		        a21: a.a11 * b.a21 + a.a21 * b.a22 + a.a31 * b.a23,
		        a22: a.a12 * b.a21 + a.a22 * b.a22 + a.a32 * b.a23,
		        a23: a.a13 * b.a21 + a.a23 * b.a22 + a.a33 * b.a23,
		        a31: a.a11 * b.a31 + a.a21 * b.a32 + a.a31 * b.a33,
		        a32: a.a12 * b.a31 + a.a22 * b.a32 + a.a32 * b.a33,
		        a33: a.a13 * b.a31 + a.a23 * b.a32 + a.a33 * b.a33,
		    };
		}
		function extract(image, location) {
		    var qToS = quadrilateralToSquare({ x: 3.5, y: 3.5 }, { x: location.dimension - 3.5, y: 3.5 }, { x: location.dimension - 6.5, y: location.dimension - 6.5 }, { x: 3.5, y: location.dimension - 3.5 });
		    var sToQ = squareToQuadrilateral(location.topLeft, location.topRight, location.alignmentPattern, location.bottomLeft);
		    var transform = times(sToQ, qToS);
		    var matrix = BitMatrix_1.BitMatrix.createEmpty(location.dimension, location.dimension);
		    var mappingFunction = function (x, y) {
		        var denominator = transform.a13 * x + transform.a23 * y + transform.a33;
		        return {
		            x: (transform.a11 * x + transform.a21 * y + transform.a31) / denominator,
		            y: (transform.a12 * x + transform.a22 * y + transform.a32) / denominator,
		        };
		    };
		    for (var y = 0; y < location.dimension; y++) {
		        for (var x = 0; x < location.dimension; x++) {
		            var xValue = x + 0.5;
		            var yValue = y + 0.5;
		            var sourcePixel = mappingFunction(xValue, yValue);
		            matrix.set(x, y, image.get(Math.floor(sourcePixel.x), Math.floor(sourcePixel.y)));
		        }
		    }
		    return {
		        matrix: matrix,
		        mappingFunction: mappingFunction,
		    };
		}
		exports$1.extract = extract;


		/***/ }),
		/* 12 */
		/***/ (function(module, exports$1, __webpack_require__) {

		Object.defineProperty(exports$1, "__esModule", { value: true });
		var MAX_FINDERPATTERNS_TO_SEARCH = 4;
		var MIN_QUAD_RATIO = 0.5;
		var MAX_QUAD_RATIO = 1.5;
		var distance = function (a, b) { return Math.sqrt(Math.pow((b.x - a.x), 2) + Math.pow((b.y - a.y), 2)); };
		function sum(values) {
		    return values.reduce(function (a, b) { return a + b; });
		}
		// Takes three finder patterns and organizes them into topLeft, topRight, etc
		function reorderFinderPatterns(pattern1, pattern2, pattern3) {
		    var _a, _b, _c, _d;
		    // Find distances between pattern centers
		    var oneTwoDistance = distance(pattern1, pattern2);
		    var twoThreeDistance = distance(pattern2, pattern3);
		    var oneThreeDistance = distance(pattern1, pattern3);
		    var bottomLeft;
		    var topLeft;
		    var topRight;
		    // Assume one closest to other two is B; A and C will just be guesses at first
		    if (twoThreeDistance >= oneTwoDistance && twoThreeDistance >= oneThreeDistance) {
		        _a = [pattern2, pattern1, pattern3], bottomLeft = _a[0], topLeft = _a[1], topRight = _a[2];
		    }
		    else if (oneThreeDistance >= twoThreeDistance && oneThreeDistance >= oneTwoDistance) {
		        _b = [pattern1, pattern2, pattern3], bottomLeft = _b[0], topLeft = _b[1], topRight = _b[2];
		    }
		    else {
		        _c = [pattern1, pattern3, pattern2], bottomLeft = _c[0], topLeft = _c[1], topRight = _c[2];
		    }
		    // Use cross product to figure out whether bottomLeft (A) and topRight (C) are correct or flipped in relation to topLeft (B)
		    // This asks whether BC x BA has a positive z component, which is the arrangement we want. If it's negative, then
		    // we've got it flipped around and should swap topRight and bottomLeft.
		    if (((topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y)) - ((topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x)) < 0) {
		        _d = [topRight, bottomLeft], bottomLeft = _d[0], topRight = _d[1];
		    }
		    return { bottomLeft: bottomLeft, topLeft: topLeft, topRight: topRight };
		}
		// Computes the dimension (number of modules on a side) of the QR Code based on the position of the finder patterns
		function computeDimension(topLeft, topRight, bottomLeft, matrix) {
		    var moduleSize = (sum(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + // Divide by 7 since the ratio is 1:1:3:1:1
		        sum(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 +
		        sum(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 +
		        sum(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) / 4;
		    if (moduleSize < 1) {
		        throw new Error("Invalid module size");
		    }
		    var topDimension = Math.round(distance(topLeft, topRight) / moduleSize);
		    var sideDimension = Math.round(distance(topLeft, bottomLeft) / moduleSize);
		    var dimension = Math.floor((topDimension + sideDimension) / 2) + 7;
		    switch (dimension % 4) {
		        case 0:
		            dimension++;
		            break;
		        case 2:
		            dimension--;
		            break;
		    }
		    return { dimension: dimension, moduleSize: moduleSize };
		}
		// Takes an origin point and an end point and counts the sizes of the black white run from the origin towards the end point.
		// Returns an array of elements, representing the pixel size of the black white run.
		// Uses a variant of http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
		function countBlackWhiteRunTowardsPoint(origin, end, matrix, length) {
		    var switchPoints = [{ x: Math.floor(origin.x), y: Math.floor(origin.y) }];
		    var steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);
		    var fromX;
		    var fromY;
		    var toX;
		    var toY;
		    if (steep) {
		        fromX = Math.floor(origin.y);
		        fromY = Math.floor(origin.x);
		        toX = Math.floor(end.y);
		        toY = Math.floor(end.x);
		    }
		    else {
		        fromX = Math.floor(origin.x);
		        fromY = Math.floor(origin.y);
		        toX = Math.floor(end.x);
		        toY = Math.floor(end.y);
		    }
		    var dx = Math.abs(toX - fromX);
		    var dy = Math.abs(toY - fromY);
		    var error = Math.floor(-dx / 2);
		    var xStep = fromX < toX ? 1 : -1;
		    var yStep = fromY < toY ? 1 : -1;
		    var currentPixel = true;
		    // Loop up until x == toX, but not beyond
		    for (var x = fromX, y = fromY; x !== toX + xStep; x += xStep) {
		        // Does current pixel mean we have moved white to black or vice versa?
		        // Scanning black in state 0,2 and white in state 1, so if we find the wrong
		        // color, advance to next state or end if we are in state 2 already
		        var realX = steep ? y : x;
		        var realY = steep ? x : y;
		        if (matrix.get(realX, realY) !== currentPixel) {
		            currentPixel = !currentPixel;
		            switchPoints.push({ x: realX, y: realY });
		            if (switchPoints.length === length + 1) {
		                break;
		            }
		        }
		        error += dy;
		        if (error > 0) {
		            if (y === toY) {
		                break;
		            }
		            y += yStep;
		            error -= dx;
		        }
		    }
		    var distances = [];
		    for (var i = 0; i < length; i++) {
		        if (switchPoints[i] && switchPoints[i + 1]) {
		            distances.push(distance(switchPoints[i], switchPoints[i + 1]));
		        }
		        else {
		            distances.push(0);
		        }
		    }
		    return distances;
		}
		// Takes an origin point and an end point and counts the sizes of the black white run in the origin point
		// along the line that intersects with the end point. Returns an array of elements, representing the pixel sizes
		// of the black white run. Takes a length which represents the number of switches from black to white to look for.
		function countBlackWhiteRun(origin, end, matrix, length) {
		    var _a;
		    var rise = end.y - origin.y;
		    var run = end.x - origin.x;
		    var towardsEnd = countBlackWhiteRunTowardsPoint(origin, end, matrix, Math.ceil(length / 2));
		    var awayFromEnd = countBlackWhiteRunTowardsPoint(origin, { x: origin.x - run, y: origin.y - rise }, matrix, Math.ceil(length / 2));
		    var middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1; // Substract one so we don't double count a pixel
		    return (_a = awayFromEnd.concat(middleValue)).concat.apply(_a, towardsEnd);
		}
		// Takes in a black white run and an array of expected ratios. Returns the average size of the run as well as the "error" -
		// that is the amount the run diverges from the expected ratio
		function scoreBlackWhiteRun(sequence, ratios) {
		    var averageSize = sum(sequence) / sum(ratios);
		    var error = 0;
		    ratios.forEach(function (ratio, i) {
		        error += Math.pow((sequence[i] - ratio * averageSize), 2);
		    });
		    return { averageSize: averageSize, error: error };
		}
		// Takes an X,Y point and an array of sizes and scores the point against those ratios.
		// For example for a finder pattern takes the ratio list of 1:1:3:1:1 and checks horizontal, vertical and diagonal ratios
		// against that.
		function scorePattern(point, ratios, matrix) {
		    try {
		        var horizontalRun = countBlackWhiteRun(point, { x: -1, y: point.y }, matrix, ratios.length);
		        var verticalRun = countBlackWhiteRun(point, { x: point.x, y: -1 }, matrix, ratios.length);
		        var topLeftPoint = {
		            x: Math.max(0, point.x - point.y) - 1,
		            y: Math.max(0, point.y - point.x) - 1,
		        };
		        var topLeftBottomRightRun = countBlackWhiteRun(point, topLeftPoint, matrix, ratios.length);
		        var bottomLeftPoint = {
		            x: Math.min(matrix.width, point.x + point.y) + 1,
		            y: Math.min(matrix.height, point.y + point.x) + 1,
		        };
		        var bottomLeftTopRightRun = countBlackWhiteRun(point, bottomLeftPoint, matrix, ratios.length);
		        var horzError = scoreBlackWhiteRun(horizontalRun, ratios);
		        var vertError = scoreBlackWhiteRun(verticalRun, ratios);
		        var diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);
		        var diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);
		        var ratioError = Math.sqrt(horzError.error * horzError.error +
		            vertError.error * vertError.error +
		            diagDownError.error * diagDownError.error +
		            diagUpError.error * diagUpError.error);
		        var avgSize = (horzError.averageSize + vertError.averageSize + diagDownError.averageSize + diagUpError.averageSize) / 4;
		        var sizeError = (Math.pow((horzError.averageSize - avgSize), 2) +
		            Math.pow((vertError.averageSize - avgSize), 2) +
		            Math.pow((diagDownError.averageSize - avgSize), 2) +
		            Math.pow((diagUpError.averageSize - avgSize), 2)) / avgSize;
		        return ratioError + sizeError;
		    }
		    catch (_a) {
		        return Infinity;
		    }
		}
		function recenterLocation(matrix, p) {
		    var leftX = Math.round(p.x);
		    while (matrix.get(leftX, Math.round(p.y))) {
		        leftX--;
		    }
		    var rightX = Math.round(p.x);
		    while (matrix.get(rightX, Math.round(p.y))) {
		        rightX++;
		    }
		    var x = (leftX + rightX) / 2;
		    var topY = Math.round(p.y);
		    while (matrix.get(Math.round(x), topY)) {
		        topY--;
		    }
		    var bottomY = Math.round(p.y);
		    while (matrix.get(Math.round(x), bottomY)) {
		        bottomY++;
		    }
		    var y = (topY + bottomY) / 2;
		    return { x: x, y: y };
		}
		function locate(matrix) {
		    var finderPatternQuads = [];
		    var activeFinderPatternQuads = [];
		    var alignmentPatternQuads = [];
		    var activeAlignmentPatternQuads = [];
		    var _loop_1 = function (y) {
		        var length_1 = 0;
		        var lastBit = false;
		        var scans = [0, 0, 0, 0, 0];
		        var _loop_2 = function (x) {
		            var v = matrix.get(x, y);
		            if (v === lastBit) {
		                length_1++;
		            }
		            else {
		                scans = [scans[1], scans[2], scans[3], scans[4], length_1];
		                length_1 = 1;
		                lastBit = v;
		                // Do the last 5 color changes ~ match the expected ratio for a finder pattern? 1:1:3:1:1 of b:w:b:w:b
		                var averageFinderPatternBlocksize = sum(scans) / 7;
		                var validFinderPattern = Math.abs(scans[0] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize &&
		                    Math.abs(scans[1] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize &&
		                    Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) < 3 * averageFinderPatternBlocksize &&
		                    Math.abs(scans[3] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize &&
		                    Math.abs(scans[4] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize &&
		                    !v; // And make sure the current pixel is white since finder patterns are bordered in white
		                // Do the last 3 color changes ~ match the expected ratio for an alignment pattern? 1:1:1 of w:b:w
		                var averageAlignmentPatternBlocksize = sum(scans.slice(-3)) / 3;
		                var validAlignmentPattern = Math.abs(scans[2] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize &&
		                    Math.abs(scans[3] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize &&
		                    Math.abs(scans[4] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize &&
		                    v; // Is the current pixel black since alignment patterns are bordered in black
		                if (validFinderPattern) {
		                    // Compute the start and end x values of the large center black square
		                    var endX_1 = x - scans[3] - scans[4];
		                    var startX_1 = endX_1 - scans[2];
		                    var line = { startX: startX_1, endX: endX_1, y: y };
		                    // Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with
		                    // that line as the starting point.
		                    var matchingQuads = activeFinderPatternQuads.filter(function (q) {
		                        return (startX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX) ||
		                            (endX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX) ||
		                            (startX_1 <= q.bottom.startX && endX_1 >= q.bottom.endX && ((scans[2] / (q.bottom.endX - q.bottom.startX)) < MAX_QUAD_RATIO &&
		                                (scans[2] / (q.bottom.endX - q.bottom.startX)) > MIN_QUAD_RATIO));
		                    });
		                    if (matchingQuads.length > 0) {
		                        matchingQuads[0].bottom = line;
		                    }
		                    else {
		                        activeFinderPatternQuads.push({ top: line, bottom: line });
		                    }
		                }
		                if (validAlignmentPattern) {
		                    // Compute the start and end x values of the center black square
		                    var endX_2 = x - scans[4];
		                    var startX_2 = endX_2 - scans[3];
		                    var line = { startX: startX_2, y: y, endX: endX_2 };
		                    // Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with
		                    // that line as the starting point.
		                    var matchingQuads = activeAlignmentPatternQuads.filter(function (q) {
		                        return (startX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX) ||
		                            (endX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX) ||
		                            (startX_2 <= q.bottom.startX && endX_2 >= q.bottom.endX && ((scans[2] / (q.bottom.endX - q.bottom.startX)) < MAX_QUAD_RATIO &&
		                                (scans[2] / (q.bottom.endX - q.bottom.startX)) > MIN_QUAD_RATIO));
		                    });
		                    if (matchingQuads.length > 0) {
		                        matchingQuads[0].bottom = line;
		                    }
		                    else {
		                        activeAlignmentPatternQuads.push({ top: line, bottom: line });
		                    }
		                }
		            }
		        };
		        for (var x = -1; x <= matrix.width; x++) {
		            _loop_2(x);
		        }
		        finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function (q) { return q.bottom.y !== y && q.bottom.y - q.top.y >= 2; }));
		        activeFinderPatternQuads = activeFinderPatternQuads.filter(function (q) { return q.bottom.y === y; });
		        alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads.filter(function (q) { return q.bottom.y !== y; }));
		        activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(function (q) { return q.bottom.y === y; });
		    };
		    for (var y = 0; y <= matrix.height; y++) {
		        _loop_1(y);
		    }
		    finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function (q) { return q.bottom.y - q.top.y >= 2; }));
		    alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads);
		    var finderPatternGroups = finderPatternQuads
		        .filter(function (q) { return q.bottom.y - q.top.y >= 2; }) // All quads must be at least 2px tall since the center square is larger than a block
		        .map(function (q) {
		        var x = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
		        var y = (q.top.y + q.bottom.y + 1) / 2;
		        if (!matrix.get(Math.round(x), Math.round(y))) {
		            return;
		        }
		        var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
		        var size = sum(lengths) / lengths.length;
		        var score = scorePattern({ x: Math.round(x), y: Math.round(y) }, [1, 1, 3, 1, 1], matrix);
		        return { score: score, x: x, y: y, size: size };
		    })
		        .filter(function (q) { return !!q; }) // Filter out any rejected quads from above
		        .sort(function (a, b) { return a.score - b.score; })
		        // Now take the top finder pattern options and try to find 2 other options with a similar size.
		        .map(function (point, i, finderPatterns) {
		        if (i > MAX_FINDERPATTERNS_TO_SEARCH) {
		            return null;
		        }
		        var otherPoints = finderPatterns
		            .filter(function (p, ii) { return i !== ii; })
		            .map(function (p) { return ({ x: p.x, y: p.y, score: p.score + (Math.pow((p.size - point.size), 2)) / point.size, size: p.size }); })
		            .sort(function (a, b) { return a.score - b.score; });
		        if (otherPoints.length < 2) {
		            return null;
		        }
		        var score = point.score + otherPoints[0].score + otherPoints[1].score;
		        return { points: [point].concat(otherPoints.slice(0, 2)), score: score };
		    })
		        .filter(function (q) { return !!q; }) // Filter out any rejected finder patterns from above
		        .sort(function (a, b) { return a.score - b.score; });
		    if (finderPatternGroups.length === 0) {
		        return null;
		    }
		    var _a = reorderFinderPatterns(finderPatternGroups[0].points[0], finderPatternGroups[0].points[1], finderPatternGroups[0].points[2]), topRight = _a.topRight, topLeft = _a.topLeft, bottomLeft = _a.bottomLeft;
		    var alignment = findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft);
		    var result = [];
		    if (alignment) {
		        result.push({
		            alignmentPattern: { x: alignment.alignmentPattern.x, y: alignment.alignmentPattern.y },
		            bottomLeft: { x: bottomLeft.x, y: bottomLeft.y },
		            dimension: alignment.dimension,
		            topLeft: { x: topLeft.x, y: topLeft.y },
		            topRight: { x: topRight.x, y: topRight.y },
		        });
		    }
		    // We normally use the center of the quads as the location of the tracking points, which is optimal for most cases and will account
		    // for a skew in the image. However, In some cases, a slight skew might not be real and instead be caused by image compression
		    // errors and/or low resolution. For those cases, we'd be better off centering the point exactly in the middle of the black area. We
		    // compute and return the location data for the naively centered points as it is little additional work and allows for multiple
		    // attempts at decoding harder images.
		    var midTopRight = recenterLocation(matrix, topRight);
		    var midTopLeft = recenterLocation(matrix, topLeft);
		    var midBottomLeft = recenterLocation(matrix, bottomLeft);
		    var centeredAlignment = findAlignmentPattern(matrix, alignmentPatternQuads, midTopRight, midTopLeft, midBottomLeft);
		    if (centeredAlignment) {
		        result.push({
		            alignmentPattern: { x: centeredAlignment.alignmentPattern.x, y: centeredAlignment.alignmentPattern.y },
		            bottomLeft: { x: midBottomLeft.x, y: midBottomLeft.y },
		            topLeft: { x: midTopLeft.x, y: midTopLeft.y },
		            topRight: { x: midTopRight.x, y: midTopRight.y },
		            dimension: centeredAlignment.dimension,
		        });
		    }
		    if (result.length === 0) {
		        return null;
		    }
		    return result;
		}
		exports$1.locate = locate;
		function findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft) {
		    var _a;
		    // Now that we've found the three finder patterns we can determine the blockSize and the size of the QR code.
		    // We'll use these to help find the alignment pattern but also later when we do the extraction.
		    var dimension;
		    var moduleSize;
		    try {
		        (_a = computeDimension(topLeft, topRight, bottomLeft, matrix), dimension = _a.dimension, moduleSize = _a.moduleSize);
		    }
		    catch (e) {
		        return null;
		    }
		    // Now find the alignment pattern
		    var bottomRightFinderPattern = {
		        x: topRight.x - topLeft.x + bottomLeft.x,
		        y: topRight.y - topLeft.y + bottomLeft.y,
		    };
		    var modulesBetweenFinderPatterns = ((distance(topLeft, bottomLeft) + distance(topLeft, topRight)) / 2 / moduleSize);
		    var correctionToTopLeft = 1 - (3 / modulesBetweenFinderPatterns);
		    var expectedAlignmentPattern = {
		        x: topLeft.x + correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),
		        y: topLeft.y + correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y),
		    };
		    var alignmentPatterns = alignmentPatternQuads
		        .map(function (q) {
		        var x = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
		        var y = (q.top.y + q.bottom.y + 1) / 2;
		        if (!matrix.get(Math.floor(x), Math.floor(y))) {
		            return;
		        }
		        var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, (q.bottom.y - q.top.y + 1)];
		        sum(lengths) / lengths.length;
		        var sizeScore = scorePattern({ x: Math.floor(x), y: Math.floor(y) }, [1, 1, 1], matrix);
		        var score = sizeScore + distance({ x: x, y: y }, expectedAlignmentPattern);
		        return { x: x, y: y, score: score };
		    })
		        .filter(function (v) { return !!v; })
		        .sort(function (a, b) { return a.score - b.score; });
		    // If there are less than 15 modules between finder patterns it's a version 1 QR code and as such has no alignmemnt pattern
		    // so we can only use our best guess.
		    var alignmentPattern = modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length ? alignmentPatterns[0] : expectedAlignmentPattern;
		    return { alignmentPattern: alignmentPattern, dimension: dimension };
		}


		/***/ })
		/******/ ])["default"];
		}); 
	} (jsQR$2));
	return jsQR$2.exports;
}

var jsQRExports = requireJsQR();
const jsQR = /*@__PURE__*/getDefaultExportFromCjs(jsQRExports);

function scanImage(image) {
  try {
    const { width, height, data } = image.bitmap;
    const clamped = new Uint8ClampedArray(data);
    const code = jsQR(clamped, width, height, { inversionAttempts: "attemptBoth" });
    return !!code;
  } catch {
    return false;
  }
}
async function detectQrCode(url) {
  if (!url) return false;
  try {
    const image = await Jimp.read(url);
    if (scanImage(image)) return true;
    const processed = image.clone();
    processed.greyscale().contrast(0.5).normalize();
    if (scanImage(processed)) return true;
    const { width, height } = image.bitmap;
    let scaled = null;
    if (width > 1200 || height > 1200) {
      scaled = image.clone().resize({ w: width / 2 });
    } else if (width < 200 || height < 200) {
      scaled = image.clone().scale(2);
    }
    if (scaled) {
      if (scanImage(scaled)) return true;
      scaled.greyscale().contrast(0.4).normalize();
      if (scanImage(scaled)) return true;
    }
    return false;
  } catch (e) {
    return false;
  }
}

function extractAt(raw) {
  const m = raw.match(/\[CQ:at,qq=(\d+)\]/);
  return m ? m[1] : null;
}
function extractQQ(text) {
  const m = text.match(/(\d{5,12})/);
  return m ? m[1] : null;
}
function getTarget(raw, textAfterCmd) {
  return extractAt(raw) || extractQQ(textAfterCmd);
}
async function isAdminOrOwner(groupId, userId) {
  if (pluginState.isOwner(userId)) return true;
  const key = `${groupId}:${userId}`;
  const settings = pluginState.getGroupSettings(groupId);
  const cacheSeconds = settings.adminCacheSeconds !== void 0 ? settings.adminCacheSeconds : 60;
  if (cacheSeconds > 0) {
    const cached = pluginState.adminCache.get(key);
    if (cached && Date.now() < cached.expire) {
      return cached.role === "admin" || cached.role === "owner";
    }
  }
  const info = await pluginState.callApi("get_group_member_info", { group_id: groupId, user_id: userId });
  const role = info?.role || "member";
  if (cacheSeconds > 0) {
    pluginState.adminCache.set(key, { role, expire: Date.now() + cacheSeconds * 1e3 });
  }
  return role === "admin" || role === "owner";
}
function saveConfig(ctx) {
  try {
    if (ctx?.configPath) {
      const mainConfig = { ...pluginState.config, groups: {} };
      fs.writeFileSync(ctx.configPath, JSON.stringify(mainConfig, null, 2), "utf-8");
      const dataDir = path.join(path.dirname(ctx.configPath), "data");
      const groupsDir = path.join(dataDir, "groups");
      if (!fs.existsSync(groupsDir)) fs.mkdirSync(groupsDir, { recursive: true });
      for (const [gid, cfg] of Object.entries(pluginState.config.groups)) {
        if (cfg) {
          const groupDir = path.join(groupsDir, gid);
          if (!fs.existsSync(groupDir)) fs.mkdirSync(groupDir, { recursive: true });
          const qaList = cfg.qaList || [];
          const configToSave = { ...cfg };
          delete configToSave.qaList;
          fs.writeFileSync(path.join(groupDir, "config.json"), JSON.stringify(configToSave, null, 2), "utf-8");
          fs.writeFileSync(path.join(groupDir, "qa.json"), JSON.stringify(qaList, null, 2), "utf-8");
        }
      }
    }
  } catch (e) {
    pluginState.log("error", `ä¿å­˜é…ç½®å¤±è´¥: ${e}`);
  }
}
async function handleCommand(event, ctx) {
  const raw = event.raw_message || "";
  const text = raw.replace(/\[CQ:[^\]]+\]/g, "").trim();
  const userId = String(event.user_id);
  String(event.self_id);
  if (event.message_type === "private") {
    pluginState.debug(`æ”¶åˆ°ç§èŠæŒ‡ä»¤: [${userId}] ${text}`);
    if (text === "å¸®åŠ©" || text === "èœå•") {
      const isOwner2 = pluginState.isOwner(userId);
      let menu = `ğŸ›¡ï¸ GroupGuard ç§èŠç®¡ç†é¢æ¿
--------------------------
`;
      if (isOwner2) {
        menu += `ğŸ“ æˆæƒç®¡ç† (ä¸»äººæƒé™):
â€¢ æˆæƒ <ç¾¤å·> <å¤©æ•°/æ°¸ä¹…> (é»˜è®¤ä¸“ä¸šç‰ˆ/ä¼ä¸šç‰ˆ)
â€¢ å›æ”¶æˆæƒ <ç¾¤å·>
â€¢ æŸ¥è¯¢æˆæƒ <ç¾¤å·>

âš™ï¸ å…¨å±€è®¾ç½® (ä¸»äººæƒé™):
â€¢ å…¨å±€é»‘åå• <QQ> (è·¨ç¾¤å°ç¦)
â€¢ å…¨å±€ç™½åå• <QQ> (è±å…æ£€æµ‹)
â€¢ å¼€å¯/å…³é—­å…¨å±€é˜²æ’¤å› (ç§èŠæ¥æ”¶æ’¤å›æ¶ˆæ¯)
`;
      } else {
        menu += `æ‚¨å½“å‰ä»…æœ‰æ™®é€šç”¨æˆ·æƒé™ï¼Œæ— æ³•æ‰§è¡Œç®¡ç†æŒ‡ä»¤ã€‚
å¦‚éœ€æˆæƒç¾¤ç»„ï¼Œè¯·è”ç³»æœºå™¨äººä¸»äººã€‚`;
      }
      menu += `
--------------------------
å½“å‰ç‰ˆæœ¬: ${pluginState.version}`;
      await pluginState.sendPrivateMsg(userId, menu);
      return true;
    }
    const isOwner = pluginState.isOwner(userId);
    if (!isOwner) {
      pluginState.log("warn", `éä¸»äººç”¨æˆ· ${userId} å°è¯•æ‰§è¡Œç§èŠç®¡ç†æŒ‡ä»¤ [${text}] è¢«æ‹¦æˆª`);
      await pluginState.sendPrivateMsg(userId, "æƒé™ä¸è¶³ï¼šè¯¥æŒ‡ä»¤ä»…é™æœºå™¨äººä¸»äººä½¿ç”¨ã€‚");
      return true;
    }
    try {
      if (text.startsWith("æˆæƒ ")) {
        const parts = text.split(" ");
        if (parts.length < 3) {
          await pluginState.sendPrivateMsg(userId, "æ ¼å¼é”™è¯¯ï¼šæˆæƒ <ç¾¤å·> <å¤©æ•°>");
          return true;
        }
        const targetGroup = parts[1];
        const duration = parts[2];
        const days = duration === "æ°¸ä¹…" ? -1 : parseInt(duration);
        if (!/^\d+$/.test(targetGroup)) {
          await pluginState.sendPrivateMsg(userId, "ç¾¤å·æ ¼å¼é”™è¯¯");
          return true;
        }
        authManager.grantLicense(targetGroup, days, days === -1 ? "enterprise" : "pro");
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, `å·²æˆæƒç¾¤ ${targetGroup} ${duration === "æ°¸ä¹…" ? "æ°¸ä¹…" : days + "å¤©"}`);
        return true;
      }
      if (text.startsWith("å›æ”¶æˆæƒ ")) {
        const targetGroup = text.split(" ")[1];
        if (!targetGroup) return true;
        authManager.revokeLicense(targetGroup);
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, `å·²å›æ”¶ç¾¤ ${targetGroup} æˆæƒ`);
        return true;
      }
      if (text.startsWith("æŸ¥è¯¢æˆæƒ ")) {
        const targetGroup = text.split(" ")[1];
        if (!targetGroup) return true;
        const license2 = authManager.getGroupLicense(targetGroup);
        if (!license2) {
          await pluginState.sendPrivateMsg(userId, `ç¾¤ ${targetGroup} æœªæˆæƒ`);
        } else {
          const remaining = license2.expireTime === -1 ? "æ°¸ä¹…" : Math.ceil((license2.expireTime - Date.now()) / 864e5) + "å¤©";
          await pluginState.sendPrivateMsg(userId, `ç¾¤ ${targetGroup} (${license2.level})
å‰©ä½™æ—¶é—´: ${remaining}`);
        }
        return true;
      }
      if (text === "å¸®åŠ©" || text === "èœå•") {
        return true;
      }
      if (text === "å¼€å¯è°ƒè¯•") {
        pluginState.config.debug = true;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, "è°ƒè¯•æ¨¡å¼å·²å¼€å¯");
        return true;
      }
      if (text === "å…³é—­è°ƒè¯•") {
        pluginState.config.debug = false;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, "è°ƒè¯•æ¨¡å¼å·²å…³é—­");
        return true;
      }
      if (text === "å¼€å¯éšæœºåç¼€") {
        pluginState.config.global.randomSuffix = true;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, "å…¨å±€éšæœºåç¼€å·²å¼€å¯");
        return true;
      }
      if (text === "å…³é—­éšæœºåç¼€") {
        pluginState.config.global.randomSuffix = false;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, "å…¨å±€éšæœºåç¼€å·²å…³é—­");
        return true;
      }
      if (text.startsWith("è®¾ç½®éšæœºå»¶è¿Ÿ ")) {
        const parts = text.split(/\s+/);
        if (parts.length < 3) {
          await pluginState.sendPrivateMsg(userId, "æ ¼å¼ï¼šè®¾ç½®éšæœºå»¶è¿Ÿ <æœ€å°ms> <æœ€å¤§ms>");
          return true;
        }
        const min = parseInt(parts[1]);
        const max = parseInt(parts[2]);
        if (isNaN(min) || isNaN(max)) {
          await pluginState.sendPrivateMsg(userId, "è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—");
          return true;
        }
        pluginState.config.global.randomDelayMin = min;
        pluginState.config.global.randomDelayMax = max;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, `å…¨å±€éšæœºå»¶è¿Ÿå·²è®¾ç½®ä¸º ${min}-${max}ms`);
        return true;
      }
      if (text === "å¼€å¯å…¨å±€è‡ªèº«æ’¤å›") {
        pluginState.config.global.autoRecallSelf = true;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, "å…¨å±€è‡ªèº«æ’¤å›å·²å¼€å¯");
        return true;
      }
      if (text === "å…³é—­å…¨å±€è‡ªèº«æ’¤å›") {
        pluginState.config.global.autoRecallSelf = false;
        saveConfig(ctx);
        await pluginState.sendPrivateMsg(userId, "å…¨å±€è‡ªèº«æ’¤å›å·²å…³é—­");
        return true;
      }
      if (text.startsWith("å¤šç¾¤å¹¿æ’­ ")) {
        const content = text.slice(5).trim();
        if (!content) {
          await pluginState.sendPrivateMsg(userId, "è¯·è¾“å…¥å¹¿æ’­å†…å®¹");
          return true;
        }
        await pluginState.sendPrivateMsg(userId, "å¼€å§‹å¹¿æ’­ï¼Œè¯·ç¨å€™...");
        let groups = [];
        try {
          groups = await pluginState.callApi("get_group_list", {}) || [];
        } catch (e) {
          await pluginState.sendPrivateMsg(userId, `è·å–ç¾¤åˆ—è¡¨å¤±è´¥: ${e}`);
          return true;
        }
        let success = 0;
        let fail = 0;
        for (const group of groups) {
          const gid = String(group.group_id);
          const license2 = authManager.getGroupLicense(gid);
          if (!license2) continue;
          try {
            await pluginState.sendGroupText(gid, `ã€å…¨å‘˜é€šçŸ¥ã€‘
${content}`);
            success++;
            await new Promise((r) => setTimeout(r, 1500));
          } catch {
            fail++;
          }
        }
        await pluginState.sendPrivateMsg(userId, `å¹¿æ’­å®Œæˆã€‚
æˆåŠŸ: ${success}
å¤±è´¥: ${fail}`);
        return true;
      }
      pluginState.log("warn", `ä¸»äººç§èŠå‘é€äº†æœªçŸ¥æŒ‡ä»¤: [${text}]`);
      await pluginState.sendPrivateMsg(userId, `æœªçŸ¥æŒ‡ä»¤: ${text}
è¯·å‘é€â€œèœå•â€æŸ¥çœ‹å¯ç”¨æŒ‡ä»¤ã€‚`);
      return true;
    } catch (e) {
      pluginState.log("error", `å¤„ç†ç§èŠæŒ‡ä»¤å‡ºé”™: ${e}`);
      await pluginState.sendPrivateMsg(userId, `æŒ‡ä»¤æ‰§è¡Œå‡ºé”™: ${e}`);
      return true;
    }
  }
  const groupId = String(event.group_id);
  if (text === "æŸ¥è¯¢æˆæƒ" || text === "æˆæƒçŠ¶æ€") {
    const license2 = authManager.getGroupLicense(groupId);
    if (!license2) {
      await pluginState.sendGroupText(groupId, "âš ï¸ æœ¬ç¾¤å½“å‰æœªè·å¾—æˆæƒ\nåŠŸèƒ½å—é™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜è·å–æˆæƒã€‚");
    } else {
      const remaining = license2.expireTime === -1 ? "æ°¸ä¹…" : Math.ceil((license2.expireTime - Date.now()) / 864e5) + "å¤©";
      await pluginState.sendGroupText(groupId, `âœ… æœ¬ç¾¤å·²æˆæƒ (${license2.level === "enterprise" ? "ä¼ä¸šç‰ˆ" : "ä¸“ä¸šç‰ˆ"})
ğŸ“… å‰©ä½™æœ‰æ•ˆæœŸ: ${remaining}`);
    }
    return true;
  }
  const license = authManager.getGroupLicense(groupId);
  if (!license) {
    return false;
  }
  if (text === "ç¾¤ç®¡å¸®åŠ©" || text === "ç¾¤ç®¡èœå•") {
    return false;
  }
  if (text === "é£æ§è®¾ç½®" || text === "å®‰å…¨è®¾ç½®") {
    const selfId2 = String(event.self_id || "");
    const nodes = [
      { type: "node", data: { nickname: "ğŸ›¡ï¸ é£æ§é…ç½®", user_id: selfId2, content: [{ type: "text", data: { text: RISK_CONTROL_MENU } }] } }
    ];
    await pluginState.callApi("send_group_forward_msg", { group_id: groupId, messages: nodes });
    return true;
  }
  if (text.startsWith("è®¾ç½®æƒé™ç¼“å­˜ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const seconds = parseInt(text.slice(7));
    if (isNaN(seconds) || seconds < 0) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„ç§’æ•° (0=å…³é—­)");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].adminCacheSeconds = seconds;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®ç®¡ç†å‘˜æƒé™ç¼“å­˜æ—¶é—´ä¸º ${seconds} ç§’`);
    return true;
  }
  if (text.startsWith("æˆæƒ ") || text.startsWith("å›æ”¶æˆæƒ") || text.startsWith("æŸ¥è¯¢æˆæƒ") || text === "æˆæƒæŸ¥è¯¢") {
    return false;
  }
  if (text.startsWith("è­¦å‘Š ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(3).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šè­¦å‘Š@æŸäºº");
      return true;
    }
    const count = (await dbQuery.getWarning(groupId, target) || 0) + 1;
    await dbQuery.setWarning(groupId, target, count);
    const settings = pluginState.getGroupSettings(groupId);
    const limit = settings.warningLimit || 3;
    if (count >= limit) {
      await dbQuery.setWarning(groupId, target, 0);
      if (settings.warningAction === "kick") {
        await pluginState.callApi("set_group_kick", { group_id: groupId, user_id: target, reject_add_request: false });
        await pluginState.sendGroupText(groupId, `ç”¨æˆ· ${target} è­¦å‘Šæ¬¡æ•°è¾¾åˆ°ä¸Šé™ (${count}/${limit})ï¼Œå·²è¢«è¸¢å‡ºã€‚`);
      } else {
        const banTime = (settings.filterBanMinutes || 10) * 60;
        await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: target, duration: banTime });
        await pluginState.sendGroupText(groupId, `ç”¨æˆ· ${target} è­¦å‘Šæ¬¡æ•°è¾¾åˆ°ä¸Šé™ (${count}/${limit})ï¼Œç¦è¨€ ${settings.filterBanMinutes} åˆ†é’Ÿã€‚`);
      }
    } else {
      await pluginState.sendGroupText(groupId, `ç”¨æˆ· ${target} å·²è¢«è­¦å‘Šï¼Œå½“å‰æ¬¡æ•°ï¼š${count}/${limit}`);
    }
    return true;
  }
  if (text.startsWith("æ¸…é™¤è­¦å‘Š ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const target = getTarget(raw, text.slice(5).trim());
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    const count = await dbQuery.getWarning(groupId, target);
    if (count > 0) {
      await dbQuery.setWarning(groupId, target, 0);
      await pluginState.sendGroupText(groupId, `å·²æ¸…é™¤ç”¨æˆ· ${target} çš„è­¦å‘Šè®°å½•`);
    } else {
      await pluginState.sendGroupText(groupId, `è¯¥ç”¨æˆ·æ— è­¦å‘Šè®°å½•`);
    }
    return true;
  }
  if (text.startsWith("æŸ¥çœ‹è­¦å‘Š ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const target = getTarget(raw, text.slice(5).trim());
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    const count = await dbQuery.getWarning(groupId, target);
    const settings = pluginState.getGroupSettings(groupId);
    await pluginState.sendGroupText(groupId, `ç”¨æˆ· ${target} å½“å‰è­¦å‘Šæ¬¡æ•°ï¼š${count}/${settings.warningLimit || 3}`);
    return true;
  }
  if (text.startsWith("å¼€å¯å®µç¦ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!authManager.checkFeature(groupId, "curfew")) {
      await pluginState.sendGroupText(groupId, "å®µç¦åŠŸèƒ½ä»…é™ä¸“ä¸šç‰ˆ/ä¼ä¸šç‰ˆä½¿ç”¨ï¼Œè¯·è´­ä¹°æˆæƒã€‚");
      return true;
    }
    const parts = text.split(/\s+/);
    if (parts.length < 3) {
      await pluginState.sendGroupText(groupId, "æ ¼å¼ï¼šå¼€å¯å®µç¦ 00:00 06:00");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    gs.enableCurfew = true;
    gs.curfewStart = parts[1];
    gs.curfewEnd = parts[2];
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²å¼€å¯å®µç¦ï¼šæ¯å¤© ${gs.curfewStart} è‡³ ${gs.curfewEnd} å…¨å‘˜ç¦è¨€`);
    return true;
  }
  if (text === "å…³é—­å®µç¦") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      pluginState.config.groups[groupId].enableCurfew = false;
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, "å·²å…³é—­å®µç¦");
    return true;
  }
  if (text.startsWith("å¼€å¯åŠŸèƒ½ ") || text.startsWith("å…³é—­åŠŸèƒ½ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const isEnable = text.startsWith("å¼€å¯åŠŸèƒ½ ");
    const feature = text.slice(5).trim();
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    switch (feature) {
      case "é—®ç­”":
        gs.disableQA = !isEnable;
        break;
      case "ç­¾åˆ°":
        gs.disableSignin = !isEnable;
        break;
      case "æŠ½å¥–":
        gs.disableLottery = !isEnable;
        break;
      case "é‚€è¯·ç»Ÿè®¡":
        gs.disableInvite = !isEnable;
        break;
      case "æ´»è·ƒç»Ÿè®¡":
        gs.disableActivity = !isEnable;
        break;
      case "è‡ªåŠ¨åŒæ„":
        gs.autoApprove = isEnable;
        break;
      case "å…¥ç¾¤éªŒè¯":
        gs.enableVerify = isEnable;
        break;
      case "åˆ·å±æ£€æµ‹":
        gs.spamDetect = isEnable;
        break;
      case "é€€ç¾¤æ‹‰é»‘":
        gs.leaveBlacklist = isEnable;
        break;
      case "æš—å·å›è½":
        gs.enableAutoApproveAfterPassphraseOff = isEnable;
        break;
      default:
        await pluginState.sendGroupText(groupId, "æœªçŸ¥åŠŸèƒ½ã€‚æ”¯æŒï¼šé—®ç­”ã€ç­¾åˆ°ã€æŠ½å¥–ã€é‚€è¯·ç»Ÿè®¡ã€æ´»è·ƒç»Ÿè®¡ã€è‡ªåŠ¨åŒæ„ã€å…¥ç¾¤éªŒè¯ã€åˆ·å±æ£€æµ‹ã€é€€ç¾¤æ‹‰é»‘ã€æš—å·å›è½");
        return true;
    }
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²${isEnable ? "å¼€å¯" : "å…³é—­"}åŠŸèƒ½ï¼š${feature}`);
    return true;
  }
  if (text.startsWith("è®¾ç½®æš—å· ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const passphrase = text.slice(5).trim();
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    if (passphrase === "å…³é—­" || passphrase === "æ— ") {
      gs.entryPassphrase = "";
      await pluginState.sendGroupText(groupId, "å·²å…³é—­å…¥ç¾¤æš—å·éªŒè¯");
    } else {
      gs.entryPassphrase = passphrase;
      await pluginState.sendGroupText(groupId, `å·²è®¾ç½®å…¥ç¾¤æš—å·ä¸ºï¼š${passphrase}`);
    }
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®å…¥ç¾¤æš—å·ä¸ºï¼š${passphrase}`);
    return true;
  }
  if (text.startsWith("è®¾ç½®å¤è¯»é˜ˆå€¼ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const val = parseInt(text.slice(7).trim());
    if (isNaN(val) || val < 0) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­— (0è¡¨ç¤ºå…³é—­)");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].repeatThreshold = val;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®å¤è¯»é˜ˆå€¼: ${val} (è¿ç»­${val}æ¡ç›¸åŒå†…å®¹è§¦å‘æ£€æµ‹)`);
    return true;
  }
  if (text.startsWith("å±è”½ ") || text.startsWith("å–æ¶ˆå±è”½ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const isBlock = text.startsWith("å±è”½ ");
    const type = text.slice(isBlock ? 3 : 5).trim();
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    if (!gs.msgFilter) gs.msgFilter = { ...pluginState.config.global.msgFilter };
    switch (type) {
      case "å›¾ç‰‡":
        gs.msgFilter.blockImage = isBlock;
        break;
      case "è§†é¢‘":
        gs.msgFilter.blockVideo = isBlock;
        break;
      case "è¯­éŸ³":
        gs.msgFilter.blockRecord = isBlock;
        break;
      case "é“¾æ¥":
        gs.msgFilter.blockUrl = isBlock;
        break;
      case "äºŒç»´ç ":
        gs.msgFilter.blockQr = isBlock;
        break;
      case "åç‰‡":
        gs.msgFilter.blockContact = isBlock;
        break;
      case "å°ç¨‹åº":
        gs.msgFilter.blockLightApp = isBlock;
        break;
      case "è½¬å‘":
        gs.msgFilter.blockForward = isBlock;
        break;
      default:
        await pluginState.sendGroupText(groupId, "æœªçŸ¥ç±»å‹ã€‚æ”¯æŒï¼šå›¾ç‰‡ã€è§†é¢‘ã€è¯­éŸ³ã€é“¾æ¥ã€äºŒç»´ç ã€åç‰‡ã€å°ç¨‹åºã€è½¬å‘");
        return true;
    }
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²${isBlock ? "å±è”½" : "å–æ¶ˆå±è”½"}ï¼š${type}`);
    return true;
  }
  if (text.startsWith("è®¾ç½®æ¬¢è¿è¯ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const msg = text.slice(6).trim();
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].welcomeMessage = msg;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "æ¬¢è¿è¯å·²æ›´æ–°");
    return true;
  }
  if (text.startsWith("å®šæ—¶ä»»åŠ¡ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!authManager.checkFeature(groupId, "scheduled_tasks")) {
      await pluginState.sendGroupText(groupId, "å®šæ—¶ä»»åŠ¡ä»…é™ä¸“ä¸šç‰ˆ/ä¼ä¸šç‰ˆä½¿ç”¨ï¼Œè¯·è´­ä¹°æˆæƒã€‚");
      return true;
    }
    const parts = text.split(/\s+/);
    if (parts.length < 3) {
      await pluginState.sendGroupText(groupId, "æ ¼å¼ï¼šå®šæ—¶ä»»åŠ¡ 08:00 å†…å®¹");
      return true;
    }
    const time = parts[1];
    if (!/^\d{2}:\d{2}$/.test(time)) {
      await pluginState.sendGroupText(groupId, "æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º HH:mm");
      return true;
    }
    const content = parts.slice(2).join(" ");
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    if (!gs.scheduledTasks) gs.scheduledTasks = [];
    const id = Date.now().toString(36);
    gs.scheduledTasks.push({
      id,
      cron: time,
      type: "text",
      content
    });
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²æ·»åŠ å®šæ—¶ä»»åŠ¡ (ID:${id})ï¼šæ¯å¤© ${time} å‘é€ "${content}"`);
    return true;
  }
  if (text.startsWith("åˆ é™¤å®šæ—¶ä»»åŠ¡ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const id = text.slice(7).trim();
    if (!pluginState.config.groups[groupId]?.scheduledTasks) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æ— å®šæ—¶ä»»åŠ¡");
      return true;
    }
    const gs = pluginState.config.groups[groupId];
    const before = gs.scheduledTasks.length;
    gs.scheduledTasks = gs.scheduledTasks.filter((t) => t.id !== id);
    if (gs.scheduledTasks.length === before) {
      await pluginState.sendGroupText(groupId, "æœªæ‰¾åˆ°è¯¥IDçš„ä»»åŠ¡");
    } else {
      saveConfig(ctx);
      await pluginState.sendGroupText(groupId, "å·²åˆ é™¤å®šæ—¶ä»»åŠ¡");
    }
    return true;
  }
  if (text === "å®šæ—¶åˆ—è¡¨") {
    const tasks = pluginState.config.groups[groupId]?.scheduledTasks || [];
    if (!tasks.length) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æ— å®šæ—¶ä»»åŠ¡");
      return true;
    }
    const list = tasks.map((t) => `[${t.id}] ${t.cron} -> ${t.content}`).join("\n");
    await pluginState.sendGroupText(groupId, `å®šæ—¶ä»»åŠ¡åˆ—è¡¨ï¼š
${list}`);
    return true;
  }
  if (text === "ç­¾åˆ°") {
    if (pluginState.getGroupSettings(groupId).disableSignin) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤ç­¾åˆ°åŠŸèƒ½å·²å…³é—­");
      return true;
    }
    let userSignin = await dbQuery.getSignin(groupId, userId);
    if (!userSignin) {
      userSignin = { lastSignin: 0, days: 0, points: 0 };
    }
    const now = /* @__PURE__ */ new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
    if (userSignin.lastSignin >= today) {
      await pluginState.sendGroupMsg(groupId, [
        { type: "at", data: { qq: userId } },
        { type: "text", data: { text: " ä½ ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†ï¼Œæ˜å¤©å†æ¥å§ï¼" } }
      ]);
      return true;
    }
    const yesterday = today - 864e5;
    if (userSignin.lastSignin >= yesterday && userSignin.lastSignin < today) {
      userSignin.days++;
    } else {
      userSignin.days = 1;
    }
    const settings = pluginState.getGroupSettings(groupId);
    const min = settings.signinMin || 10;
    const max = settings.signinMax || 50;
    const base = Math.floor(Math.random() * (max - min + 1)) + min;
    const bonus = Math.min(userSignin.days, 10);
    const points = base + bonus;
    userSignin.points += points;
    userSignin.lastSignin = Date.now();
    await dbQuery.updateSignin(groupId, userId, userSignin);
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` ç­¾åˆ°æˆåŠŸï¼
è·å¾—ç§¯åˆ†ï¼š${points}
å½“å‰ç§¯åˆ†ï¼š${userSignin.points}
è¿ç»­ç­¾åˆ°ï¼š${userSignin.days}å¤©` } }
    ]);
    return true;
  }
  if (text === "ç­¾åˆ°æ¦œ") {
    const data = await dbQuery.getAllSignin(groupId);
    if (!Object.keys(data).length) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æš‚æ— ç­¾åˆ°æ•°æ®");
      return true;
    }
    const now = /* @__PURE__ */ new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
    const list = Object.entries(data).filter(([_, v]) => v.lastSignin >= today).sort((a, b) => b[1].lastSignin - a[1].lastSignin).slice(0, 10);
    if (!list.length) {
      await pluginState.sendGroupText(groupId, "ä»Šå¤©è¿˜æ²¡æœ‰äººç­¾åˆ°å“¦");
      return true;
    }
    const content = list.map((item, i) => {
      const time = new Date(item[1].lastSignin).toLocaleTimeString();
      return `${i + 1}. ${item[0]} (${time})`;
    }).join("\n");
    await pluginState.sendGroupText(groupId, `ğŸ“… ä»Šæ—¥ç­¾åˆ°æ¦œ
${content}`);
    return true;
  }
  if (text === "æˆ‘çš„ç§¯åˆ†") {
    const data = await dbQuery.getSignin(groupId, userId);
    const points = data ? data.points : 0;
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` ä½ çš„å½“å‰ç§¯åˆ†ï¼š${points}` } }
    ]);
    return true;
  }
  if (text.startsWith("æŸ¥å°å·")) {
    const rest = text.slice(3).trim();
    let targetQQ = rest;
    if (!targetQQ || !/^\d+$/.test(targetQQ)) {
      targetQQ = getTarget(raw, rest) || "";
    }
    if (!targetQQ) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šè¦æŸ¥è¯¢çš„QQå·ï¼Œä¾‹å¦‚ï¼šæŸ¥å°å· 12345 æˆ– æŸ¥å°å· @æŸäºº");
      return true;
    }
    if (!/^\d{5,13}$/.test(targetQQ)) {
      await pluginState.sendGroupText(groupId, "QQå·æ ¼å¼é”™è¯¯ (éœ€5-13ä½æ•°å­—)");
      return true;
    }
    await pluginState.sendGroupText(groupId, `æ­£åœ¨æŸ¥è¯¢ QQ: ${targetQQ} çš„å°å·çŠ¶æ€...`);
    try {
      const apiUrl = `https://yun.4png.com/api/query.html?token=c7739372694acf36&qq=${targetQQ}`;
      const response = await fetch(apiUrl);
      const data = await response.json();
      if (data.code === 200) {
        const banMsg = data.data?.banmsg || "æ— è¯¦ç»†å°ç¦ä¿¡æ¯";
        await pluginState.sendGroupText(groupId, `âœ… æŸ¥è¯¢æˆåŠŸï¼š${data.msg || "æœªçŸ¥çŠ¶æ€"}
ğŸ“ è¯¦ç»†ä¿¡æ¯ï¼š${banMsg}`);
      } else if (data.code === 404) {
        await pluginState.sendGroupText(groupId, `â“ æœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯ [404]
ğŸ“¢ QQ ${targetQQ} å¯èƒ½æœªç»‘å®šã€Šè‹±é›„è”ç›Ÿã€‹è´¦å·ï¼Œæˆ–å½“å‰æ— å°ç¦è®°å½•`);
      } else if (data.code === 403) {
        await pluginState.sendGroupText(groupId, `ğŸ›‘ è¯·æ±‚è¢«æ‹’ç» [403]ï¼šå¯èƒ½å› æŸ¥è¯¢è¿‡äºé¢‘ç¹æˆ–IPå—é™`);
      } else if (data.code === 429) {
        await pluginState.sendGroupText(groupId, `ğŸ“¢ APIå…è´¹é¢åº¦ä½¿ç”¨å®Œæ¯•æˆ–è´¦å·ä¼šå‘˜å·²ç»è¿‡æœŸ`);
      } else {
        await pluginState.sendGroupText(groupId, `âŒ æŸ¥è¯¢å¤±è´¥ [${data.code}]: ${data.msg || "æœªçŸ¥é”™è¯¯"}`);
      }
    } catch (e) {
      pluginState.log("error", `æŸ¥è¯¢å°å·å¤±è´¥: ${e}`);
      await pluginState.sendGroupText(groupId, `æŸ¥è¯¢å‡ºé”™: ${e.message || e}`);
    }
    return true;
  }
  if (text.startsWith("è®¾ç½®lolurl")) {
    if (!pluginState.isOwner(userId)) {
      return true;
    }
    const url = text.replace("è®¾ç½®lolurl", "").trim();
    if (!url) {
      await pluginState.sendGroupText(groupId, "è¯·æä¾›å®Œæ•´çš„æŸ¥è¯¢æ¥å£åœ°å€ï¼Œä¾‹å¦‚ï¼šè®¾ç½®lolurl http://example.com/query.php");
      return true;
    }
    pluginState.config.lolQueryUrl = url;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "è‡ªå®šä¹‰æˆ˜ç»©æŸ¥è¯¢æ¥å£åœ°å€å·²æ›´æ–°");
    return true;
  }
  if (text.startsWith("è®¾ç½®lolkey")) {
    if (!pluginState.isOwner(userId)) {
      return true;
    }
    const key = text.replace("è®¾ç½®lolkey", "").trim();
    if (!key) {
      await pluginState.sendGroupText(groupId, "è¯·æä¾›æˆæƒç (zhanjikey)");
      return true;
    }
    pluginState.config.lolAuthKey = key;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "è‡ªå®šä¹‰æˆ˜ç»©æŸ¥è¯¢æˆæƒç å·²æ›´æ–°");
    return true;
  }
  if (text.startsWith("è®¾ç½®loltoken")) {
    if (!pluginState.isOwner(userId)) {
      return true;
    }
    const token = text.replace("è®¾ç½®loltoken", "").trim();
    if (!token) {
      await pluginState.sendGroupText(groupId, "è¯·æä¾› Tokenï¼Œä¾‹å¦‚ï¼šè®¾ç½®loltoken eyJ...");
      return true;
    }
    pluginState.config.lolToken = token;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "LOL Token å·²æ›´æ–°");
    return true;
  }
  if (text.startsWith("æŸ¥éšè—")) {
    const rest = text.replace("æŸ¥éšè—", "").trim();
    if (!rest) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå¬å”¤å¸ˆåç§°ï¼Œä¾‹å¦‚ï¼šæŸ¥éšè— TheShy");
      return true;
    }
    const args = rest.split(/\s+/);
    const name = args[0];
    const region = args[1] || "1";
    const customUrl = pluginState.config.lolQueryUrl;
    const customKey = pluginState.config.lolAuthKey;
    if (customUrl && customKey) {
      await pluginState.sendGroupText(groupId, `ğŸ” æ­£åœ¨é€šè¿‡è‡ªå®šä¹‰æ¥å£æŸ¥è¯¢ ${name}...`);
      try {
        const params = new URLSearchParams();
        params.append("name", name);
        params.append("region", region);
        params.append("sign", "0");
        params.append("key", customKey);
        const res = await fetch(customUrl, {
          method: "POST",
          body: params,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "X-Requested-With": "XMLHttpRequest",
            "Cookie": `zhanjikey=${customKey}`,
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
          }
        });
        if (res.status === 200) {
          const json = await res.json();
          if (json.status === 200) {
            const d = json.data;
            let msg = `ğŸ“Š ${d.summonerName} (Lv.${d.level}) éšè—æˆ˜ç»©
`;
            msg += `------------------------------
`;
            msg += `å°å·çŠ¶æ€: ${d.banstatus === 1 ? "âŒ å°å·" : d.banstatus === 2 ? "â“ æœªçŸ¥/ç°ç™½" : "âœ… æ­£å¸¸"}
`;
            if (d.banst) msg += `å°å·è¯¦æƒ…: ${d.banst}
`;
            msg += `å•åŒæ’: ${d.soloData?.tier} ${d.soloData?.rank} (${d.soloData?.lp}ç‚¹)
`;
            msg += `çµæ´»æ’: ${d.flexData?.tier} ${d.flexData?.rank} (${d.flexData?.lp}ç‚¹)
`;
            msg += `æœ€ååœ¨çº¿: ${d.last_game?.time || "æœªçŸ¥"}
`;
            msg += `æ’ä½èµ„æ ¼: ${d.rankEligibility || "æœªçŸ¥"}`;
            await pluginState.sendGroupText(groupId, msg);
            return true;
          } else {
            await pluginState.sendGroupText(groupId, `æŸ¥è¯¢å¤±è´¥: ${json.msg || "æœªçŸ¥é”™è¯¯"}`);
            return true;
          }
        } else {
          await pluginState.sendGroupText(groupId, `æ¥å£è¯·æ±‚å¤±è´¥: HTTP ${res.status}`);
          return true;
        }
      } catch (e) {
        pluginState.log("error", `è‡ªå®šä¹‰æŸ¥è¯¢å‡ºé”™: ${e}`);
        await pluginState.sendGroupText(groupId, `æŸ¥è¯¢å‡ºé”™: ${e.message}`);
        return true;
      }
    }
    const token = pluginState.config.lolToken;
    if (!token) {
      await pluginState.sendGroupText(groupId, "âŒ æœªé…ç½® LOL Tokenï¼Œè¯·è”ç³»æœºå™¨äººä¸»äººé…ç½®");
      return true;
    }
    await pluginState.sendGroupText(groupId, `ğŸ” æ­£åœ¨æŸ¥è¯¢ [${region}åŒº] ${name} çš„éšè—æˆ˜ç»©...`);
    try {
      const searchUrl = `https://ww1.lolso1.com/game-lol/customize-summoner-basic-by-name-region`;
      const headers = {
        "Authorization": `Bearer ${token}`,
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Content-Type": "application/json",
        "Referer": "https://lolso1.com/",
        "Origin": "https://lolso1.com"
      };
      const searchRes = await fetch(searchUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({ name, region: parseInt(region) || 1 })
      });
      if (!searchRes.ok) {
        const errText = await searchRes.text();
        if (searchRes.status === 403 || searchRes.status === 405) {
          await pluginState.sendGroupText(groupId, `ğŸ›‘ æŸ¥è¯¢è¢«æ‹¦æˆª [${searchRes.status}]ï¼šAPI æ‹’ç»è®¿é—® (å¯èƒ½æ˜¯WAFæˆ–Tokenæ— æ•ˆ)`);
        } else {
          await pluginState.sendGroupText(groupId, `âŒ æœç´¢å¤±è´¥ [${searchRes.status}]`);
        }
        pluginState.log("error", `LOL Search Failed: ${searchRes.status} ${errText}`);
        return true;
      }
      const searchData = await searchRes.json();
      if (!searchData.data || !searchData.data.puuid) {
        await pluginState.sendGroupText(groupId, `âŒ æœªæ‰¾åˆ°å¬å”¤å¸ˆ ${name}`);
        return true;
      }
      const { puuid, summonerLevel } = searchData.data;
      const historyUrl = `https://ww1.lolso1.com/game-lol/customize-normal-match-history-simplified`;
      const historyRes = await fetch(historyUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          puuid,
          region: parseInt(region) || 1,
          start: 0,
          count: 5
        })
      });
      if (!historyRes.ok) {
        await pluginState.sendGroupText(groupId, `âŒ è·å–æˆ˜ç»©å¤±è´¥ [${historyRes.status}]`);
        return true;
      }
      const historyData = await historyRes.json();
      const matches = historyData.data || [];
      if (matches.length === 0) {
        await pluginState.sendGroupText(groupId, `ğŸ“­ ${name} æœ€è¿‘æ²¡æœ‰æ¯”èµ›è®°å½•`);
        return true;
      }
      let msg = `ğŸ“Š ${name} (Lv.${summonerLevel}) è¿‘5åœºæˆ˜ç»©ï¼š
`;
      msg += `------------------------------
`;
      for (const match of matches) {
        const mode = match.queueId === 420 ? "æ’ä½" : match.queueId === 450 ? "ä¹±æ–—" : "åŒ¹é…";
        const result = match.win ? "âœ… èƒœåˆ©" : "âŒ å¤±è´¥";
        const kda = `${match.kills}/${match.deaths}/${match.assists}`;
        const champion = match.championName || "æœªçŸ¥è‹±é›„";
        const time = new Date(match.gameEndTimestamp).toLocaleString();
        msg += `${result} | ${champion} (${mode})
`;
        msg += `âš”ï¸ KDA: ${kda}
`;
        msg += `â° ${time}
`;
        msg += `------------------------------
`;
      }
      await pluginState.sendGroupText(groupId, msg.trim());
    } catch (e) {
      pluginState.log("error", `æŸ¥è¯¢éšè—æˆ˜ç»©å¤±è´¥: ${e}`);
      await pluginState.sendGroupText(groupId, `æŸ¥è¯¢å‡ºé”™: ${e.message || e}`);
    }
    return true;
  }
  if (text === "é‚€è¯·æŸ¥è¯¢") {
    const data = await dbQuery.getInvite(groupId, userId);
    const count = data ? data.inviteCount : 0;
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` ä½ å·²é‚€è¯· ${count} äººåŠ å…¥æœ¬ç¾¤` } }
    ]);
    return true;
  }
  if (text === "é‚€è¯·æ¦œ") {
    const data = await dbQuery.getAllInvites(groupId);
    if (!Object.keys(data).length) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æš‚æ— é‚€è¯·æ•°æ®");
      return true;
    }
    const list = Object.entries(data).sort((a, b) => b[1].inviteCount - a[1].inviteCount).slice(0, 10);
    const content = list.map((item, i) => `${i + 1}. ${item[0]} - é‚€è¯· ${item[1].inviteCount} äºº`).join("\n");
    await pluginState.sendGroupText(groupId, `ğŸ† é‚€è¯·æ’è¡Œæ¦œ
${content}`);
    return true;
  }
  if (text.startsWith("æ¿€æ´» ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const key = text.slice(3).trim();
    if (key.startsWith("PRO-30-")) {
      authManager.grantLicense(groupId, 30);
      saveConfig(ctx);
      await pluginState.sendGroupText(groupId, "æ¿€æ´»æˆåŠŸï¼å·²è·å¾— 30 å¤©ä¸“ä¸šç‰ˆæˆæƒã€‚");
    } else if (key.startsWith("PRO-PERM-")) {
      authManager.grantLicense(groupId, -1);
      saveConfig(ctx);
      await pluginState.sendGroupText(groupId, "æ¿€æ´»æˆåŠŸï¼å·²è·å¾— æ°¸ä¹… ä¸“ä¸šç‰ˆæˆæƒã€‚");
    } else {
      await pluginState.sendGroupText(groupId, "æ— æ•ˆçš„æ¿€æ´»ç ");
    }
    return true;
  }
  if (text === "è¿è¡ŒçŠ¶æ€") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const uptime = Math.floor((Date.now() - pluginState.startTime) / 1e3);
    const h = Math.floor(uptime / 3600);
    const m = Math.floor(uptime % 3600 / 60);
    const s = uptime % 60;
    const mem = process.memoryUsage();
    const rss = (mem.rss / 1024 / 1024).toFixed(2);
    const heap = (mem.heapUsed / 1024 / 1024).toFixed(2);
    const cacheStats = `Msg: ${pluginState.msgCache.size} | Spam: ${pluginState.spamCache.size} | Admin: ${pluginState.adminCache.size}`;
    const status = `ğŸ¤– è¿è¡ŒçŠ¶æ€
â±ï¸ è¿è¡Œæ—¶é•¿ï¼š${h}å°æ—¶${m}åˆ†${s}ç§’
ğŸ“¨ å¤„ç†æ¶ˆæ¯ï¼š${pluginState.msgCount} æ¡
ğŸ’¾ å†…å­˜å ç”¨ï¼šRSS ${rss}MB / Heap ${heap}MB
ğŸ“¦ ç¼“å­˜å¯¹è±¡ï¼š${cacheStats}
ğŸ›¡ï¸ å½“å‰ç‰ˆæœ¬ï¼šv${pluginState.version}
ğŸ‘¥ æˆæƒç¾¤æ•°ï¼š${Object.keys(pluginState.config.licenses || {}).length}`;
    await pluginState.sendGroupText(groupId, status);
    return true;
  }
  if (text === "æŠ½å¥–") {
    if (pluginState.getGroupSettings(groupId).disableLottery) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æŠ½å¥–åŠŸèƒ½å·²å…³é—­");
      return true;
    }
    let userSignin = await dbQuery.getSignin(groupId, userId);
    const settings = pluginState.getGroupSettings(groupId);
    const cost = settings.lotteryCost || 20;
    const maxReward = settings.lotteryReward || 100;
    if (!userSignin || userSignin.points < cost) {
      await pluginState.sendGroupMsg(groupId, [
        { type: "at", data: { qq: userId } },
        { type: "text", data: { text: ` ç§¯åˆ†ä¸è¶³ï¼æŠ½å¥–éœ€è¦${cost}ç§¯åˆ†ï¼Œè¯·å…ˆç­¾åˆ°è·å–ç§¯åˆ†ã€‚` } }
      ]);
      return true;
    }
    userSignin.points -= cost;
    const rand = Math.random();
    let prize = "";
    let bonus = 0;
    if (rand < 0.01) {
      prize = `ç‰¹ç­‰å¥–ï¼šç§¯åˆ†+${maxReward}`;
      bonus = maxReward;
    } else if (rand < 0.1) {
      prize = `ä¸€ç­‰å¥–ï¼šç§¯åˆ†+${Math.floor(maxReward * 0.5)}`;
      bonus = Math.floor(maxReward * 0.5);
    } else if (rand < 0.3) {
      prize = `äºŒç­‰å¥–ï¼šç§¯åˆ†+${Math.floor(maxReward * 0.3)}`;
      bonus = Math.floor(maxReward * 0.3);
    } else if (rand < 0.6) {
      prize = `ä¸‰ç­‰å¥–ï¼šç§¯åˆ†+${Math.floor(maxReward * 0.1)}`;
      bonus = Math.floor(maxReward * 0.1);
    } else {
      prize = "è°¢è°¢å‚ä¸";
      bonus = 0;
    }
    userSignin.points += bonus;
    await dbQuery.updateSignin(groupId, userId, userSignin);
    await pluginState.sendGroupMsg(groupId, [
      { type: "at", data: { qq: userId } },
      { type: "text", data: { text: ` æ¶ˆè€—${cost}ç§¯åˆ†æŠ½å¥–...
ğŸ‰ ${prize}
å½“å‰ç§¯åˆ†ï¼š${userSignin.points}` } }
    ]);
    return true;
  }
  if (text === "ç§¯åˆ†å•†åŸ" || text === "å•†åŸ") {
    if (pluginState.getGroupSettings(groupId).disableLottery) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤ç§¯åˆ†åŠŸèƒ½å·²å…³é—­");
      return true;
    }
    const menu = `ğŸ›’ ç§¯åˆ†å•†åŸ
----------------
1. å…æ­»é‡‘ç‰Œ (æ¸…é™¤è­¦å‘Š) - 100ç§¯åˆ†
   æŒ‡ä»¤ï¼šå…‘æ¢ å…æ­»é‡‘ç‰Œ
2. è‡ªå®šä¹‰å¤´è¡” (æ°¸ä¹…) - 500ç§¯åˆ†
   æŒ‡ä»¤ï¼šå…‘æ¢ å¤´è¡” <å†…å®¹>
3. è§£é™¤ç¦è¨€ (è‡ªå·±) - 200ç§¯åˆ†
   æŒ‡ä»¤ï¼šå…‘æ¢ è§£ç¦
----------------
å‘é€â€œæˆ‘çš„ç§¯åˆ†â€æŸ¥çœ‹ä½™é¢`;
    await pluginState.sendGroupText(groupId, menu);
    return true;
  }
  if (text.startsWith("å…‘æ¢ ")) {
    if (pluginState.getGroupSettings(groupId).disableLottery) {
      return true;
    }
    const args = text.slice(3).trim().split(/\s+/);
    const item = args[0];
    const param = args.slice(1).join(" ");
    let userSignin = await dbQuery.getSignin(groupId, userId);
    if (!userSignin) userSignin = { lastSignin: 0, days: 0, points: 0 };
    if (item === "å…æ­»é‡‘ç‰Œ") {
      const cost = 100;
      if (userSignin.points < cost) {
        await pluginState.sendGroupText(groupId, `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${cost} ç§¯åˆ†`);
        return true;
      }
      const warnings = await dbQuery.getWarning(groupId, userId);
      if (warnings <= 0) {
        await pluginState.sendGroupText(groupId, "ä½ å½“å‰æ²¡æœ‰è­¦å‘Šè®°å½•ï¼Œæ— éœ€ä½¿ç”¨å…æ­»é‡‘ç‰Œ");
        return true;
      }
      userSignin.points -= cost;
      await dbQuery.updateSignin(groupId, userId, userSignin);
      await dbQuery.setWarning(groupId, userId, 0);
      await pluginState.sendGroupText(groupId, `å…‘æ¢æˆåŠŸï¼å·²æ¸…é™¤æ‰€æœ‰è­¦å‘Šè®°å½•ã€‚
å‰©ä½™ç§¯åˆ†ï¼š${userSignin.points}`);
      return true;
    }
    if (item === "å¤´è¡”") {
      const cost = 500;
      if (userSignin.points < cost) {
        await pluginState.sendGroupText(groupId, `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${cost} ç§¯åˆ†`);
        return true;
      }
      if (!param) {
        await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå¤´è¡”å†…å®¹ï¼šå…‘æ¢ å¤´è¡” <å†…å®¹>");
        return true;
      }
      if (!await pluginState.isBotAdmin(groupId)) {
        await pluginState.sendGroupText(groupId, "å…‘æ¢å¤±è´¥ï¼šæœºå™¨äººéç®¡ç†å‘˜ï¼Œæ— æ³•è®¾ç½®å¤´è¡”");
        return true;
      }
      userSignin.points -= cost;
      await dbQuery.updateSignin(groupId, userId, userSignin);
      await pluginState.callApi("set_group_special_title", { group_id: groupId, user_id: userId, special_title: param });
      await pluginState.sendGroupText(groupId, `å…‘æ¢æˆåŠŸï¼å¤´è¡”å·²è®¾ç½®ä¸ºï¼š${param}
å‰©ä½™ç§¯åˆ†ï¼š${userSignin.points}`);
      return true;
    }
    if (item === "è§£ç¦") {
      const cost = 200;
      const target = getTarget(raw, param) || userId;
      if (userSignin.points < cost) {
        await pluginState.sendGroupText(groupId, `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${cost} ç§¯åˆ†`);
        return true;
      }
      if (!await pluginState.isBotAdmin(groupId)) {
        await pluginState.sendGroupText(groupId, "æœºå™¨äººéç®¡ç†å‘˜");
        return true;
      }
      userSignin.points -= cost;
      await dbQuery.updateSignin(groupId, userId, userSignin);
      await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: target, duration: 0 });
      await pluginState.sendGroupText(groupId, `å…‘æ¢æˆåŠŸï¼å·²è§£é™¤ ${target} çš„ç¦è¨€ã€‚
å‰©ä½™ç§¯åˆ†ï¼š${userSignin.points}`);
      return true;
    }
    await pluginState.sendGroupText(groupId, "æœªçŸ¥å•†å“ã€‚è¯·å‘é€â€œç§¯åˆ†å•†åŸâ€æŸ¥çœ‹åˆ—è¡¨ã€‚");
    return true;
  }
  if (text.startsWith("å¼€å¯å‘è¨€å¥–åŠ± ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const points = parseInt(text.slice(7));
    if (isNaN(points) || points <= 0) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æ­£ç¡®çš„ç§¯åˆ†æ•°");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].messageReward = points;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²å¼€å¯å‘è¨€å¥–åŠ±ï¼Œæ¯æ¡æ¶ˆæ¯å¥–åŠ± ${points} ç§¯åˆ†`);
    return true;
  }
  if (text === "å…³é—­å‘è¨€å¥–åŠ±") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      pluginState.config.groups[groupId].messageReward = 0;
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, "å·²å…³é—­å‘è¨€å¥–åŠ±");
    return true;
  }
  if (text.startsWith("è¸¢å‡º")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(2).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šè¸¢å‡º@æŸäºº æˆ– è¸¢å‡ºQQå·");
      return true;
    }
    await pluginState.callApi("set_group_kick", { group_id: groupId, user_id: target, reject_add_request: false });
    await pluginState.sendGroupText(groupId, `å·²è¸¢å‡º ${target}`);
    return true;
  }
  if (text.startsWith("ç¦è¨€") && !text.startsWith("ç¦è¨€åˆ—è¡¨")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(2).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šç¦è¨€@æŸäºº åˆ†é’Ÿ æˆ– ç¦è¨€QQå· åˆ†é’Ÿ");
      return true;
    }
    const durationMatch = rest.replace(/\d{5,}/, "").match(/(\d+)/);
    const duration = durationMatch ? parseInt(durationMatch[1]) : 10;
    await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: target, duration: duration * 60 });
    await pluginState.sendGroupText(groupId, `å·²ç¦è¨€ ${target}ï¼Œæ—¶é•¿ ${duration} åˆ†é’Ÿ`);
    return true;
  }
  if (text.startsWith("è§£ç¦")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(2).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šè§£ç¦@æŸäºº æˆ– è§£ç¦QQå·");
      return true;
    }
    await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: target, duration: 0 });
    await pluginState.sendGroupText(groupId, `å·²è§£ç¦ ${target}`);
    return true;
  }
  if (text === "å…¨ä½“ç¦è¨€") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    await pluginState.callApi("set_group_whole_ban", { group_id: groupId, enable: true });
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯å…¨ä½“ç¦è¨€");
    return true;
  }
  if (text === "å…¨ä½“è§£ç¦") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    await pluginState.callApi("set_group_whole_ban", { group_id: groupId, enable: false });
    await pluginState.sendGroupText(groupId, "å·²å…³é—­å…¨ä½“ç¦è¨€");
    return true;
  }
  if (text.startsWith("æˆäºˆå¤´è¡”")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç¾¤ä¸»æƒé™");
      return true;
    }
    const rest = text.slice(4).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šæˆäºˆå¤´è¡”@æŸäºº å†…å®¹");
      return true;
    }
    const title = rest.replace(/\[CQ:[^\]]+\]/g, "").replace(/\d{5,12}/, "").trim();
    await pluginState.callApi("set_group_special_title", { group_id: groupId, user_id: target, special_title: title });
    await pluginState.sendGroupText(groupId, `å·²ä¸º ${target} è®¾ç½®å¤´è¡”ï¼š${title || "(ç©º)"}`);
    return true;
  }
  if (text.startsWith("æ¸…é™¤å¤´è¡”")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç¾¤ä¸»æƒé™");
      return true;
    }
    const rest = text.slice(4).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    await pluginState.callApi("set_group_special_title", { group_id: groupId, user_id: target, special_title: "" });
    await pluginState.sendGroupText(groupId, `å·²æ¸…é™¤ ${target} çš„å¤´è¡”`);
    return true;
  }
  if (text.startsWith("é”å®šåç‰‡")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(4).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    const info = await pluginState.callApi("get_group_member_info", { group_id: groupId, user_id: target });
    const card = info?.card || info?.nickname || "";
    pluginState.config.cardLocks[`${groupId}:${target}`] = card;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²é”å®š ${target} çš„åç‰‡ä¸ºï¼š${card || "(ç©º)"}`);
    return true;
  }
  if (text.startsWith("è§£é”åç‰‡")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(4).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    delete pluginState.config.cardLocks[`${groupId}:${target}`];
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è§£é” ${target} çš„åç‰‡`);
    return true;
  }
  if (text === "åç‰‡é”å®šåˆ—è¡¨") {
    const locks = pluginState.config.cardLocks;
    const entries = Object.entries(locks).filter(([k]) => k.startsWith(groupId + ":"));
    if (!entries.length) {
      await pluginState.sendGroupText(groupId, "å½“å‰ç¾¤æ²¡æœ‰é”å®šçš„åç‰‡");
      return true;
    }
    const list = entries.map(([k, v]) => `${k.split(":")[1]} â†’ ${v}`).join("\n");
    await pluginState.sendGroupText(groupId, `åç‰‡é”å®šåˆ—è¡¨ï¼š
${list}`);
    return true;
  }
  if (text === "å¼€å¯é˜²æ’¤å›") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!authManager.checkFeature(groupId, "anti_recall")) {
      await pluginState.sendGroupText(groupId, "æ­¤åŠŸèƒ½ä»…é™ä¸“ä¸šç‰ˆ/ä¼ä¸šç‰ˆä½¿ç”¨ï¼Œè¯·è´­ä¹°æˆæƒã€‚");
      return true;
    }
    if (!pluginState.config.antiRecallGroups) pluginState.config.antiRecallGroups = [];
    if (!pluginState.config.antiRecallGroups.includes(groupId)) {
      pluginState.config.antiRecallGroups.push(groupId);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯é˜²æ’¤å›");
    return true;
  }
  if (text === "å…³é—­é˜²æ’¤å›") {
    if (!pluginState.isOwner(userId) && !await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    pluginState.config.antiRecallGroups = pluginState.config.antiRecallGroups.filter((g) => g !== groupId);
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­é˜²æ’¤å›");
    return true;
  }
  if (text === "é˜²æ’¤å›åˆ—è¡¨") {
    const list = pluginState.config.antiRecallGroups;
    await pluginState.sendGroupText(groupId, list.length ? `é˜²æ’¤å›å·²å¼€å¯çš„ç¾¤ï¼š
${list.join("\n")}` : "æ²¡æœ‰å¼€å¯é˜²æ’¤å›çš„ç¾¤");
    return true;
  }
  if (text === "å¼€å¯å›åº”è¡¨æƒ…") {
    if (!pluginState.isOwner(userId) && !await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.emojiReactGroups[groupId]) pluginState.config.emojiReactGroups[groupId] = [];
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯å›åº”è¡¨æƒ…");
    return true;
  }
  if (text === "å…³é—­å›åº”è¡¨æƒ…") {
    if (!pluginState.isOwner(userId) && !await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    delete pluginState.config.emojiReactGroups[groupId];
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­å›åº”è¡¨æƒ…");
    return true;
  }
  if (text.startsWith("é’ˆå¯¹") && text !== "é’ˆå¯¹åˆ—è¡¨") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(2).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šé’ˆå¯¹@æŸäºº æˆ– é’ˆå¯¹+QQå·");
      return true;
    }
    const cfg = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal ? pluginState.config.groups[groupId] : pluginState.config.global;
    if (!cfg.targetUsers) cfg.targetUsers = [];
    if (!cfg.targetUsers.includes(target)) {
      cfg.targetUsers.push(target);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²é’ˆå¯¹ ${target}ï¼Œå…¶æ¶ˆæ¯å°†è¢«è‡ªåŠ¨æ’¤å›`);
    return true;
  }
  if (text.startsWith("å–æ¶ˆé’ˆå¯¹")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(4).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    const cfg = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal ? pluginState.config.groups[groupId] : pluginState.config.global;
    if (cfg.targetUsers) {
      cfg.targetUsers = cfg.targetUsers.filter((t) => t !== target);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å–æ¶ˆé’ˆå¯¹ ${target}`);
    return true;
  }
  if (text === "é’ˆå¯¹åˆ—è¡¨") {
    const settings = pluginState.getGroupSettings(groupId);
    const list = settings.targetUsers || [];
    await pluginState.sendGroupText(groupId, list.length ? `å½“å‰ç¾¤é’ˆå¯¹åˆ—è¡¨ï¼š
${list.join("\n")}` : "å½“å‰ç¾¤æ²¡æœ‰é’ˆå¯¹çš„ç”¨æˆ·");
    return true;
  }
  if (text === "æ¸…é™¤é’ˆå¯¹") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const cfg = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal ? pluginState.config.groups[groupId] : pluginState.config.global;
    cfg.targetUsers = [];
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²æ¸…é™¤å½“å‰ç¾¤æ‰€æœ‰é’ˆå¯¹");
    return true;
  }
  if (text.startsWith("å¼€å¯è‡ªèº«æ’¤å›")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(6).trim();
    const duration = parseInt(rest);
    const delay = isNaN(duration) ? 60 : duration;
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    gs.autoRecallSelf = true;
    gs.autoRecallSelfDelay = delay;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²å¼€å¯è‡ªèº«æ¶ˆæ¯æ’¤å›ï¼Œå»¶è¿Ÿ ${delay} ç§’`);
    return true;
  }
  if (text === "å…³é—­è‡ªèº«æ’¤å›") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      pluginState.config.groups[groupId].autoRecallSelf = false;
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, "å·²å…³é—­è‡ªèº«æ¶ˆæ¯æ’¤å›");
    return true;
  }
  if (text.startsWith("æ‹‰é»‘")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    if (!authManager.checkFeature(groupId, "global_blacklist")) {
      await pluginState.sendGroupText(groupId, "å…¨å±€é»‘åå•ä»…é™ä¼ä¸šç‰ˆä½¿ç”¨ï¼Œè¯·ä½¿ç”¨ç¾¤æ‹‰é»‘æˆ–è´­ä¹°ä¼ä¸šæˆæƒã€‚");
      return true;
    }
    const rest = text.slice(2).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šæ‹‰é»‘@æŸäºº æˆ– æ‹‰é»‘QQå·");
      return true;
    }
    if (!pluginState.config.blacklist) pluginState.config.blacklist = [];
    if (!pluginState.config.blacklist.includes(target)) {
      pluginState.config.blacklist.push(target);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°† ${target} åŠ å…¥å…¨å±€é»‘åå•`);
    return true;
  }
  if (text.startsWith("å–æ¶ˆæ‹‰é»‘")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const rest = text.slice(4).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    pluginState.config.blacklist = (pluginState.config.blacklist || []).filter((q) => q !== target);
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²å°† ${target} ç§»å‡ºé»‘åå•`);
    return true;
  }
  if (text === "é»‘åå•åˆ—è¡¨") {
    const list = pluginState.config.blacklist || [];
    await pluginState.sendGroupText(groupId, list.length ? `å…¨å±€é»‘åå•ï¼š
${list.join("\n")}` : "é»‘åå•ä¸ºç©º");
    return true;
  }
  if (text.startsWith("ç¾¤æ‹‰é»‘")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(3).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šç¾¤æ‹‰é»‘@æŸäºº æˆ– ç¾¤æ‹‰é»‘QQå·");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    if (!gs.groupBlacklist) gs.groupBlacklist = [];
    if (!gs.groupBlacklist.includes(target)) {
      gs.groupBlacklist.push(target);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°† ${target} åŠ å…¥æœ¬ç¾¤é»‘åå•`);
    return true;
  }
  if (text.startsWith("ç¾¤å–æ¶ˆæ‹‰é»‘")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(5).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      const gs = pluginState.config.groups[groupId];
      gs.groupBlacklist = (gs.groupBlacklist || []).filter((q) => q !== target);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°† ${target} ç§»å‡ºæœ¬ç¾¤é»‘åå•`);
    return true;
  }
  if (text === "ç¾¤é»‘åå•åˆ—è¡¨") {
    const settings = pluginState.getGroupSettings(groupId);
    const list = settings.groupBlacklist || [];
    await pluginState.sendGroupText(groupId, list.length ? `æœ¬ç¾¤é»‘åå•ï¼š
${list.join("\n")}` : "æœ¬ç¾¤é»‘åå•ä¸ºç©º");
    return true;
  }
  if (text.startsWith("ç™½åå•") && text !== "ç™½åå•åˆ—è¡¨") {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const rest = text.slice(3).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡ï¼šç™½åå•@æŸäºº æˆ– ç™½åå•QQå·");
      return true;
    }
    if (!pluginState.config.whitelist) pluginState.config.whitelist = [];
    if (!pluginState.config.whitelist.includes(target)) {
      pluginState.config.whitelist.push(target);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°† ${target} åŠ å…¥ç™½åå•`);
    return true;
  }
  if (text.startsWith("å–æ¶ˆç™½åå•")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const rest = text.slice(5).trim();
    const target = getTarget(raw, rest);
    if (!target) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šç›®æ ‡");
      return true;
    }
    pluginState.config.whitelist = (pluginState.config.whitelist || []).filter((q) => q !== target);
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²å°† ${target} ç§»å‡ºç™½åå•`);
    return true;
  }
  if (text === "ç™½åå•åˆ—è¡¨") {
    const list = pluginState.config.whitelist || [];
    await pluginState.sendGroupText(groupId, list.length ? `å…¨å±€ç™½åå•ï¼š
${list.join("\n")}` : "ç™½åå•ä¸ºç©º");
    return true;
  }
  if (text.startsWith("æ·»åŠ è¿ç¦è¯")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const word = text.slice(5).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šè¿ç¦è¯ï¼šæ·»åŠ è¿ç¦è¯ è¯è¯­");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    if (!gs.filterKeywords) gs.filterKeywords = [];
    if (!gs.filterKeywords.includes(word)) {
      gs.filterKeywords.push(word);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°†ã€Œ${word}ã€åŠ å…¥æœ¬ç¾¤è¿ç¦è¯`);
    return true;
  }
  if (text.startsWith("æ·»åŠ å…¨å±€è¿ç¦è¯")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const word = text.slice(7).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šè¿ç¦è¯");
      return true;
    }
    if (!pluginState.config.filterKeywords) pluginState.config.filterKeywords = [];
    if (!pluginState.config.filterKeywords.includes(word)) {
      pluginState.config.filterKeywords.push(word);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°†ã€Œ${word}ã€åŠ å…¥å…¨å±€è¿ç¦è¯`);
    return true;
  }
  if (text.startsWith("åˆ é™¤è¿ç¦è¯")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const word = text.slice(5).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šè¿ç¦è¯");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      const gs = pluginState.config.groups[groupId];
      if (gs.filterKeywords) {
        gs.filterKeywords = gs.filterKeywords.filter((w) => w !== word);
        saveConfig(ctx);
      }
    }
    await pluginState.sendGroupText(groupId, `å·²ä»æœ¬ç¾¤è¿ç¦è¯ä¸­ç§»é™¤ï¼š${word}`);
    return true;
  }
  if (text.startsWith("åˆ é™¤å…¨å±€è¿ç¦è¯")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const word = text.slice(7).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šè¿ç¦è¯");
      return true;
    }
    pluginState.config.filterKeywords = (pluginState.config.filterKeywords || []).filter((w) => w !== word);
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²ä»å…¨å±€è¿ç¦è¯ä¸­ç§»é™¤ï¼š${word}`);
    return true;
  }
  if (text.startsWith("è®¾ç½®è¿ç¦è¯æƒ©ç½š ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const level = parseInt(text.slice(8).trim());
    if (isNaN(level) || level < 1 || level > 4) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„æƒ©ç½šç­‰çº§ (1-4)ï¼š\n1: ä»…æ’¤å›\n2: æ’¤å›+ç¦è¨€\n3: æ’¤å›+è¸¢å‡º\n4: æ’¤å›+è¸¢å‡º+æ‹‰é»‘");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].filterPunishLevel = level;
    saveConfig(ctx);
    const desc = ["ä»…æ’¤å›", "æ’¤å›+ç¦è¨€", "æ’¤å›+è¸¢å‡º", "æ’¤å›+è¸¢å‡º+æ‹‰é»‘"][level - 1];
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®è¿ç¦è¯æƒ©ç½šç­‰çº§ä¸ºï¼š${level} (${desc})`);
    return true;
  }
  if (text.startsWith("è®¾ç½®è¿ç¦è¯ç¦è¨€ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const minutes = parseInt(text.slice(8).trim());
    if (isNaN(minutes) || minutes < 1) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„ç¦è¨€æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].filterBanMinutes = minutes;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®è¿ç¦è¯ç¦è¨€æ—¶é•¿ä¸ºï¼š${minutes} åˆ†é’Ÿ`);
    return true;
  }
  if (text === "è¿ç¦è¯åˆ—è¡¨") {
    const settings = pluginState.getGroupSettings(groupId);
    const groupKw = settings.filterKeywords || [];
    const globalKw = pluginState.config.filterKeywords || [];
    let msg = "ğŸš« è¿ç¦è¯åˆ—è¡¨\n";
    if (groupKw.length) msg += `ã€æœ¬ç¾¤ã€‘ï¼š${groupKw.join("ã€")}
`;
    if (globalKw.length) msg += `ã€å…¨å±€ã€‘ï¼š${globalKw.join("ã€")}`;
    if (!groupKw.length && !globalKw.length) msg += "æš‚æ— è¿ç¦è¯";
    await pluginState.sendGroupText(groupId, msg);
    return true;
  }
  if (text.startsWith("æ·»åŠ æ‹’ç»è¯")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const word = text.slice(5).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå…³é”®è¯ï¼šæ·»åŠ æ‹’ç»è¯ è¯è¯­");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    const gs = pluginState.config.groups[groupId];
    if (!gs.rejectKeywords) gs.rejectKeywords = [];
    if (!gs.rejectKeywords.includes(word)) {
      gs.rejectKeywords.push(word);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°†ã€Œ${word}ã€åŠ å…¥æœ¬ç¾¤å…¥ç¾¤æ‹’ç»è¯`);
    return true;
  }
  if (text.startsWith("æ·»åŠ å…¨å±€æ‹’ç»è¯")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const word = text.slice(7).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå…³é”®è¯");
      return true;
    }
    if (!pluginState.config.rejectKeywords) pluginState.config.rejectKeywords = [];
    if (!pluginState.config.rejectKeywords.includes(word)) {
      pluginState.config.rejectKeywords.push(word);
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, `å·²å°†ã€Œ${word}ã€åŠ å…¥å…¨å±€å…¥ç¾¤æ‹’ç»è¯`);
    return true;
  }
  if (text.startsWith("åˆ é™¤æ‹’ç»è¯")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const word = text.slice(5).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå…³é”®è¯");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      const gs = pluginState.config.groups[groupId];
      if (gs.rejectKeywords) {
        gs.rejectKeywords = gs.rejectKeywords.filter((w) => w !== word);
        saveConfig(ctx);
      }
    }
    await pluginState.sendGroupText(groupId, `å·²ä»æœ¬ç¾¤å…¥ç¾¤æ‹’ç»è¯ä¸­ç§»é™¤ï¼š${word}`);
    return true;
  }
  if (text.startsWith("åˆ é™¤å…¨å±€æ‹’ç»è¯")) {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ä¸»äººæƒé™");
      return true;
    }
    const word = text.slice(7).trim();
    if (!word) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå…³é”®è¯");
      return true;
    }
    pluginState.config.rejectKeywords = (pluginState.config.rejectKeywords || []).filter((w) => w !== word);
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²ä»å…¨å±€å…¥ç¾¤æ‹’ç»è¯ä¸­ç§»é™¤ï¼š${word}`);
    return true;
  }
  if (text === "æ‹’ç»è¯åˆ—è¡¨") {
    const settings = pluginState.getGroupSettings(groupId);
    const groupKw = settings.rejectKeywords || [];
    const globalKw = pluginState.config.rejectKeywords || [];
    let msg = "ğŸš« å…¥ç¾¤æ‹’ç»è¯åˆ—è¡¨\n";
    if (groupKw.length) msg += `ã€æœ¬ç¾¤ã€‘ï¼š${groupKw.join("ã€")}
`;
    if (globalKw.length) msg += `ã€å…¨å±€ã€‘ï¼š${globalKw.join("ã€")}`;
    if (!groupKw.length && !globalKw.length) msg += "æš‚æ— æ‹’ç»è¯";
    await pluginState.sendGroupText(groupId, msg);
    return true;
  }
  if (text === "é—®ç­”åˆ—è¡¨") {
    const settings = pluginState.getGroupSettings(groupId);
    const groupQa = settings.qaList || [];
    const globalQa = pluginState.config.qaList || [];
    const isGroupCustom = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal;
    const list = isGroupCustom ? groupQa : globalQa;
    const label = isGroupCustom ? "æœ¬ç¾¤" : "å…¨å±€";
    if (!list.length) {
      await pluginState.sendGroupText(groupId, `${label}é—®ç­”åˆ—è¡¨ä¸ºç©º`);
      return true;
    }
    const modeMap = { exact: "ç²¾ç¡®", contains: "æ¨¡ç³Š", regex: "æ­£åˆ™" };
    const txt = list.map((q, i) => `${i + 1}. [${modeMap[q.mode] || q.mode}] ${q.keyword} â†’ ${q.reply}`).join("\n");
    await pluginState.sendGroupText(groupId, `${label}é—®ç­”åˆ—è¡¨ï¼š
${txt}`);
    return true;
  }
  if (text.startsWith("æ¨¡ç³Šé—®") || text.startsWith("ç²¾ç¡®é—®")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    let mode = "contains";
    let rest = "";
    if (text.startsWith("æ¨¡ç³Šé—®")) {
      mode = "contains";
      rest = text.slice(3);
    } else if (text.startsWith("ç²¾ç¡®é—®")) {
      mode = "exact";
      rest = text.slice(3);
    }
    const sep = rest.indexOf("ç­”");
    if (sep < 1) {
      await pluginState.sendGroupText(groupId, "æ ¼å¼é”™è¯¯ï¼Œç¤ºä¾‹ï¼šæ¨¡ç³Šé—®ä½ å¥½ç­”åœ¨çš„ | ç²¾ç¡®é—®å¸®åŠ©ç­”è¯·çœ‹èœå•");
      return true;
    }
    const keyword = rest.slice(0, sep).trim();
    const reply = rest.slice(sep + 1).trim();
    if (!keyword || !reply) {
      await pluginState.sendGroupText(groupId, "å…³é”®è¯å’Œå›å¤ä¸èƒ½ä¸ºç©º");
      return true;
    }
    const isGroupCustom = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal;
    if (isGroupCustom) {
      const gs = pluginState.config.groups[groupId];
      if (!gs.qaList) gs.qaList = [];
      gs.qaList.push({ keyword, reply, mode });
    } else {
      if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId), useGlobal: false, qaList: [] };
      if (!pluginState.config.groups[groupId].qaList) pluginState.config.groups[groupId].qaList = [];
      pluginState.config.groups[groupId].qaList.push({ keyword, reply, mode });
    }
    saveConfig(ctx);
    const modeMap = { exact: "ç²¾ç¡®", contains: "æ¨¡ç³Š", regex: "æ­£åˆ™" };
    await pluginState.sendGroupText(groupId, `å·²æ·»åŠ ${modeMap[mode]}é—®ç­”ï¼š${keyword} â†’ ${reply}`);
    return true;
  }
  if (text.startsWith("æ·»åŠ æ­£åˆ™é—®ç­” ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const rest = text.slice(7).trim();
    const sep = rest.indexOf("|");
    if (sep < 1) {
      await pluginState.sendGroupText(groupId, "æ ¼å¼ï¼šæ·»åŠ æ­£åˆ™é—®ç­” è¡¨è¾¾å¼|å›å¤");
      return true;
    }
    const keyword = rest.slice(0, sep).trim();
    const reply = rest.slice(sep + 1).trim();
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId), useGlobal: false, qaList: [] };
    if (!pluginState.config.groups[groupId].qaList) pluginState.config.groups[groupId].qaList = [];
    pluginState.config.groups[groupId].qaList.push({ keyword, reply, mode: "regex" });
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²æ·»åŠ æ­£åˆ™é—®ç­”ï¼š${keyword} â†’ ${reply}`);
    return true;
  }
  if (text.startsWith("æ·»åŠ é—®ç­” ") || text.startsWith("æ·»åŠ æ¨¡ç³Šé—®ç­” ")) {
    await pluginState.sendGroupText(groupId, "æŒ‡ä»¤å·²æ›´æ–°ï¼Œè¯·ä½¿ç”¨ï¼šç²¾ç¡®é—®XXç­”YY / æ¨¡ç³Šé—®XXç­”YY");
    return true;
  }
  if (text.startsWith("åˆ é™¤é—®ç­” ") || text.startsWith("åˆ é—®")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const prefix = text.startsWith("åˆ é—®") ? "åˆ é—®" : "åˆ é™¤é—®ç­” ";
    const keyword = text.slice(prefix.length).trim();
    if (!keyword) {
      await pluginState.sendGroupText(groupId, "è¯·æŒ‡å®šå…³é”®è¯");
      return true;
    }
    const isGroupCustom = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal;
    if (isGroupCustom) {
      const gs = pluginState.config.groups[groupId];
      if (gs.qaList) {
        const before = gs.qaList.length;
        gs.qaList = gs.qaList.filter((q) => q.keyword !== keyword);
        if (gs.qaList.length === before) {
          await pluginState.sendGroupText(groupId, `æœªæ‰¾åˆ°é—®ç­”ï¼š${keyword}`);
        } else {
          saveConfig(ctx);
          await pluginState.sendGroupText(groupId, `å·²åˆ é™¤é—®ç­”ï¼š${keyword}`);
        }
      } else {
        await pluginState.sendGroupText(groupId, `æœªæ‰¾åˆ°ç›¸å…³é—®ç­”`);
      }
    } else {
      await pluginState.sendGroupText(groupId, "å½“å‰ä¸ºå…¨å±€é…ç½®æ¨¡å¼ï¼Œæ— æ³•åˆ é™¤å…¨å±€é—®ç­”ã€‚è¯·å…ˆå¼€å¯åˆ†ç¾¤ç‹¬ç«‹é…ç½®ã€‚");
    }
    return true;
  }
  if (text.startsWith("æ´»è·ƒç»Ÿè®¡")) {
    if (pluginState.getGroupSettings(groupId).disableActivity) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æ´»è·ƒç»Ÿè®¡å·²å…³é—­");
      return true;
    }
    if (!authManager.checkFeature(groupId, "analytics_detail")) {
      await pluginState.sendGroupText(groupId, "æ´»è·ƒç»Ÿè®¡ä»…é™ä¸“ä¸šç‰ˆ/ä¼ä¸šç‰ˆä½¿ç”¨ï¼Œè¯·è´­ä¹°æˆæƒã€‚");
      return true;
    }
    const stats = await dbQuery.getAllActivity(groupId);
    if (!Object.keys(stats).length) {
      await pluginState.sendGroupText(groupId, "æœ¬ç¾¤æš‚æ— æ´»è·ƒç»Ÿè®¡æ•°æ®");
      return true;
    }
    const selfId2 = String(event.self_id || "");
    const entries = Object.entries(stats).sort((a, b) => b[1].msgCount - a[1].msgCount);
    const today = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
    const totalMsg = entries.reduce((s, [, r]) => s + r.msgCount, 0);
    const todayMsg = entries.reduce((s, [, r]) => s + (r.lastActiveDay === today ? r.msgCountToday : 0), 0);
    const summary = `ğŸ“Š æœ¬ç¾¤æ´»è·ƒç»Ÿè®¡
æ€»æ¶ˆæ¯æ•°ï¼š${totalMsg}
ä»Šæ—¥æ¶ˆæ¯ï¼š${todayMsg}
ç»Ÿè®¡äººæ•°ï¼š${entries.length}`;
    const pages = [];
    const pageSize = 15;
    for (let i = 0; i < entries.length; i += pageSize) {
      const chunk = entries.slice(i, i + pageSize);
      const lines = chunk.map(([uid, r], idx) => {
        const rank = i + idx + 1;
        const todayC = r.lastActiveDay === today ? r.msgCountToday : 0;
        const lastTime = new Date(r.lastActive).toLocaleString("zh-CN", { hour12: false });
        return `${rank}. ${uid}
   æ€»æ¶ˆæ¯ï¼š${r.msgCount} | ä»Šæ—¥ï¼š${todayC}
   æœ€åæ´»è·ƒï¼š${lastTime}`;
      });
      pages.push(`æ’è¡Œæ¦œï¼ˆ${i + 1}-${i + chunk.length}ï¼‰

${lines.join("\n\n")}`);
    }
    const nodes = [summary, ...pages].map((content) => ({
      type: "node",
      data: { nickname: "ğŸ“Š æ´»è·ƒç»Ÿè®¡", user_id: selfId2, content: [{ type: "text", data: { text: content } }] }
    }));
    await pluginState.callApi("send_group_forward_msg", { group_id: groupId, messages: nodes });
    return true;
  }
  if (text === "å¼€å¯å…¥ç¾¤éªŒè¯") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].enableVerify = true;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯å…¥ç¾¤éªŒè¯");
    return true;
  }
  if (text === "å…³é—­å…¥ç¾¤éªŒè¯") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].enableVerify = false;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­å…¥ç¾¤éªŒè¯");
    return true;
  }
  if (text === "å¼€å¯è‡ªåŠ¨å®¡æ‰¹") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].autoApprove = true;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯è‡ªåŠ¨å®¡æ‰¹");
    return true;
  }
  if (text === "å…³é—­è‡ªåŠ¨å®¡æ‰¹") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].autoApprove = false;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­è‡ªåŠ¨å®¡æ‰¹");
    return true;
  }
  if (text === "å¼€å¯åˆ·å±æ£€æµ‹") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].spamDetect = true;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯åˆ·å±æ£€æµ‹");
    return true;
  }
  if (text === "å…³é—­åˆ·å±æ£€æµ‹") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].spamDetect = false;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­åˆ·å±æ£€æµ‹");
    return true;
  }
  if (text.startsWith("è®¾ç½®åˆ·å±çª—å£ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const seconds = parseInt(text.slice(7).trim());
    if (isNaN(seconds) || seconds < 1) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„ç§’æ•° (è‡³å°‘1ç§’)");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].spamWindow = seconds;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®åˆ·å±æ£€æµ‹çª—å£ä¸ºï¼š${seconds} ç§’`);
    return true;
  }
  if (text.startsWith("è®¾ç½®åˆ·å±é˜ˆå€¼ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const count = parseInt(text.slice(7).trim());
    if (isNaN(count) || count < 1) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„æ¡æ•° (è‡³å°‘1æ¡)");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].spamThreshold = count;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®åˆ·å±æ£€æµ‹é˜ˆå€¼ä¸ºï¼š${count} æ¡`);
    return true;
  }
  if (text.startsWith("è®¾ç½®åˆ·å±ç¦è¨€ ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const minutes = parseInt(text.slice(7).trim());
    if (isNaN(minutes) || minutes < 1) {
      await pluginState.sendGroupText(groupId, "è¯·è¾“å…¥æœ‰æ•ˆçš„åˆ†é’Ÿæ•° (è‡³å°‘1åˆ†é’Ÿ)");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].spamBanMinutes = minutes;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®åˆ·å±ç¦è¨€æ—¶é•¿ä¸ºï¼š${minutes} åˆ†é’Ÿ`);
    return true;
  }
  if (text === "å¼€å¯é€€ç¾¤æ‹‰é»‘") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].leaveBlacklist = true;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯é€€ç¾¤æ‹‰é»‘");
    return true;
  }
  if (text === "å…³é—­é€€ç¾¤æ‹‰é»‘") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].leaveBlacklist = false;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­é€€ç¾¤æ‹‰é»‘");
    return true;
  }
  if (text.startsWith("è®¾ç½®å…¥ç¾¤æš—å· ")) {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    const passphrase = text.slice(7).trim();
    if (!passphrase) {
      await pluginState.sendGroupText(groupId, "æš—å·ä¸èƒ½ä¸ºç©º");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].entryPassphrase = passphrase;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, `å·²è®¾ç½®å…¥ç¾¤æš—å·ä¸ºï¼šã€Œ${passphrase}ã€`);
    return true;
  }
  if (text === "å…³é—­å…¥ç¾¤æš—å·") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      pluginState.config.groups[groupId].entryPassphrase = "";
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, "å·²å…³é—­å…¥ç¾¤æš—å·");
    return true;
  }
  if (text === "å¼€å¯æš—å·å›è½") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].enableAutoApproveAfterPassphraseOff = true;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯æš—å·å›è½ï¼ˆå…³é—­æš—å·åå°†ä½¿ç”¨è‡ªåŠ¨åŒæ„è§„åˆ™ï¼‰");
    return true;
  }
  if (text === "å…³é—­æš—å·å›è½") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    pluginState.config.groups[groupId].enableAutoApproveAfterPassphraseOff = false;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å…³é—­æš—å·å›è½ï¼ˆå…³é—­æš—å·åå°†ä¸å†è‡ªåŠ¨å¤„ç†ç”³è¯·ï¼‰");
    return true;
  }
  if (text === "æ¸…ç©ºç¾¤é…ç½®") {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "æ­¤æ“ä½œä»…é™æœºå™¨äººä¸»äººæ‰§è¡Œ");
      return true;
    }
    await pluginState.sendGroupText(groupId, "âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†æ¸…ç©ºæœ¬ç¾¤æ‰€æœ‰é…ç½®å’Œæ•°æ®ï¼ˆåŒ…æ‹¬é—®ç­”ã€è¿ç¦è¯ã€æ—¥å¿—ç­‰ï¼‰ï¼Œä¸”ä¸å¯æ¢å¤ï¼\nè¯·å‘é€ã€Œç¡®è®¤æ¸…ç©ºç¾¤é…ç½®ã€ä»¥æ‰§è¡Œã€‚");
    return true;
  }
  if (text === "ç¡®è®¤æ¸…ç©ºç¾¤é…ç½®") {
    if (!pluginState.isOwner(userId)) {
      await pluginState.sendGroupText(groupId, "æ­¤æ“ä½œä»…é™æœºå™¨äººä¸»äººæ‰§è¡Œ");
      return true;
    }
    try {
      const groupDir = path.join(pluginState.configDir, "data", "groups", groupId);
      if (fs.existsSync(groupDir)) {
        fs.rmSync(groupDir, { recursive: true, force: true });
        fs.mkdirSync(groupDir, { recursive: true });
      }
      delete pluginState.config.groups[groupId];
      saveConfig(ctx);
      await pluginState.sendGroupText(groupId, "âœ… å·²æ¸…ç©ºæœ¬ç¾¤æ‰€æœ‰é…ç½®å’Œæ•°æ®");
      pluginState.log("warn", `ä¸»äºº ${userId} æ¸…ç©ºäº†ç¾¤ ${groupId} çš„æ‰€æœ‰æ•°æ®`);
    } catch (e) {
      await pluginState.sendGroupText(groupId, `æ¸…ç©ºå¤±è´¥: ${e}`);
    }
    return true;
  }
  if (text === "å¼€å¯äºŒç»´ç æ’¤å›") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (!pluginState.config.groups[groupId]) pluginState.config.groups[groupId] = { ...pluginState.getGroupSettings(groupId) };
    if (!pluginState.config.groups[groupId].msgFilter) pluginState.config.groups[groupId].msgFilter = { ...pluginState.config.global.msgFilter };
    pluginState.config.groups[groupId].msgFilter.blockQr = true;
    saveConfig(ctx);
    await pluginState.sendGroupText(groupId, "å·²å¼€å¯äºŒç»´ç æ’¤å›");
    return true;
  }
  if (text === "å…³é—­äºŒç»´ç æ’¤å›") {
    if (!await isAdminOrOwner(groupId, userId)) {
      await pluginState.sendGroupText(groupId, "éœ€è¦ç®¡ç†å‘˜æƒé™");
      return true;
    }
    if (pluginState.config.groups[groupId]) {
      if (!pluginState.config.groups[groupId].msgFilter) pluginState.config.groups[groupId].msgFilter = { ...pluginState.config.global.msgFilter };
      pluginState.config.groups[groupId].msgFilter.blockQr = false;
      saveConfig(ctx);
    }
    await pluginState.sendGroupText(groupId, "å·²å…³é—­äºŒç»´ç æ’¤å›");
    return true;
  }
  return false;
}
async function handleAntiRecall(groupId, messageId, operatorId) {
  if (operatorId === pluginState.botId) return;
  if (!pluginState.config.antiRecallGroups.includes(groupId) && !pluginState.config.globalAntiRecall) return;
  const cached = pluginState.msgCache.get(messageId);
  if (!cached) return;
  const contentSegments = cached.segments.length ? cached.segments : [{ type: "text", data: { text: cached.raw } }];
  const now = /* @__PURE__ */ new Date();
  const timeStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")} ${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}:${String(now.getSeconds()).padStart(2, "0")}`;
  const owners = pluginState.config.ownerQQs.split(",").map((s) => s.trim()).filter(Boolean);
  for (const owner of owners) {
    await pluginState.callApi("send_private_msg", {
      user_id: owner,
      message: [
        { type: "text", data: { text: `ğŸ”” é˜²æ’¤å›é€šçŸ¥
ç¾¤å·ï¼š${groupId}
QQå·ï¼š${cached.userId}
æ—¶é—´ï¼š${timeStr}
æ’¤å›å†…å®¹ï¼š
` } },
        ...contentSegments
      ]
    });
  }
}
function cacheMessage(messageId, userId, groupId, raw, segments) {
  if (!pluginState.config.antiRecallGroups.includes(groupId) && !pluginState.config.globalAntiRecall) return;
  pluginState.msgCache.set(messageId, { userId, groupId, raw, segments: segments || [], time: Date.now() });
  const now = Date.now();
  for (const [k, v] of pluginState.msgCache) {
    if (now - v.time > 6e5) pluginState.msgCache.delete(k);
  }
}
async function handleEmojiReact(groupId, userId, messageId, selfId) {
  if (pluginState.config.globalEmojiReact) {
    await pluginState.callApi("set_msg_emoji_like", { message_id: messageId, emoji_id: "76" });
    return;
  }
  const targets = pluginState.config.emojiReactGroups[groupId];
  if (!targets || !targets.length) return;
  const shouldReact = targets.includes(userId) || targets.includes("self") && userId === selfId;
  if (!shouldReact) return;
  await pluginState.callApi("set_msg_emoji_like", { message_id: messageId, emoji_id: "76" });
}
async function handleCardLockCheck(groupId, userId) {
  const key = `${groupId}:${userId}`;
  const lockedCard = pluginState.config.cardLocks[key];
  if (lockedCard === void 0) return;
  const info = await pluginState.callApi("get_group_member_info", { group_id: groupId, user_id: userId, no_cache: true });
  const currentCard = info?.card || "";
  if (currentCard !== lockedCard) {
    await pluginState.callApi("set_group_card", { group_id: groupId, user_id: userId, card: lockedCard });
    pluginState.debug(`åç‰‡é”å®š: ${userId} åœ¨ç¾¤ ${groupId} åç‰‡è¢«è¿˜åŸä¸º ${lockedCard}`);
  }
}
async function handleCardLockOnMessage(groupId, userId, senderCard) {
  const key = `${groupId}:${userId}`;
  const lockedCard = pluginState.config.cardLocks[key];
  if (lockedCard === void 0) return;
  const currentCard = senderCard || "";
  if (currentCard !== lockedCard) {
    pluginState.log("info", `[MsgCheck] ç›‘æµ‹åˆ° ${userId} åç‰‡å¼‚å¸¸(å½“å‰: "${currentCard}", é”å®š: "${lockedCard}")ï¼Œæ­£åœ¨ä¿®æ­£...`);
    await pluginState.callApi("set_group_card", { group_id: groupId, user_id: userId, card: lockedCard });
  }
}
async function handleAutoRecall(groupId, userId, messageId) {
  const settings = pluginState.getGroupSettings(groupId);
  const targets = settings.targetUsers || [];
  if (!targets.includes(userId)) return false;
  await pluginState.callApi("delete_msg", { message_id: messageId });
  pluginState.debug(`é’ˆå¯¹æ’¤å›: ç¾¤ ${groupId} ç”¨æˆ· ${userId} æ¶ˆæ¯ ${messageId}`);
  return true;
}
async function sendWelcomeMessage(groupId, userId) {
  const settings = pluginState.getGroupSettings(groupId);
  const tpl = settings.welcomeMessage !== void 0 && settings.welcomeMessage !== "" ? settings.welcomeMessage : pluginState.config.welcomeMessage || "";
  if (!tpl) return;
  const msg = tpl.replace(/\{user\}/g, userId).replace(/\{group\}/g, groupId);
  await pluginState.sendGroupMsg(groupId, [
    { type: "at", data: { qq: userId } },
    { type: "text", data: { text: ` ${msg}` } }
  ]);
}
async function handleMsgTypeFilter(groupId, userId, messageId, raw, messageSegments) {
  const settings = pluginState.getGroupSettings(groupId);
  const filter = settings.msgFilter || pluginState.config.msgFilter;
  if (!filter) return false;
  const types = (messageSegments || []).map((s) => s.type);
  let blocked = false;
  let reason = "";
  if (filter.blockVideo && types.includes("video")) {
    blocked = true;
    reason = "è§†é¢‘";
  } else if (filter.blockImage && types.includes("image")) {
    blocked = true;
    reason = "å›¾ç‰‡";
  } else if (filter.blockRecord && types.includes("record")) {
    blocked = true;
    reason = "è¯­éŸ³";
  } else if (filter.blockForward && types.includes("forward")) {
    blocked = true;
    reason = "åˆå¹¶è½¬å‘";
  } else if (filter.blockLightApp && (raw.includes("[CQ:json,") || raw.includes("[CQ:xml,"))) {
    blocked = true;
    reason = "å°ç¨‹åºå¡ç‰‡";
  } else if (filter.blockContact && (raw.includes('"app":"com.tencent.contact.lua"') || raw.includes('"app":"com.tencent.qq.checkin"') || types.includes("contact"))) {
    blocked = true;
    reason = "åç‰‡åˆ†äº«";
  } else if (filter.blockUrl) {
    const plainText = raw.replace(/\[CQ:[^\]]+\]/g, "");
    const urlPattern = /https?:\/\/\S+|www\.\S+|[a-zA-Z0-9][-a-zA-Z0-9]{0,62}\.(?:com|cn|net|org|io|cc|co|me|top|xyz|info|dev|app|site|vip|pro|tech|cloud|link|fun|icu|club|ltd|live|tv|asia|biz|wang|mobi|online|shop|store|work)\b/i;
    if (urlPattern.test(plainText)) {
      blocked = true;
      reason = "é“¾æ¥";
    }
  }
  if (!blocked && filter.blockQr) {
    const images = messageSegments.filter((s) => s.type === "image");
    for (const img of images) {
      const url = img.url || img.file;
      if (url && (url.startsWith("http") || url.startsWith("file://"))) {
        try {
          const hasQr = await detectQrCode(url);
          if (hasQr) {
            blocked = true;
            reason = "äºŒç»´ç ";
            break;
          }
        } catch (e) {
        }
      }
    }
  }
  if (!blocked) return false;
  await pluginState.callApi("delete_msg", { message_id: messageId });
  pluginState.log("info", `æ¶ˆæ¯ç±»å‹è¿‡æ»¤: ç¾¤ ${groupId} ç”¨æˆ· ${userId} å‘é€${reason}ï¼Œå·²æ’¤å›`);
  return true;
}
async function handleBlacklist(groupId, userId, messageId) {
  const settings = pluginState.getGroupSettings(groupId);
  const isGlobalBlack = pluginState.isBlacklisted(userId);
  const isGroupBlack = (settings.groupBlacklist || []).includes(userId);
  if (isGlobalBlack || isGroupBlack) {
    await pluginState.callApi("delete_msg", { message_id: messageId });
    pluginState.debug(`é»‘åå•æ‹¦æˆª: ç¾¤ ${groupId} ç”¨æˆ· ${userId} æ¶ˆæ¯ ${messageId}`);
    return true;
  }
  return false;
}
async function handleFilterKeywords(groupId, userId, messageId, raw, ctx) {
  const settings = pluginState.getGroupSettings(groupId);
  const groupKw = settings.filterKeywords || [];
  const globalKw = pluginState.config.filterKeywords || [];
  const allKw = [.../* @__PURE__ */ new Set([...groupKw, ...globalKw])];
  if (!allKw.length) return false;
  const matched = allKw.find((k) => raw.includes(k));
  if (matched) {
    const masked = matched.length > 1 ? matched[0] + "*".repeat(matched.length - 1) : "*";
    await pluginState.callApi("delete_msg", { message_id: messageId });
    pluginState.log("info", `è¿ç¦è¯æ‹¦æˆª: ç¾¤ ${groupId} ç”¨æˆ· ${userId} è§¦å‘ã€Œ${matched}ã€`);
    const level = settings.filterPunishLevel || 1;
    if (level >= 2) {
      const banMin = groupKw && groupKw.length ? settings.filterBanMinutes || 10 : pluginState.config.filterBanMinutes || 10;
      await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: userId, duration: banMin * 60 });
      await pluginState.sendGroupText(groupId, `âš ï¸ ${userId} æ¶ˆæ¯å·²æ’¤å›å¹¶ç¦è¨€ ${banMin} åˆ†é’Ÿï¼ŒåŸå› ï¼šè§¦å‘è¿ç¦è¯ã€Œ${masked}ã€`);
    }
    if (level >= 3) {
      setTimeout(() => pluginState.callApi("set_group_kick", { group_id: groupId, user_id: userId, reject_add_request: false }), 1e3);
      await pluginState.sendGroupText(groupId, `âš ï¸ ${userId} å·²è¢«ç§»å‡ºç¾¤èŠï¼ŒåŸå› ï¼šè§¦å‘è¿ç¦è¯ã€Œ${masked}ã€`);
    }
    if (level >= 4) {
      if (!pluginState.config.blacklist) pluginState.config.blacklist = [];
      if (!pluginState.config.blacklist.includes(userId)) {
        pluginState.config.blacklist.push(userId);
        saveConfig(ctx);
      }
      await pluginState.sendGroupText(groupId, `âš ï¸ ${userId} å·²è¢«åŠ å…¥é»‘åå•ï¼ŒåŸå› ï¼šè§¦å‘è¿ç¦è¯ã€Œ${masked}ã€`);
    }
    return true;
  }
  return false;
}
async function handleSpamDetect(groupId, userId, raw = "") {
  const settings = pluginState.getGroupSettings(groupId);
  const spamOn = settings.spamDetect !== void 0 ? settings.spamDetect : pluginState.config.spamDetect;
  if (!spamOn) return false;
  const windowMs = ((settings.spamWindow !== void 0 ? settings.spamWindow : pluginState.config.spamWindow) || 10) * 1e3;
  const threshold = (settings.spamThreshold !== void 0 ? settings.spamThreshold : pluginState.config.spamThreshold) || 10;
  const key = `${groupId}:${userId}`;
  const now = Date.now();
  let timestamps = pluginState.spamCache.get(key) || [];
  timestamps.push(now);
  timestamps = timestamps.filter((t) => now - t < windowMs);
  pluginState.spamCache.set(key, timestamps);
  if (timestamps.length >= threshold) {
    const banMin = (settings.spamBanMinutes !== void 0 ? settings.spamBanMinutes : pluginState.config.spamBanMinutes) || 5;
    await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: userId, duration: banMin * 60 });
    await pluginState.sendGroupText(groupId, `âš ï¸ ${userId} åˆ·å±æ£€æµ‹è§¦å‘ï¼ˆé¢‘ç‡ï¼‰ï¼Œå·²ç¦è¨€ ${banMin} åˆ†é’Ÿ`);
    pluginState.spamCache.delete(key);
    pluginState.repeatCache.delete(key);
    pluginState.log("info", `åˆ·å±æ£€æµ‹: ç¾¤ ${groupId} ç”¨æˆ· ${userId} åœ¨ ${windowMs / 1e3}s å†…å‘é€ ${threshold} æ¡æ¶ˆæ¯`);
    return true;
  }
  const repeatLimit = settings.repeatThreshold || 0;
  if (repeatLimit > 0 && raw) {
    const repeatKey = `${groupId}:${userId}`;
    const lastMsg = pluginState.repeatCache.get(repeatKey);
    if (lastMsg && lastMsg.content === raw) {
      lastMsg.count++;
      if (lastMsg.count >= repeatLimit) {
        const banMin = settings.spamBanMinutes || 5;
        await pluginState.callApi("set_group_ban", { group_id: groupId, user_id: userId, duration: banMin * 60 });
        await pluginState.sendGroupText(groupId, `âš ï¸ ${userId} åˆ·å±æ£€æµ‹è§¦å‘ï¼ˆå¤è¯»ï¼‰ï¼Œå·²ç¦è¨€ ${banMin} åˆ†é’Ÿ`);
        pluginState.repeatCache.delete(repeatKey);
        return true;
      }
    } else {
      pluginState.repeatCache.set(repeatKey, { content: raw, count: 1 });
    }
  }
  return false;
}
async function handleQA(groupId, userId, raw) {
  const settings = pluginState.getGroupSettings(groupId);
  if (settings.disableQA) return false;
  const isGroupCustom = pluginState.config.groups[groupId] && !pluginState.config.groups[groupId].useGlobal;
  const qaList = isGroupCustom ? settings.qaList || [] : pluginState.config.qaList || [];
  if (!qaList.length) return false;
  const text = raw.replace(/\[CQ:[^\]]+\]/g, "").trim();
  if (text.startsWith("åˆ é—®") || text.startsWith("æ¨¡ç³Šé—®") || text.startsWith("ç²¾ç¡®é—®") || text.startsWith("åˆ é™¤é—®ç­”")) {
    return false;
  }
  for (const qa of qaList) {
    let matched = false;
    if (qa.mode === "exact") matched = text === qa.keyword;
    else if (qa.mode === "contains") matched = text.includes(qa.keyword);
    else if (qa.mode === "regex") {
      try {
        matched = new RegExp(qa.keyword).test(text);
      } catch {
      }
    }
    if (matched) {
      const reply = qa.reply.replace(/\{user\}/g, userId).replace(/\{group\}/g, groupId);
      if (reply.includes("[CQ:")) {
        await pluginState.sendGroupMsg(groupId, [{ type: "text", data: { text: reply } }]);
      } else {
        await pluginState.sendGroupText(groupId, reply);
      }
      pluginState.debug(`é—®ç­”è§¦å‘: ç¾¤ ${groupId} ç”¨æˆ· ${userId} åŒ¹é… [${qa.mode}]${qa.keyword}`);
      return true;
    }
  }
  return false;
}
async function recordActivity(groupId, userId) {
  const today = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
  const now = Date.now();
  let activity = await dbQuery.getActivityAsync(groupId, userId);
  if (!activity) {
    activity = {
      msgCount: 0,
      lastActive: 0,
      role: "member",
      msgCountToday: 0,
      lastActiveDay: today
    };
  }
  activity.msgCount++;
  activity.lastActive = now;
  if (activity.lastActiveDay !== today) {
    activity.lastActiveDay = today;
    activity.msgCountToday = 1;
  } else {
    activity.msgCountToday++;
  }
  await dbQuery.updateActivity(groupId, userId, activity);
}

const joinRequestCache = /* @__PURE__ */ new Map();
const CACHE_TTL = 3e5;
setInterval(() => {
  const now = Date.now();
  for (const [key, timestamps] of joinRequestCache) {
    const valid = timestamps.filter((t) => now - t < CACHE_TTL);
    if (valid.length === 0) joinRequestCache.delete(key);
    else joinRequestCache.set(key, valid);
  }
}, 6e4);
class GroupJoinVerifier {
  /** 
   * å¤„ç†å…¥ç¾¤ç”³è¯· 
   * è¿”å› true è¡¨ç¤ºå·²å¤„ç†ï¼ˆæ— è®ºåŒæ„è¿˜æ˜¯æ‹’ç»ï¼‰ï¼Œfalse è¡¨ç¤ºäº¤ç»™åç»­é€»è¾‘
   */
  static async handleJoinRequest(ctx, event) {
    const { group_id: groupId, user_id: userId, comment, flag } = event;
    const settings = pluginState.getGroupSettings(groupId);
    let answer = comment || "";
    answer = answer.replace(/^é—®é¢˜ï¼š.*ç­”æ¡ˆï¼š/, "").trim();
    answer = answer.replace(/[\r\n\t]/g, " ").trim();
    if (pluginState.isBlacklisted(userId) || (settings.groupBlacklist || []).includes(userId)) {
      await this.reject(ctx, flag, "æ‚¨å·²è¢«åˆ—å…¥é»‘åå•");
      this.log(groupId, userId, answer, false, "reject", "é»‘åå•ç”¨æˆ·");
      return true;
    }
    const key = `${groupId}:${userId}`;
    const now = Date.now();
    let timestamps = joinRequestCache.get(key) || [];
    timestamps.push(now);
    timestamps = timestamps.filter((t) => now - t < CACHE_TTL);
    joinRequestCache.set(key, timestamps);
    if (timestamps.length > 3) {
      await this.reject(ctx, flag, "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•");
      this.log(groupId, userId, answer, false, "reject", `é˜²åˆ·è§¦å‘ (${timestamps.length}æ¬¡/5min)`);
      return true;
    }
    const passphrase = settings.entryPassphrase;
    if (passphrase && passphrase.trim()) {
      const expected = passphrase.trim().toLowerCase();
      const actual = answer.toLowerCase();
      if (expected === actual) {
        await this.approve(ctx, flag);
        this.log(groupId, userId, answer, true, "approve", "æš—å·éªŒè¯é€šè¿‡");
        return true;
      } else {
        await this.reject(ctx, flag, "æš—å·é”™è¯¯ï¼Œè¯·é‡æ–°ç”³è¯·");
        this.log(groupId, userId, answer, false, "reject", `æš—å·é”™è¯¯ (æœŸæœ›: ${passphrase}, å®é™…: ${answer})`);
        return true;
      }
    }
    const enableFallback = settings.enableAutoApproveAfterPassphraseOff !== false;
    if (!enableFallback) {
      return false;
    }
    const rejectKw = (settings.rejectKeywords?.length ? settings.rejectKeywords : pluginState.config.rejectKeywords) || [];
    if (rejectKw.length && comment) {
      const matched = rejectKw.find((k) => comment.includes(k));
      if (matched) {
        await this.reject(ctx, flag, "éªŒè¯ä¿¡æ¯åŒ…å«æ‹’ç»å…³é”®è¯");
        this.log(groupId, userId, answer, false, "reject", `è§¦å‘æ‹’ç»è¯: ${matched}`);
        return true;
      }
    }
    if (settings.autoApprove) {
      await this.approve(ctx, flag);
      this.log(groupId, userId, answer, false, "approve", "è‡ªåŠ¨åŒæ„ (å›è½ç­–ç•¥)");
      return true;
    }
    return false;
  }
  static async approve(ctx, flag) {
    if (!pluginState.actions || !pluginState.networkConfig) return;
    try {
      await pluginState.actions.call("set_group_add_request", {
        flag,
        sub_type: "add",
        approve: true
      }, pluginState.adapterName, pluginState.networkConfig);
    } catch (e) {
      pluginState.log("error", `è‡ªåŠ¨åŒæ„å¤±è´¥: ${e}`);
    }
  }
  static async reject(ctx, flag, reason) {
    if (!pluginState.actions || !pluginState.networkConfig) return;
    try {
      await pluginState.actions.call("set_group_add_request", {
        flag,
        sub_type: "add",
        approve: false,
        reason
      }, pluginState.adapterName, pluginState.networkConfig);
    } catch (e) {
      pluginState.log("error", `è‡ªåŠ¨æ‹’ç»å¤±è´¥: ${e}`);
    }
  }
  /** è®°å½•æ—¥å¿— (å¼‚æ­¥å†™å…¥) */
  static log(groupId, userId, answer, matched, action, reason) {
    const entry = {
      groupId,
      userId,
      answer,
      passphraseMatched: matched,
      action,
      reason,
      timestamp: Date.now()
    };
    setImmediate(() => {
      try {
        const logDir = path.join(pluginState.configDir, "data", "groups", groupId);
        if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true });
        const logPath = path.join(logDir, "join_logs.json");
        let logs = [];
        if (fs.existsSync(logPath)) {
          try {
            logs = JSON.parse(fs.readFileSync(logPath, "utf-8"));
          } catch {
          }
        }
        logs.push(entry);
        const expire = Date.now() - 7776e6;
        logs = logs.filter((l) => l.timestamp > expire);
        fs.writeFileSync(logPath, JSON.stringify(logs, null, 2), "utf-8");
      } catch (e) {
        pluginState.log("error", `å†™å…¥å…¥ç¾¤æ—¥å¿—å¤±è´¥: ${e}`);
      }
    });
  }
}

let plugin_config_ui = [];
const plugin_init = async (ctx) => {
  Object.assign(pluginState, {
    logger: ctx.logger,
    actions: ctx.actions,
    adapterName: ctx.adapterName,
    networkConfig: ctx.pluginManager.config
  });
  pluginState.log("info", "ç¾¤ç®¡æ’ä»¶æ­£åœ¨åˆå§‹åŒ–...");
  plugin_config_ui = ctx.NapCatConfig.combine(
    ctx.NapCatConfig.html(`
      <div style="padding:16px;background:linear-gradient(135deg,rgba(59,130,246,0.1),rgba(30,41,59,0.1));border:1px solid rgba(59,130,246,0.3);border-radius:12px;margin-bottom:20px;">
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
          <div style="width:36px;height:36px;background:rgba(59,130,246,0.2);border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:20px;">ğŸ›¡ï¸</div>
          <div>
            <h3 style="margin:0;font-size:16px;font-weight:600;">ç¾¤ç®¡æ’ä»¶ v${pluginState.version}</h3>
            <p style="margin:2px 0 0;font-size:12px;color:#9ca3af;">napcat-plugin-groupguard</p>
          </div>
        </div>
        <p style="margin:0;font-size:13px;color:#6b7280;">
          è¯·å‰å¾€ <a href="#" onclick="window.open(window.location.origin+'/plugin/napcat-plugin-groupguard/page/config','_blank');return false;" style="color:#3B82F6;font-weight:600;">WebUI æ§åˆ¶å°</a> è¿›è¡Œè¯¦ç»†é…ç½®ã€‚
        </p>
      </div>
    `),
    ctx.NapCatConfig.text("licenseKey", "æˆæƒå¯†é’¥", "", "ä¸“ä¸šç‰ˆ/ä¼ä¸šç‰ˆæˆæƒå¯†é’¥"),
    ctx.NapCatConfig.text("ownerQQs", "ä¸»äººQQå·ï¼ˆé€—å·åˆ†éš”ï¼‰", "", "æ‹¥æœ‰æœ€é«˜æƒé™çš„QQå·"),
    ctx.NapCatConfig.boolean("debug", "è°ƒè¯•æ¨¡å¼", false, "æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—")
  );
  if (ctx.configPath) {
    pluginState.configDir = path.dirname(ctx.configPath);
  }
  if (fs.existsSync(ctx.configPath)) {
    try {
      const raw = JSON.parse(fs.readFileSync(ctx.configPath, "utf-8"));
      pluginState.config = { ...JSON.parse(JSON.stringify(DEFAULT_PLUGIN_CONFIG)), ...raw };
      const dataDir = path.join(pluginState.configDir, "data");
      const groupsDataDir = path.join(dataDir, "groups");
      if (!fs.existsSync(groupsDataDir)) fs.mkdirSync(groupsDataDir, { recursive: true });
      const oldGroupsDir = path.join(pluginState.configDir, "groups");
      if (fs.existsSync(oldGroupsDir)) {
        const files = fs.readdirSync(oldGroupsDir);
        for (const file of files) {
          if (file.endsWith(".json")) {
            const gid = file.replace(".json", "");
            const oldPath = path.join(oldGroupsDir, file);
            const newGroupDir = path.join(groupsDataDir, gid);
            if (!fs.existsSync(newGroupDir)) fs.mkdirSync(newGroupDir, { recursive: true });
            const newPath = path.join(newGroupDir, "config.json");
            if (!fs.existsSync(newPath)) {
              fs.renameSync(oldPath, newPath);
              pluginState.log("info", `å·²è¿ç§»ç¾¤é…ç½®: ${gid}`);
            } else {
              fs.unlinkSync(oldPath);
            }
          }
        }
        try {
          fs.rmdirSync(oldGroupsDir);
        } catch {
        }
      }
      if (pluginState.config.groups && Object.keys(pluginState.config.groups).length > 0) {
        for (const [gid, cfg] of Object.entries(pluginState.config.groups)) {
          const groupDir = path.join(groupsDataDir, gid);
          if (!fs.existsSync(groupDir)) fs.mkdirSync(groupDir, { recursive: true });
          fs.writeFileSync(path.join(groupDir, "config.json"), JSON.stringify(cfg, null, 2), "utf-8");
        }
      }
      if (fs.existsSync(groupsDataDir)) {
        const groupDirs = fs.readdirSync(groupsDataDir);
        for (const gid of groupDirs) {
          const groupDirPath = path.join(groupsDataDir, gid);
          const cfgPath = path.join(groupDirPath, "config.json");
          if (fs.existsSync(cfgPath)) {
            try {
              const groupCfg = JSON.parse(fs.readFileSync(cfgPath, "utf-8"));
              pluginState.config.groups[gid] = groupCfg;
              const qaPath = path.join(groupDirPath, "qa.json");
              if (fs.existsSync(qaPath)) {
                try {
                  const qaData = JSON.parse(fs.readFileSync(qaPath, "utf-8"));
                  pluginState.config.groups[gid].qaList = qaData;
                } catch (e) {
                  pluginState.log("error", `åŠ è½½ç¾¤ ${gid} QAé…ç½®å¤±è´¥: ${e}`);
                }
              }
            } catch (e) {
              pluginState.log("error", `åŠ è½½ç¾¤ ${gid} é…ç½®å¤±è´¥: ${e}`);
            }
          }
        }
      }
      saveConfig(ctx);
    } catch (e) {
      pluginState.log("error", `åŠ è½½é…ç½®å‡ºé”™: ${e}`);
    }
  }
  await initDB();
  authManager.init();
  setInterval(() => {
    saveConfig(ctx);
    if (pluginState.cleanCache) pluginState.cleanCache();
  }, 3e5);
  registerRoutes(ctx);
  try {
    const loginInfo = await ctx.actions.call("get_login_info", {}, ctx.adapterName, ctx.pluginManager.config);
    pluginState.botId = loginInfo?.user_id ? String(loginInfo.user_id) : "";
    if (pluginState.botId) pluginState.log("info", `æœºå™¨äººQQ: ${pluginState.botId}`);
  } catch {
  }
  pluginState.log("info", "ç¾¤ç®¡æ’ä»¶åˆå§‹åŒ–å®Œæˆ");
};
function registerRoutes(ctx) {
  const router = ctx.router;
  if (router.static) router.static("/webui", "webui");
  if (router.page) {
    router.page({ path: "config", title: "ç¾¤ç®¡é…ç½®", icon: "ğŸ›¡ï¸", htmlFile: "webui/config.html", description: "ç¾¤ç®¡æ’ä»¶é…ç½®é¢æ¿" });
    pluginState.log("info", "æ’ä»¶é¡µé¢å·²æ³¨å†Œ: ç¾¤ç®¡é…ç½®");
  }
  router.getNoAuth("/config", (_req, res) => {
    res.json({ code: 0, data: pluginState.config, version: pluginState.version });
  });
  router.postNoAuth("/config", (req, res) => {
    try {
      const body = req.body || {};
      const newConfig = { ...pluginState.config, ...body };
      pluginState.config = newConfig;
      if (ctx?.configPath) {
        saveConfig(ctx);
      }
      res.json({ code: 0, message: "é…ç½®å·²ä¿å­˜" });
    } catch (e) {
      res.status(500).json({ code: -1, message: String(e) });
    }
  });
  router.getNoAuth("/groups", async (_req, res) => {
    try {
      const result = await ctx.actions.call("get_group_list", {}, ctx.adapterName, ctx.pluginManager.config);
      res.json({ code: 0, data: result || [] });
    } catch (e) {
      res.status(500).json({ code: -1, message: String(e) });
    }
  });
  router.getNoAuth("/sessions", (_req, res) => {
    const list = Array.from(pluginState.sessions.values()).map((s) => ({
      userId: s.userId,
      groupId: s.groupId,
      expression: s.expression,
      attempts: s.attempts,
      maxAttempts: s.maxAttempts,
      createdAt: s.createdAt,
      remainingMs: Math.max(0, s.createdAt + pluginState.getGroupSettings(s.groupId).verifyTimeout * 1e3 - Date.now())
    }));
    res.json({ code: 0, data: list });
  });
  router.getNoAuth("/logs", (_req, res) => {
    res.json({ code: 0, data: pluginState.logBuffer });
  });
  router.postNoAuth("/logs/clear", (_req, res) => {
    pluginState.clearLogs();
    res.json({ code: 0, message: "æ—¥å¿—å·²æ¸…é™¤" });
  });
  router.getNoAuth("/activity", async (req, res) => {
    const groupId = req.query?.group_id || "";
    if (groupId) {
      const stats = await dbQuery.getAllActivity(groupId);
      res.json({ code: 0, data: stats || {} });
    } else {
      res.json({ code: 0, data: {} });
    }
  });
  router.getNoAuth("/presets", (_req, res) => {
    res.json({ code: 0, data: pluginState.config.presets || [] });
  });
  router.postNoAuth("/presets", (req, res) => {
    try {
      pluginState.config.presets = req.body?.presets || [];
      if (ctx?.configPath) {
        const dir = path.dirname(ctx.configPath);
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
        fs.writeFileSync(ctx.configPath, JSON.stringify(pluginState.config, null, 2), "utf-8");
      }
      res.json({ code: 0, message: "é¢„è®¾å·²ä¿å­˜" });
    } catch (e) {
      res.status(500).json({ code: -1, message: String(e) });
    }
  });
  pluginState.log("info", "WebUI è·¯ç”±å·²æ³¨å†Œ");
}
const plugin_get_config = async () => pluginState.config;
const plugin_set_config = async (ctx, config) => {
  pluginState.config = config;
  if (ctx?.configPath) {
    const dir = path.dirname(ctx.configPath);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(ctx.configPath, JSON.stringify(config, null, 2), "utf-8");
  }
};
const plugin_cleanup = async () => {
  pluginState.log("info", "ç¾¤ç®¡æ’ä»¶æ­£åœ¨å¸è½½...");
  clearAllSessions();
};
const plugin_onmessage = async (ctx, event) => {
  if (event.post_type !== "message") return;
  const userId = String(event.user_id);
  const raw = event.raw_message || "";
  const messageId = String(event.message_id);
  const selfId = String(event.self_id || "");
  const messageSegments = event.message || [];
  if (event.message_type === "private") {
    await handleCommand(event, ctx);
    return;
  }
  if (event.message_type === "group") {
    const groupId = String(event.group_id);
    const license = authManager.getGroupLicense(groupId);
    if (!license) {
      return;
    }
    if (userId === selfId) {
      const settings2 = pluginState.getGroupSettings(groupId);
      if (settings2.autoRecallSelf) {
        const delay = (settings2.autoRecallSelfDelay || 60) * 1e3;
        setTimeout(() => {
          pluginState.callApi("delete_msg", { message_id: messageId }).catch(() => {
          });
        }, delay);
      }
      return;
    }
    const handled = await handleCommand(event, ctx);
    if (handled) return;
    const isWhite = pluginState.isWhitelisted(userId);
    if (!isWhite) {
      const blacklisted = await handleBlacklist(groupId, userId, messageId);
      if (blacklisted) return;
    }
    const qaHandled = await handleQA(groupId, userId, raw);
    if (qaHandled) {
      await recordActivity(groupId, userId);
      cacheMessage(messageId, userId, groupId, raw, messageSegments);
      return;
    }
    if (!isWhite) {
      const recalled = await handleAutoRecall(groupId, userId, messageId);
      if (recalled) return;
    }
    if (!isWhite) {
      const filtered = await handleFilterKeywords(groupId, userId, messageId, raw, ctx);
      if (filtered) return;
    }
    if (!isWhite) {
      const typeFiltered = await handleMsgTypeFilter(groupId, userId, messageId, raw, messageSegments);
      if (typeFiltered) return;
    }
    if (!isWhite) {
      await handleSpamDetect(groupId, userId, raw);
    }
    await recordActivity(groupId, userId);
    cacheMessage(messageId, userId, groupId, raw, messageSegments);
    await handleEmojiReact(groupId, userId, messageId, selfId);
    const settings = pluginState.getGroupSettings(groupId);
    if (settings.enableVerify) {
      await handleVerifyAnswer(groupId, userId, raw, messageId);
    }
    await handleCardLockCheck(groupId, userId);
    await handleCardLockOnMessage(groupId, userId, messageId);
  }
};
const plugin_onevent = async (ctx, event) => {
  const e = event;
  const groupId = String(e.group_id);
  const license = authManager.getGroupLicense(groupId);
  if (!license && groupId !== "undefined") return;
  if (e.post_type === "request" && e.request_type === "group" && e.sub_type === "add") {
    const handled = await GroupJoinVerifier.handleJoinRequest(ctx, {
      group_id: groupId,
      user_id: String(e.user_id),
      comment: e.comment,
      flag: e.flag || "",
      sub_type: e.sub_type
    });
    if (handled) return;
    return;
  }
  if (e.post_type === "notice" && e.notice_type === "group_increase") {
    const groupId2 = String(e.group_id);
    const userId = String(e.user_id);
    const operatorId = String(e.operator_id || "");
    if (operatorId && operatorId !== userId && operatorId !== pluginState.botId) {
      const inviteeRecord = await dbQuery.getInvite(groupId2, userId);
      if (!inviteeRecord || !inviteeRecord.inviterId) {
        const newInviteeRecord = inviteeRecord || { inviteCount: 0, joinTime: Date.now(), inviterId: "" };
        newInviteeRecord.inviterId = operatorId;
        await dbQuery.updateInvite(groupId2, userId, newInviteeRecord);
        let inviterRecord = await dbQuery.getInvite(groupId2, operatorId);
        if (!inviterRecord) inviterRecord = { inviteCount: 0, joinTime: 0, inviterId: "" };
        inviterRecord.inviteCount++;
        await dbQuery.updateInvite(groupId2, operatorId, inviterRecord);
        const settings2 = pluginState.getGroupSettings(groupId2);
        if (settings2.invitePoints && settings2.invitePoints > 0) {
          let inviterSignin = await dbQuery.getSignin(groupId2, operatorId);
          if (!inviterSignin) inviterSignin = { lastSignin: 0, days: 0, points: 0 };
          inviterSignin.points += settings2.invitePoints;
          await dbQuery.updateSignin(groupId2, operatorId, inviterSignin);
          pluginState.log("info", `é‚€è¯·å¥–åŠ±: ç”¨æˆ· ${operatorId} é‚€è¯· ${userId} è¿›ç¾¤ï¼Œè·å¾— ${settings2.invitePoints} ç§¯åˆ†`);
        }
      }
    }
    if (userId === pluginState.botId) {
      pluginState.log("info", `æœºå™¨äººè‡ªèº«åŠ å…¥ç¾¤ ${groupId2}ï¼Œè·³è¿‡éªŒè¯`);
      return;
    }
    const isAdmin = await pluginState.isBotAdmin(groupId2);
    if (!isAdmin) {
      pluginState.debug(`æœºå™¨äººåœ¨ç¾¤ ${groupId2} ä¸æ˜¯ç®¡ç†å‘˜ï¼Œè·³è¿‡éªŒè¯`);
      return;
    }
    const settings = pluginState.getGroupSettings(groupId2);
    if (!settings.enableVerify) {
      await sendWelcomeMessage(groupId2, userId);
      return;
    }
    const commentKey = `${groupId2}:${userId}`;
    const comment = pluginState.pendingComments.get(commentKey);
    pluginState.pendingComments.delete(commentKey);
    const tpl = settings.welcomeMessage !== void 0 && settings.welcomeMessage !== "" ? settings.welcomeMessage : pluginState.config.welcomeMessage || "";
    const welcomeText = tpl ? tpl.replace(/\{user\}/g, userId).replace(/\{group\}/g, groupId2) : "";
    pluginState.log("info", `æ–°æˆå‘˜è¿›ç¾¤: ç”¨æˆ· ${userId} åŠ å…¥ç¾¤ ${groupId2}ï¼Œå‘èµ·éªŒè¯`);
    createVerifySession(groupId2, userId, comment, welcomeText);
    return;
  }
  if (e.post_type === "notice" && e.notice_type === "group_recall") {
    const groupId2 = String(e.group_id);
    const messageId = String(e.message_id);
    const userId = String(e.user_id);
    await handleAntiRecall(groupId2, messageId, userId);
    return;
  }
  if (e.post_type === "notice" && e.notice_type === "group_card") {
    const groupId2 = String(e.group_id);
    const userId = String(e.user_id);
    await handleCardLockCheck(groupId2, userId);
    return;
  }
  if (e.post_type === "notice" && e.notice_type === "group_decrease" && e.sub_type === "leave") {
    const groupId2 = String(e.group_id);
    const userId = String(e.user_id);
    const settings = pluginState.getGroupSettings(groupId2);
    const globalLeave = pluginState.config.leaveBlacklist;
    const groupLeave = settings.leaveBlacklist;
    if (!globalLeave && !groupLeave) return;
    if (!pluginState.config.blacklist) pluginState.config.blacklist = [];
    if (!pluginState.config.blacklist.includes(userId)) {
      pluginState.config.blacklist.push(userId);
      pluginState.log("info", `é€€ç¾¤æ‹‰é»‘: ç”¨æˆ· ${userId} é€€å‡ºç¾¤ ${groupId2}ï¼Œå·²åŠ å…¥é»‘åå•ï¼ˆ${globalLeave ? "å…¨å±€" : "ç¾¤ç‹¬ç«‹"}è®¾ç½®ï¼‰`);
      saveConfig(ctx);
    }
    return;
  }
};

export { plugin_cleanup, plugin_config_ui, plugin_get_config, plugin_init, plugin_onevent, plugin_onmessage, plugin_set_config };
